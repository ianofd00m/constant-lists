import React, {
  useState,
  useEffect,
  useMemo,
  useCallback,
  useRef,
  memo,
} from "react";
import { createPortal } from "react-dom";
import { useParams, useNavigate } from "react-router-dom";
import { toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import CardActionsModal from "./CardActionsModal";
import "./CardActionsModal.css";
import PrintingCache from "../utils/PrintingCache";
import PrintingPreferences from "../utils/PrintingPreferences";
import { CARD_TYPE_HINTS, getMainCardType } from "./cardTypeHints";
import { fetchOtagRecommendations } from "../utils/fetchOtagRecommendations";

import debounce from "lodash.debounce";
import CardModal from "./CardModal";
import CardPreview from "./CardPreview";
import CardTypeHeader from "./CardTypeHeader";
import CardGroupSortOptions from "./CardGroupSortOptions";
import ManaCost from "./ManaCost"; // Import the new component
import {
  groupCardsByManaValue,
  groupCardsByColorIdentity,
  groupCardsByCollectionStatus,
} from "./cardGroupings";

// Preferred basic land printings for consistency
const BASIC_LAND_PRINTINGS = {
  // Regular basic lands (using specific FDN collector numbers as requested)
  "Forest": "d232fcc2-12f6-401a-b1aa-ddff11cb9378",      // FDN Forest #280
  "Island": "23635e40-d040-40b7-8b98-90ed362aa028",      // FDN Island #275
  "Mountain": "1edc5050-69bd-416d-b04c-7f82de2a1901",    // FDN Mountain #279
  "Plains": "4ef17ed4-a9b5-4b8e-b4cb-2ecb7e5898c3",     // FDN Plains #272
  "Swamp": "13505c15-14e0-4200-82bd-fb9bce949e68",      // FDN Swamp #277
  "Wastes": "60682c00-c661-4a9d-8326-f3f014a04e3e",     // OGW Wastes #184a
  
  // Snow-covered basic lands - using CSP printings (except Wastes which is MH3)
  "Snow-Covered Forest": "838c915d-8153-43c2-b513-dfbe4e9388a5",   // CSP Snow-Covered Forest #155
  "Snow-Covered Island": "6abf0692-07d1-4b72-af06-93d0e338589d",   // CSP Snow-Covered Island #152
  "Snow-Covered Mountain": "0dc9a6d1-a1ca-4b8f-894d-71c2a9933f79", // CSP Snow-Covered Mountain #154
  "Snow-Covered Plains": "b1e3a010-dae3-41b6-8dd8-e31d14c3ac4a",   // CSP Snow-Covered Plains #151
  "Snow-Covered Swamp": "c4dacaf1-09b8-42bb-8064-990190fdaf81",    // CSP Snow-Covered Swamp #153
  "Snow-Covered Wastes": "ad21a874-525e-4d11-bd8e-bc44918bec40",   // MH3 Snow-Covered Wastes #309
  
  // Alternative basic land names (for older printings or special sets)
  "Basic Forest": "d232fcc2-12f6-401a-b1aa-ddff11cb9378",
  "Basic Island": "ff0ba1cf-1b05-403e-8b5e-4bbe3cfa8a89",
  "Basic Mountain": "b34bb2dc-c1af-4d77-b0b3-a0fb342a5fc6", 
  "Basic Plains": "8e592a1e-b5e1-497a-863d-9772d25d3b3f",
  "Basic Swamp": "6b28e7a6-e0ed-4c45-85dd-7c1bbfe6b3e5"
};

// Set information for preferred basic land printings
const BASIC_LAND_SET_INFO = {
  "d232fcc2-12f6-401a-b1aa-ddff11cb9378": {
    set_name: "Foundations",
    collector_number: "280",
  },
  "23635e40-d040-40b7-8b98-90ed362aa028": {
    set_name: "Foundations",
    collector_number: "275",
  },
  "1edc5050-69bd-416d-b04c-7f82de2a1901": {
    set_name: "Foundations",
    collector_number: "279",
  },
  "4ef17ed4-a9b5-4b8e-b4cb-2ecb7e5898c3": {
    set_name: "Foundations",
    collector_number: "272",
  },
  "13505c15-14e0-4200-82bd-fb9bce949e68": {
    set_name: "Foundations",
    collector_number: "277",
  },
  "87870792-e429-4eba-8193-cdce5c7b6c55": {
    set_name: "Modern Horizons 3",
    collector_number: "229",
  },
  "838c915d-8153-43c2-b513-dfbe4e9388a5": {
    set_name: "Coldsnap",
    collector_number: "155",
  },
  "6abf0692-07d1-4b72-af06-93d0e338589d": {
    set_name: "Coldsnap",
    collector_number: "152",
  },
  "0dc9a6d1-a1ca-4b8f-894d-71c2a9933f79": {
    set_name: "Coldsnap",
    collector_number: "154",
  },
  "b1e3a010-dae3-41b6-8dd8-e31d14c3ac4a": {
    set_name: "Coldsnap",
    collector_number: "151",
  },
  "c4dacaf1-09b8-42bb-8064-990190fdaf81": {
    set_name: "Coldsnap",
    collector_number: "153",
  },
};

const CATEGORY_ORDER = [
  "Commander",
  "Planeswalker",
  "Battle",
  "Creature",
  "Sorcery",
  "Instant",
  "Artifact",
  "Kindred",
  "Enchantment",
  "Land",
  "Conspiracy",
  "Dungeon",
  "Emblem",
  "Hero",
  "Phenomenon",
  "Plane",
  "Scheme",
  "Vanguard",
  "Other",
];

// Global variable for card hover preview
window.__hoveredCardName = null;

function groupCardsByType(cards, commanderNames = []) {
  // Group and count cards by type (no supertype) with proper consolidation
  const typeMap = {};
  if (!Array.isArray(cards)) {
    return [];
  }

  for (const cardObj of cards) {
    let name, type;

    // Handle null/undefined cardObj
    if (!cardObj) continue;

    if (cardObj && typeof cardObj === "object") {
      if (cardObj.card && typeof cardObj.card === "object") {
        name = cardObj.card.name;
        // If this card is a commander, force type to 'Commander'
        if (name && commanderNames.includes(name.toLowerCase())) {
          type = "Commander";
        } else {
          try {
            type =
              (name && CARD_TYPE_HINTS[name]) ||
              getMainCardType(cardObj.card.type_line) ||
              "Other";
          } catch (error) {
            console.error("Error getting card type for:", cardObj, error);
            type = "Other";
          }
        }
      } else if (cardObj.name) {
        name = cardObj.name;
        if (name && commanderNames.includes(name.toLowerCase())) {
          type = "Commander";
        } else {
          type = (name && CARD_TYPE_HINTS[name]) || "Other";
        }
      }
    } else if (typeof cardObj === "string") {
      name = cardObj;
      if (name && commanderNames.includes(name.toLowerCase())) {
        type = "Commander";
      } else {
        type = (name && CARD_TYPE_HINTS[name]) || "Other";
      }
    }

    // Skip if we couldn't determine a name
    if (!name) continue;

    if (!typeMap[type]) typeMap[type] = [];
    typeMap[type].push(cardObj);
  }

  // Apply consolidation to each type group using a simplified groupCards logic
  Object.keys(typeMap).forEach(type => {
    const cardsInType = typeMap[type];
    const consolidatedMap = {};
    
    cardsInType.forEach(cardObj => {
      const name = cardObj.card?.name || cardObj.name;
      const printing = cardObj.printing || cardObj.card?.printing || 'default';
      const foil = cardObj.foil || cardObj.card?.foil || false;
      const key = `${name}-${printing}-${foil}`;
      
      if (!consolidatedMap[key]) {
        consolidatedMap[key] = {
          name,
          count: 0,
          printing,
          cardObj,
          foil
        };
      }
      
      // Increment count by the quantity of this card
      const quantity = cardObj.count || cardObj.quantity || 1;
      consolidatedMap[key].count += quantity;
    });
    
    // Convert back to array and sort by name
    typeMap[type] = Object.values(consolidatedMap).sort((a, b) => {
      const nameA = (a.name || '').toLowerCase();
      const nameB = (b.name || '').toLowerCase();
      return nameA.localeCompare(nameB);
    });
  });

  // Use CATEGORY_ORDER for sorting, but allow for custom order for card types
  const result = [];
  // For card type grouping, use custom order, then alpha for others
  const allTypes = Object.keys(typeMap);
  let orderedTypes = [];
  if (CATEGORY_ORDER && CATEGORY_ORDER.length > 0) {
    // Only include types that exist in this deck
    orderedTypes = CATEGORY_ORDER.filter((t) => allTypes.includes(t));
    // Add any types not in CATEGORY_ORDER, sorted alphabetically
    const extraTypes = allTypes
      .filter((t) => !CATEGORY_ORDER.includes(t))
      .sort();
    orderedTypes = orderedTypes.concat(extraTypes);
  } else {
    orderedTypes = allTypes.sort();
  }
  for (const type of orderedTypes) {
    result.push({ type, cards: typeMap[type] });
  }
  return result;
}

function ensureCommanderInCards(deck) {
  if (!deck) return [];
  let cards = Array.isArray(deck.cards) ? [...deck.cards] : [];

  // Filter out any null/undefined cards
  cards = cards.filter((card) => card != null);

  // Detect commander(s) from deck object
  let commanders = [];
  if (
    deck.commander &&
    Array.isArray(deck.commander) &&
    deck.commander.length > 0
  ) {
    commanders = deck.commander.filter((comm) => comm != null);
  } else if (
    deck.commander &&
    typeof deck.commander === "object" &&
    deck.commander !== null &&
    !Array.isArray(deck.commander)
  ) {
    commanders = [deck.commander];
  } else if (typeof deck.commander === "string" && deck.commander.trim()) {
    commanders = [deck.commander];
  }

  // Also check commanderNames field for unresolved commanders
  if (
    deck.commanderNames &&
    Array.isArray(deck.commanderNames) &&
    deck.commanderNames.length > 0
  ) {
    const nameCommanders = deck.commanderNames.filter(
      (name) => typeof name === "string" && name.trim(),
    );
    commanders = commanders.concat(nameCommanders);
  }

  // If no commanders, return cards as-is
  if (commanders.length === 0) {
    return cards;
  }

  // Normalize commander names
  const commanderNames = commanders
    .map((comm) => {
      const name = comm.card?.name || comm.name || comm;
      return typeof name === "string" ? name.toLowerCase() : "";
    })
    .filter((name) => name);


  //   const name = c.card?.name || c.name || '';
  //   return typeof name === 'string' ? name.toLowerCase() : '';
  // }));

  // Remove all but the first occurrence of any card with the same name as a commander
  const seen = new Set();
  const dedupedCards = cards.filter((c) => {
    if (!c) return false;
    const cName = (c.card?.name || c.name || "").toLowerCase();
    if (commanderNames.includes(cName)) {
      if (seen.has(cName)) return false;
      seen.add(cName);
      return true;
    }
    return true;
  });

  // Add commander(s) if not present
  for (const comm of commanders) {
    if (!comm) continue;
    const commName = (comm.card?.name || comm.name || comm).toLowerCase();
    if (
      commName &&
      !dedupedCards.some(
        (c) => (c.card?.name || c.name || "").toLowerCase() === commName,
      )
    ) {
      if (typeof comm === "object" && comm !== null) {
        // Ensure we add all necessary metadata for the commander card
        const commanderCard = { card: comm };

        // Enhanced commander card patching for cmc (mana value)
        // Check all possible locations for cmc in the card data
        let manaValue = null;
        if (comm.cmc !== undefined) manaValue = comm.cmc;
        else if (comm.card?.cmc !== undefined) manaValue = comm.card.cmc;
        else if (comm.scryfall_json?.cmc !== undefined)
          manaValue = comm.scryfall_json.cmc;
        else if (comm.card?.scryfall_json?.cmc !== undefined)
          manaValue = comm.card.scryfall_json.cmc;

        // Apply the mana value to both the card and main object
        if (manaValue !== null) {
          commanderCard.card.cmc = manaValue;
          commanderCard.cmc = manaValue; // Add directly for easier access
        }

        // Enhanced commander card patching for price
        let price = null;
        if (comm.prices?.usd !== undefined) price = comm.prices.usd;
        else if (comm.card?.prices?.usd !== undefined)
          price = comm.card.prices.usd;
        else if (comm.scryfall_json?.prices?.usd !== undefined)
          price = comm.scryfall_json.prices.usd;
        else if (comm.card?.scryfall_json?.prices?.usd !== undefined)
          price = comm.card.scryfall_json.prices.usd;
        else if (comm.price) price = comm.price;

        // Apply the price to both the card and main object
        if (price !== null) {
          // Ensure price objects exist
          if (!commanderCard.card.prices) commanderCard.card.prices = {};
          if (!commanderCard.prices) commanderCard.prices = {};

          // Apply price to both locations
          commanderCard.card.prices.usd = price;
          commanderCard.prices.usd = price;
        }

        // Add printing if available
        if (
          comm.printings &&
          comm.printings.length > 0 &&
          !commanderCard.printing
        ) {
          commanderCard.printing = comm.printings[0];
        }

        dedupedCards.unshift(commanderCard);
      } else if (typeof comm === "string") {
        dedupedCards.unshift({ name: comm });
      }
    }
  }
  return dedupedCards;
}

// Group and count cards by name and printing
function groupCards(cards) {
  const map = new Map();
  if (!Array.isArray(cards)) {
    return [];
  }

  for (const cardObj of cards) {
    // Handle null/undefined cardObj
    if (!cardObj) continue;

    const name = cardObj.card?.name || cardObj.name || "";
    const printing = cardObj.printing || "";

    // Skip if we couldn't determine a name
    if (!name) continue;

    const key = name + "|" + printing;
    if (!map.has(key)) {
      map.set(key, { name, count: 1, printing, cardObj });
    } else {
      map.get(key).count++;
    }
  }
  return Array.from(map.values());
}

// Function to preload all card images
const preloadCardImages = (cards, preloadedImagesMap) => {
  if (!Array.isArray(cards)) return;

  // Extract unique cards to avoid loading duplicates
  const uniqueCards = new Map();
  cards.forEach((cardObj) => {
    if (!cardObj) return;
    const card = cardObj.card || cardObj;
    const name = card?.name || cardObj.name;
    if (!name) return;

    // Use printing ID as the key if available, otherwise use name
    const key = cardObj.printing || name;
    if (!uniqueCards.has(key)) {
      uniqueCards.set(key, { card, cardObj });
    }
  });

  // Preload each image
  uniqueCards.forEach(({ card, cardObj }, key) => {
    if (preloadedImagesMap.has(key)) return; // Skip if already preloaded

    let imageUrl;
    
    // First check if we already have image_uris in the card data (fastest)
    if (card.image_uris) {
      imageUrl = card.image_uris.normal || card.image_uris.large || card.image_uris.png;
    } else if (card.scryfall_json?.image_uris) {
      imageUrl = card.scryfall_json.image_uris.normal || card.scryfall_json.image_uris.large || card.scryfall_json.image_uris.png;
    } else if (cardObj.scryfall_json?.image_uris) {
      imageUrl = cardObj.scryfall_json.image_uris.normal || cardObj.scryfall_json.image_uris.large || cardObj.scryfall_json.image_uris.png;
    }
    
    // If no existing image_uris, construct URLs
    if (!imageUrl) {
      if (BASIC_LAND_PRINTINGS[card.name]) {
        const printingId = BASIC_LAND_PRINTINGS[card.name];
        // Use direct image URL for basic lands (no API call needed)
        imageUrl = `https://cards.scryfall.io/normal/front/${printingId.substring(0, 1)}/${printingId.substring(1, 2)}/${printingId}.jpg`;
      } else {
        const cardId = card.id || card.scryfall_json?.id || cardObj.printing;
        if (cardId) {
          // Use direct image URL format for card ID (fastest method)
          imageUrl = `https://cards.scryfall.io/normal/front/${cardId.substring(0, 1)}/${cardId.substring(1, 2)}/${cardId}.jpg`;
        } else if (card.set && card.collector_number) {
          // Keep set/collector number API call as last resort
          imageUrl = `https://api.scryfall.com/cards/${card.set.toLowerCase()}/${card.collector_number}?format=image&version=normal`;
        } else {
          // Only use named search as absolute last resort
          imageUrl = `https://api.scryfall.com/cards/named?format=image&version=normal&exact=${encodeURIComponent(card.name)}`;
        }
      }
    }

    // Create image element to trigger preloading
    const img = new Image();
    img.src = imageUrl;
    preloadedImagesMap.set(key, imageUrl);
  });
};

// Helper function to check if a modalPrice is valid (not undefined, null, or string "undefined")
const isValidModalPrice = (price) => {
  return price !== undefined && price !== null && price !== "undefined" && typeof price !== 'undefined';
};

// Helper function to extract price and special properties from a card object
// Optimized to reduce excessive logging and improve performance
const extractPrice = (c) => {
  if (!c || typeof c !== "object") {
    return { price: null, source: "invalid_card_object", cardType: "unknown" };
  }

  const cardName = c.card?.name || c.name || 'Unknown Card';
  
  // Check for explicit foil status FIRST to determine if we can use cached price
  const isExplicitlyFoil =
    c.foil === true ||
    c.card?.foil === true ||
    c.cardObj?.foil === true ||
    c.cardObj?.card?.foil === true;
  
  // CRITICAL FIX: Only use stored modal price if it was calculated with the same foil status
  // Get the stored modal price and its foil context
  const storedModalPrice = c.modalPrice || c.card?.modalPrice;
  const storedModalFoilStatus = c.modalPriceFoilStatus || c.card?.modalPriceFoilStatus;
  
  // Only use the cached price if the foil status matches what was used to calculate it
  if (isValidModalPrice(storedModalPrice) && storedModalFoilStatus === isExplicitlyFoil) {
    const typeLine = c.card?.scryfall_json?.type_line || c.scryfall_json?.type_line || c.card?.type_line || "";
    const isBasic = typeLine.toLowerCase().includes("basic land");
    const finishes = c.card?.scryfall_json?.finishes || c.scryfall_json?.finishes || [];
    const promoTypes = c.card?.scryfall_json?.promo_types || c.scryfall_json?.promo_types || [];
    const isEtched = finishes.includes('etched') || c.card?.scryfall_json?.frame_effects?.includes('etched') || c.scryfall_json?.frame_effects?.includes('etched');
    const isPromo = c.card?.scryfall_json?.promo === true || (promoTypes && promoTypes.length > 0);
    const isSpecialFinish = promoTypes.includes('textured') || promoTypes.includes('boosterfun') || promoTypes.includes('surgefoil');
    const isDigital = c.card?.scryfall_json?.digital === true || c.scryfall_json?.digital === true;
    
    return {
      price: storedModalPrice,
      source: "modal_synchronized",
      isEtched,
      isPromo,
      isSpecialFinish,
      isFoil: isExplicitlyFoil,
      isDigital,
      cardType: isExplicitlyFoil ? "foil" : "normal",
    };
  }
  
  // If cached price is invalid or foil status mismatch, calculate fresh price
  if (isValidModalPrice(storedModalPrice) && storedModalFoilStatus !== isExplicitlyFoil) {
    // Silently recalculate price when foil status doesn't match
  }

  const scryfall = c.card?.scryfall_json || c.scryfall_json || {};
  const prices = scryfall.prices || c.card?.prices || c.prices || {};
  
  // Use the same simple pricing logic as the modal for consistency
  const finishes = scryfall.finishes || [];
  const promoTypes = scryfall.promo_types || [];
  
  // Check if this is a foil-only card (matches modal logic exactly)
  const isFoilOnly = 
    (scryfall.foil === true && scryfall.nonfoil === false) ||
    (finishes.includes('foil') && !finishes.includes('nonfoil'));
  
  let price = null;
  let source = "not_found";
  let cardType = "normal";
  
  // If card is foil-only, always use foil pricing regardless of explicit foil state
  if (isFoilOnly) {
    if (finishes.includes('etched') || scryfall.frame_effects?.includes('etched')) {
      price = prices.usd_etched || prices.usd_foil || prices.usd || null;
      source = "foil_only_etched";
      cardType = "etched";
    } else if (promoTypes.includes('surgefoil') || promoTypes.includes('rainbow') || 
               promoTypes.includes('textured') || promoTypes.includes('boosterfun')) {
      price = prices.usd_foil || prices.usd || null;
      source = "foil_only_special";
      cardType = "foil";
    } else {
      price = prices.usd_foil || prices.usd || null;
      source = "foil_only_regular";
      cardType = "foil";
    }
  }
  // Otherwise use normal foil/non-foil logic (matches modal exactly)
  else if (isExplicitlyFoil) {
    // Handle etched cards
    if (finishes.includes('etched') || scryfall.frame_effects?.includes('etched')) {
      price = prices.usd_etched || prices.usd_foil || prices.usd || null;
      source = "explicit_foil_etched";
      cardType = "etched";
    }
    // Handle special foil types (surge, rainbow, etc.)
    else if (promoTypes.includes('surgefoil') || promoTypes.includes('rainbow') || 
             promoTypes.includes('textured') || promoTypes.includes('boosterfun')) {
      price = prices.usd_foil || prices.usd || null;
      source = "explicit_foil_special";
      cardType = "foil";
    }
    // Regular foil cards
    else {
      price = prices.usd_foil || prices.usd || null;
      source = "explicit_foil_regular";
      cardType = "foil";
    }
  } else {
    // Non-foil cards - use regular USD price (matches modal exactly)
    price = prices.usd || null;
    source = "regular_usd";
    cardType = "normal";
  }

  // Define additional properties for consistency with old function
  const typeLine = scryfall.type_line || c.card?.type_line || "";
  const isBasic = typeLine.toLowerCase().includes("basic land") || BASIC_LAND_PRINTINGS[cardName];
  
  // CRITICAL FIX: For basic lands, always use the preferred printing data to match modal pricing
  if (isBasic && BASIC_LAND_PRINTINGS[cardName]) {
    // For basic lands, we need to ensure price consistency with the modal
    // The modal always uses preferred printing, so deck list should too
    const preferredPrintingId = BASIC_LAND_PRINTINGS[cardName];
    
    // Check if we already have the preferred printing data
    if (scryfall.id === preferredPrintingId) {
      // We already have the preferred printing data, use its price
      // (price is already calculated above from this data)
    } else {
      // We have a different printing - this should not happen after deck loading fix
      // Silently handle non-preferred printing
    }
  }
  
  // CRITICAL FIX: Mirror the modal's logic exactly - only use $0.10 fallback when Scryfall price is null
  // If there's no Scryfall price AND this is a basic land, use $0.10 fallback (same as modal)
  if (!price && isBasic) {
    price = 0.10;
    source = "basic_land_fallback";
  }
  // Legacy fallback if no Scryfall price found for non-basic lands
  else if (!price) {
    const legacyPrice = c.price || c.usd || c.card?.price;
    if (legacyPrice) {
      price = legacyPrice;
      source = "legacy_fallback";
    }
  }
  
  const isEtched = finishes.includes('etched') || scryfall.frame_effects?.includes('etched');
  const isPromo = scryfall.promo === true || (scryfall.promo_types && scryfall.promo_types.length > 0);
  const isSpecialFinish = promoTypes.includes('textured') || promoTypes.includes('boosterfun') || promoTypes.includes('surgefoil');
  const isDigital = scryfall.digital === true || (Array.isArray(scryfall.games) && !scryfall.games.includes("paper"));
  
  // For display purposes, use explicit foil status
  const isFoil = isExplicitlyFoil;

  return {
    price,
    source,
    isEtched,
    isPromo,
    isSpecialFinish,
    isFoil,
    isDigital,
    cardType,
  };
};

// Function to parse mana cost and return image tags
const parseManaCost = (manaCost) => {
  if (!manaCost) return null;

  // Scryfall mana symbol codes are case-sensitive and use specific codes for hybrid, phyrexian, etc.
  // We'll use the Scryfall mana symbol API, which expects codes like 'w', 'u', 'b', 'r', 'g', 'c', 's', 'x', '0'-'20', 'wu', '2w', 'wp', etc.
  // The Scryfall symbol endpoint is: https://svgs.scryfall.io/card-symbols/{code}.svg

  // Extract all {X} symbols
  const manaSymbols = manaCost.match(/\{([^{}]+)\}/g);
  if (!manaSymbols) return manaCost;

  return manaSymbols.map((symbol, index) => {
    // Remove braces and convert to Scryfall code
    let code = symbol.replace(/\{|\}/g, "").toLowerCase();
    // Scryfall expects 'w', 'u', 'b', 'r', 'g', 'c', 's', 'x', '0'-'20', 'wu', '2w', 'wp', etc.
    // Replace some common aliases
    code = code.replace(/\//g, ""); // Remove slashes for hybrid/phyrexian (Scryfall uses e.g. 'wup' for {W/U/P})
    // But for hybrid, Scryfall expects e.g. 'wu' for {W/U}, 'wp' for {W/P}, '2w' for {2/W}
    // We'll handle some common cases:
    if (/^[wubrgcspx0-9]+$/.test(code)) {
      // Normal symbol, do nothing
    } else if (/^[wubrgcspx0-9]+\/[wubrgcspx0-9]+$/.test(code)) {
      // Hybrid mana, e.g. 'w/u' => 'wu'
      code = code.replace("/", "");
    } else if (/^[wubrgcspx0-9]+\/[p]$/.test(code)) {
      // Phyrexian, e.g. 'g/p' => 'gp'
      code = code.replace("/", "");
    } else if (/^2\/[wubrg]$/.test(code)) {
      // Two-color hybrid, e.g. '2/w' => '2w'
      code = code.replace("/", "");
    } else {
      // Fallback: just remove slashes
      code = code.replace(/\//g, "");
    }
    return (
      <img
        key={index}
        src={`https://svgs.scryfall.io/card-symbols/${code}.svg`}
        alt={symbol}
        className="mana-symbol"
        style={{ height: "1em", verticalAlign: "middle", marginRight: "1px" }}
      />
    );
  });
};

function CardContextMenu({ x, y, onCopyScryfallLink, onClose, onUseForDeckImage, onAddToWishlist, onAddToCollection, onRemoveFromDeck }) {
  // Trap focus for accessibility
  const menuRef = React.useRef(null);
  React.useEffect(() => {
    if (menuRef.current) menuRef.current.focus();
  }, []);

  const menuStyle = {
    position: "fixed",
    top: Math.min(y, window.innerHeight - 200), // Prevent menu from going off-screen
    left: Math.min(x, window.innerWidth - 200),
    background: "#fff",
    border: "1px solid #ccc",
    borderRadius: 6,
    boxShadow: "0 2px 8px rgba(0,0,0,0.15)",
    zIndex: 9999,
    minWidth: 180,
    padding: "4px 0",
  };

  const buttonStyle = {
    display: "block",
    width: "100%",
    background: "none",
    border: "none",
    textAlign: "left",
    padding: "8px 16px",
    fontSize: 15,
    fontWeight: 500,
    color: "#222",
    cursor: "pointer",
    transition: "background 0.15s",
  };

  const handleButtonClick = (action) => {
    action();
    onClose();
  };

  return (
    <div
      ref={menuRef}
      tabIndex={-1}
      style={menuStyle}
      onContextMenu={(e) => e.preventDefault()}
      onKeyDown={(e) => {
        if (e.key === "Escape") onClose();
      }}
    >
      <button
        style={buttonStyle}
        onClick={() => handleButtonClick(onUseForDeckImage)}
        onMouseOver={(e) => (e.currentTarget.style.background = "#e0e0e0")}
        onMouseOut={(e) => (e.currentTarget.style.background = "none")}
      >
        Use for Deck Image
      </button>
      <button
        style={buttonStyle}
        onClick={() => handleButtonClick(onAddToWishlist)}
        onMouseOver={(e) => (e.currentTarget.style.background = "#e0e0e0")}
        onMouseOut={(e) => (e.currentTarget.style.background = "none")}
      >
        Add to Wishlist
      </button>
      <button
        style={buttonStyle}
        onClick={() => handleButtonClick(onAddToCollection)}
        onMouseOver={(e) => (e.currentTarget.style.background = "#e0e0e0")}
        onMouseOut={(e) => (e.currentTarget.style.background = "none")}
      >
        Add to My Collection
      </button>
      <button
        style={buttonStyle}
        onClick={() => handleButtonClick(onCopyScryfallLink)}
        onMouseOver={(e) => (e.currentTarget.style.background = "#e0e0e0")}
        onMouseOut={(e) => (e.currentTarget.style.background = "none")}
      >
        Copy Scryfall Link
      </button>
      <hr style={{ margin: '4px 0', border: '0', borderTop: '1px solid #eee' }} />
      <button
        style={{...buttonStyle, color: "#dc3545"}}
        onClick={() => handleButtonClick(onRemoveFromDeck)}
        onMouseOver={(e) => (e.currentTarget.style.background = "#fff5f5")}
        onMouseOut={(e) => (e.currentTarget.style.background = "none")}
      >
        Remove from Deck
      </button>
    </div>
  );
}

// Memoized card component to prevent animation resets
const DeckCardRow = memo(
  ({
    cardData,
    isFoil,
    price,
    index,
    onMouseEnter,
    onClick,
    onContextMenu,
    showMana,
    hidePrices,
    isExplicitlyFoil,
    bulkEditMode,
    isSelected,
    onToggleSelection,
  }) => {
    // Get collection status for this card
    const collectionStatus = getCollectionStatus(cardData);
    
    // Determine if this is a basic land for price display fallback
    const typeLine = cardData.cardObj?.card?.scryfall_json?.type_line || 
                     cardData.cardObj?.scryfall_json?.type_line || 
                     cardData.card?.scryfall_json?.type_line ||
                     cardData.scryfall_json?.type_line ||
                     cardData.card?.type_line ||
                     "";
    const isBasic = typeLine.toLowerCase().includes("basic land") || BASIC_LAND_PRINTINGS[cardData.name];
    
    const manaCost =
      cardData.cardObj?.card?.scryfall_json?.mana_cost ||
      cardData.cardObj?.scryfall_json?.mana_cost ||
      cardData.cardObj?.card?.mana_cost ||
      cardData.cardObj?.mana_cost;

    // Create a unique animation delay based on card name hash
    const cardNameHash = cardData.name.split("").reduce((a, b) => {
      a = (a << 5) - a + b.charCodeAt(0);
      return a & a;
    }, 0);
    const animationDelay = `${-(Math.abs(cardNameHash) % 8)}s`;

    const handleRowClick = (e) => {
      if (bulkEditMode) {
        e.preventDefault();
        e.stopPropagation();
        onToggleSelection();
      } else {
        onClick();
      }
    };

    return (
      <div
        key={`${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
        className={`deck-card-row ${bulkEditMode ? 'bulk-edit-mode' : ''} ${bulkEditMode && isSelected ? 'bulk-selected' : ''}`}
        onMouseEnter={onMouseEnter}
        onClick={handleRowClick}
        onContextMenu={onContextMenu}
      >
        {/* Bulk edit checkbox */}
        {bulkEditMode && (
          <input
            type="checkbox"
            checked={isSelected}
            onChange={onToggleSelection}
            onClick={(e) => e.stopPropagation()}
            className="bulk-edit-checkbox"
            style={{
              cursor: 'pointer',
              marginRight: '3px',
            }}
          />
        )}
        
        <span className="card-count" style={{ marginLeft: '4px' }}>
          {`${cardData.count} -`}
        </span>
        <span
          className={`card-name ${isExplicitlyFoil ? "foil-active-text" : ""}`}
          style={isExplicitlyFoil ? { animationDelay } : {}}
        >
          {cardData.name}
        </span>
        {/* Show mana cost based on showMana setting */}
        <span className="card-right-group">
          {showMana && manaCost ? (
            <span className="card-mana-column">
              <ManaCost manaCost={manaCost} />
            </span>
          ) : (
            <span className="card-mana-column" />
          )}
          {/* Show prices only if not hidden */}
          {!hidePrices && (
            <span
              className={`card-price ${isExplicitlyFoil ? "foil-price" : ""} ${!price && isBasic ? "basic-land-price" : ""}`}
              title={`${isExplicitlyFoil ? "Foil" : "Non-foil"} price`}
            >
              {price ? `$${price}` : (isBasic ? "$0.10" : "N/A")}
            </span>
          )}
          {/* Always reserve space for collection status, even if hidden */}
          {!hidePrices && (
            <span style={{ width: '14px', display: 'inline-flex', justifyContent: 'center', flexShrink: 0 }}>
              {(() => {
                const getCollectionBadge = (status) => {
                  switch (status) {
                    case 'exact-match':
                      return { symbol: '✓', bg: '#4caf50', color: 'white', title: 'In collection (exact match)' };
                    case 'different-version':
                      return { symbol: 'D', bg: '#ff9800', color: 'white', title: 'In collection (different printing)' };
                    case 'not-owned':
                      return { symbol: '✗', bg: '#9e9e9e', color: 'white', title: 'Not in collection' };
                    default:
                      return null;
                  }
                };
                
                const badge = getCollectionBadge(collectionStatus);
                if (!badge) return null;
                
                return (
                  <span
                    style={{
                      fontSize: '9px',
                      fontWeight: 'bold',
                      color: badge.color,
                      display: 'inline-flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      width: '14px',
                      height: '14px',
                      borderRadius: '50%',
                      backgroundColor: badge.bg,
                      flexShrink: 0,
                    }}
                    title={badge.title}
                  >
                    {badge.symbol}
                  </span>
                );
              })()}
            </span>
          )}
        </span>
      </div>
    );
  },
);

DeckCardRow.displayName = "DeckCardRow";

// Helper function to get collection status for a card
const getCollectionStatus = (cardData) => {
  try {
    // Get collection from localStorage
    const collection = JSON.parse(localStorage.getItem('cardCollection') || '[]');
    
    // Create a map for faster lookup: printing_id + foil -> quantity
    const collectionMap = new Map();
    
    // Also create a map by card name to check for different versions
    const cardNameMap = new Map();
    
    collection.forEach(item => {
      const key = `${item.printing_id}_${item.foil}`;
      collectionMap.set(key, (collectionMap.get(key) || 0) + item.quantity);
      
      // Track card names for different version checking
      const cardName = item.name || item.card_name || item.cardName;
      if (cardName) {
        if (!cardNameMap.has(cardName)) {
          cardNameMap.set(cardName, new Set());
        }
        cardNameMap.get(cardName).add(`${item.printing_id}_${item.foil}`);
      }
    });
    
    // Get card name from various possible locations
    const cardName = cardData.name || 
                    cardData.cardObj?.name ||
                    cardData.cardObj?.card?.name ||
                    cardData.card?.name ||
                    cardData.cardObj?.card?.scryfall_json?.name ||
                    cardData.scryfall_json?.name;
    
    // Get printing ID from various possible locations
    const printingId = cardData.printing || 
                      cardData.cardObj?.printing || 
                      cardData.cardObj?.card?.printing ||
                      cardData.card?.printing ||
                      cardData.scryfall_id ||
                      cardData.id ||
                      cardData.cardObj?.scryfall_id ||
                      cardData.cardObj?.id ||
                      cardData.cardObj?.card?.scryfall_id ||
                      cardData.cardObj?.card?.id;
    
    // Get foil status
    const isFoil = cardData.foil === true || 
                  cardData.isFoil === true ||
                  cardData.cardObj?.foil === true ||
                  cardData.cardObj?.isFoil === true ||
                  cardData.cardObj?.card?.foil === true ||
                  cardData.cardObj?.card?.isFoil === true;
    
    if (!printingId || !cardName) {
      return 'not-owned';
    }
    
    // Check for exact match (same printing + foil status)
    const exactKey = `${printingId}_${isFoil}`;
    const hasExactMatch = (collectionMap.get(exactKey) || 0) > 0;
    
    if (hasExactMatch) {
      return 'exact-match';
    } else {
      // Check if we own any other version of this card
      const ownedVersions = cardNameMap.get(cardName);
      if (ownedVersions && ownedVersions.size > 0) {
        return 'different-version';
      } else {
        return 'not-owned';
      }
    }
  } catch (error) {
    console.error('Error checking collection status:', error);
    return 'not-owned';
  }
};

// GridCard component for the grid view
const GridCard = memo(({ cardData, isExplicitlyFoil, price, onMouseEnter, onClick, onContextMenu, bulkEditMode, isSelected, onToggleSelection }) => {
  // Get collection status for this card
  const collectionStatus = getCollectionStatus(cardData);
  
  // Get card image URL from various possible locations
  const getCardImageUrl = () => {
    const cardObj = cardData.cardObj || cardData;
    
    // Try multiple sources for the image
    if (cardObj?.card?.scryfall_json?.image_uris?.normal) {
      return cardObj.card.scryfall_json.image_uris.normal;
    }
    if (cardObj?.scryfall_json?.image_uris?.normal) {
      return cardObj.scryfall_json.image_uris.normal;
    }
    if (cardObj?.card?.image_uris?.normal) {
      return cardObj.card.image_uris.normal;
    }
    if (cardObj?.image_uris?.normal) {
      return cardObj.image_uris.normal;
    }
    
    // Fallback to smaller versions
    if (cardObj?.card?.scryfall_json?.image_uris?.small) {
      return cardObj.card.scryfall_json.image_uris.small;
    }
    if (cardObj?.scryfall_json?.image_uris?.small) {
      return cardObj.scryfall_json.image_uris.small;
    }
    
    // If no image found, try to construct URL from Scryfall ID
    const scryfallId = cardObj?.card?.scryfall_json?.id || 
                      cardObj?.scryfall_json?.id || 
                      cardObj?.scryfall_id ||
                      cardObj?.id;
    
    if (scryfallId) {
      return `https://cards.scryfall.io/normal/front/${scryfallId.substr(0,1)}/${scryfallId.substr(1,1)}/${scryfallId}.jpg`;
    }
    
    return null;
  };

  const imageUrl = getCardImageUrl();
  const quantity = cardData.count || cardData.quantity || 1;

  return (
    <div
      className="grid-card"
      style={{
        position: 'relative',
        aspectRatio: '5/7',
        width: '150px', // Fixed width for proper card sizing
        borderRadius: '8px',
        overflow: 'hidden',
        backgroundColor: '#f0f0f0',
        cursor: 'pointer',
        transition: 'transform 0.2s ease, box-shadow 0.2s ease',
        boxShadow: isSelected ? '0 0 0 3px #1976d2' : '0 2px 4px rgba(0,0,0,0.1)',
        opacity: bulkEditMode && !isSelected ? 0.7 : 1,
      }}
      onMouseEnter={(e) => {
        if (!bulkEditMode) {
          e.currentTarget.style.transform = 'scale(1.05)';
          e.currentTarget.style.boxShadow = isSelected ? '0 0 0 3px #1976d2' : '0 4px 8px rgba(0,0,0,0.2)';
        }
        onMouseEnter && onMouseEnter();
      }}
      onMouseLeave={(e) => {
        if (!bulkEditMode) {
          e.currentTarget.style.transform = 'scale(1)';
          e.currentTarget.style.boxShadow = isSelected ? '0 0 0 3px #1976d2' : '0 2px 4px rgba(0,0,0,0.1)';
        }
      }}
      onClick={(e) => {
        if (bulkEditMode) {
          e.preventDefault();
          e.stopPropagation();
          onToggleSelection && onToggleSelection();
        } else {
          onClick && onClick(e);
        }
      }}
      onContextMenu={onContextMenu}
    >
      {/* Card Image */}
      {imageUrl ? (
        <img
          src={imageUrl}
          alt={cardData.name}
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
          }}
          onError={(e) => {
            e.target.style.display = 'none';
            e.target.nextSibling.style.display = 'flex';
          }}
        />
      ) : null}
      
      {/* Fallback for missing image */}
      <div
        style={{
          display: imageUrl ? 'none' : 'flex',
          width: '100%',
          height: '100%',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#e0e0e0',
          color: '#666',
          fontSize: '12px',
          textAlign: 'center',
          padding: '8px',
          flexDirection: 'column',
          gap: '4px',
        }}
      >
        <div style={{ fontWeight: 'bold', lineHeight: '1.2' }}>
          {cardData.name}
        </div>
        <div style={{ fontSize: '10px', opacity: 0.7 }}>
          No Image
        </div>
      </div>

      {/* Quantity Badge */}
      {quantity > 1 && (
        <div
          style={{
            position: 'absolute',
            top: '6px',
            left: '6px',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            color: 'white',
            borderRadius: '12px',
            padding: '2px 8px',
            fontSize: '12px',
            fontWeight: 'bold',
            minWidth: '20px',
            textAlign: 'center',
          }}
        >
          {quantity}
        </div>
      )}

      {/* Foil Badge */}
      {isExplicitlyFoil && (
        <div
          style={{
            position: 'absolute',
            top: '6px',
            right: '6px',
            width: '18px',
            height: '18px',
            background: 'linear-gradient(125deg, #ff0000, #ffa500, #ffff00, #00ff00, #0000ff, #ee82ee)',
            backgroundSize: '400% 400%',
            borderRadius: '50%',
            border: '1px solid rgba(255, 255, 255, 0.8)',
            opacity: 1,
            pointerEvents: 'none',
            zIndex: 2,
            animation: 'rainbow-shift 3s linear infinite',
            willChange: 'transform, filter',
          }}
        />
      )}

      {/* Collection Status Badge */}
      {(() => {
        const getCollectionBadge = (status) => {
          switch (status) {
            case 'exact-match':
              return { symbol: '✓', bg: '#4caf50', color: 'white' };
            case 'different-version':
              return { symbol: 'D', bg: '#ff9800', color: 'white' };
            case 'not-owned':
              return { symbol: '✗', bg: '#9e9e9e', color: 'white' };
            default:
              return null;
          }
        };
        
        const badge = getCollectionBadge(collectionStatus);
        if (!badge) return null;
        
        return (
          <div
            style={{
              position: 'absolute',
              top: '6px',
              right: isExplicitlyFoil ? '32px' : '6px', // Move left if foil badge is present
              backgroundColor: badge.bg,
              color: badge.color,
              borderRadius: '50%',
              border: '1px solid rgba(255, 255, 255, 0.8)',
              width: '18px',
              height: '18px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '10px',
              fontWeight: 'bold',
            }}
            title={
              collectionStatus === 'exact-match' ? 'In collection (exact match)' :
              collectionStatus === 'different-version' ? 'In collection (different printing)' :
              'Not in collection'
            }
          >
            {badge.symbol}
          </div>
        );
      })()}

      {/* Price Badge */}
      {price && (
        <div
          style={{
            position: 'absolute',
            bottom: '6px',
            left: '6px',
            backgroundColor: 'rgba(0, 0, 0, 0.85)',
            color: 'white',
            borderRadius: '6px',
            padding: '2px 6px',
            fontSize: '11px',
            fontWeight: 'bold',
            boxShadow: '0 1px 3px rgba(0,0,0,0.3)',
          }}
        >
          ${price}
        </div>
      )}

      {/* Bulk Edit Selection Indicator */}
      {bulkEditMode && (
        <div
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            width: '30px',
            height: '30px',
            borderRadius: '50%',
            backgroundColor: isSelected ? '#1976d2' : 'rgba(255, 255, 255, 0.9)',
            border: isSelected ? 'none' : '2px solid #1976d2',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            color: isSelected ? 'white' : '#1976d2',
            fontSize: '16px',
            fontWeight: 'bold',
            boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            zIndex: 10,
          }}
        >
          {isSelected ? '✓' : ''}
        </div>
      )}
    </div>
  );
});

GridCard.displayName = "GridCard";

export default function DeckViewEdit() {
  const { id } = useParams();

  // Debug: Log the deck ID being accessed
  // console.log('[DeckViewEdit] Attempting to load deck ID:', id);

  const [modalState, setModalState] = useState({
    isOpen: false,
    cardObj: null,
  });

  // Function to handle card hover and update preview
  const handleCardHover = useCallback((cardObj) => {

    if (!cardObj) {
      // If cardObj is null, clear the preview
      setFixedPreview({ card: null });
      return;
    }

    // Extract the card name for performance optimization
    const hoverCardName = cardObj.name || cardObj.card?.name;
    
    // PERFORMANCE OPTIMIZATION: Avoid unnecessary re-renders if we're already showing this card
    // Check if the current preview is already showing the same card
    const currentPreviewCardName = fixedPreview?.card?.name || fixedPreview?.card?.card?.name;
    if (currentPreviewCardName === hoverCardName && fixedPreview?.card) {
      // Same card is already being previewed, no need to update
      return;
    }

    // Ensure we have a complete card object with all necessary data
    let card = { ...cardObj };

    // Preserve foil information
    const foilInfo = {
      foil: cardObj.foil,
      isFoil: cardObj.isFoil || cardObj.foil,
    };

    // Handle different card object structures
    // 1. Search results from Scryfall API might have a different structure
    // 2. Cards from the deck might have card data in a nested .card property
    // 3. Some objects might directly be the card

    // Extract the card name, which is the most important piece of information
    const cardName = card.name || card.card?.name;

    // Check if this is a basic land and should use preferred printing
    const isBasicLand = BASIC_LAND_PRINTINGS[cardName];
    
    // Check if this is a search result card (has forceEnglish flag)
    const isSearchResult = card.forceEnglish === true;

    // First check if we have specific printing information that we want to preserve
    // For deck cards, we should ALWAYS preserve their specific printing to maintain consistency
    // UNLESS it's a basic land, in which case we override with preferred printing
    const hasPrintingData =
      !isSearchResult &&
      !isBasicLand &&  // Override basic lands with preferred printing
      (card.printing ||
       card.card?.printing ||
       card.scryfall_json ||
       card.image_uris ||
       card.card?.scryfall_json ||
       card.card?.image_uris);

    // For basic lands, force use of preferred printing
    if (isBasicLand) {
      const preferredPrintingId = BASIC_LAND_PRINTINGS[cardName];
      
      // Construct image URLs directly from printing ID to avoid API calls
      const preferredImageUris = {
        small: `https://cards.scryfall.io/small/front/${preferredPrintingId.substring(0, 1)}/${preferredPrintingId.substring(1, 2)}/${preferredPrintingId}.jpg`,
        normal: `https://cards.scryfall.io/normal/front/${preferredPrintingId.substring(0, 1)}/${preferredPrintingId.substring(1, 2)}/${preferredPrintingId}.jpg`,
        large: `https://cards.scryfall.io/large/front/${preferredPrintingId.substring(0, 1)}/${preferredPrintingId.substring(1, 2)}/${preferredPrintingId}.jpg`,
        png: `https://cards.scryfall.io/png/front/${preferredPrintingId.substring(0, 1)}/${preferredPrintingId.substring(1, 2)}/${preferredPrintingId}.png`,
        art_crop: `https://cards.scryfall.io/art_crop/front/${preferredPrintingId.substring(0, 1)}/${preferredPrintingId.substring(1, 2)}/${preferredPrintingId}.jpg`,
        border_crop: `https://cards.scryfall.io/border_crop/front/${preferredPrintingId.substring(0, 1)}/${preferredPrintingId.substring(1, 2)}/${preferredPrintingId}.jpg`
      };
      
      card = {
        ...card,
        ...foilInfo,
        printing: preferredPrintingId,
        forceEnglish: true,
        forceHighRes: true,
        name: cardName,
        // Use pre-constructed image URLs to avoid API calls
        image_uris: preferredImageUris,
        // Keep scryfall_json null to let CardPreview handle it if needed
        scryfall_json: null,
        card: card.card
          ? {
              ...card.card,
              ...foilInfo,
              printing: preferredPrintingId,
              name: cardName,
              image_uris: preferredImageUris,
              scryfall_json: null,
            }
          : {
              name: cardName,
              ...foilInfo,
              printing: preferredPrintingId,
              image_uris: preferredImageUris,
              scryfall_json: null,
            },
      };
    }



    // Handle different processing paths based on card type and data availability
    if (isBasicLand) {
      // Basic lands: already processed above with preferred printing
      // No additional processing needed - card object is ready
    }
    else if (hasPrintingData) {
      // For deck cards, preserve the exact printing data to ensure consistency
      // between preview, modal, and deck list pricing
      
      // If we have printing-specific data, use it directly
      // Make sure nested card object has the same printing data
      if (card.card) {
        card.card.printing = card.printing || card.card.printing;
        card.card = { ...card.card, ...foilInfo }; // Preserve foil info
        if (card.scryfall_json && !card.card.scryfall_json) {
          card.card.scryfall_json = card.scryfall_json;
        }
        if (card.image_uris && !card.card.image_uris) {
          card.card.image_uris = card.image_uris;
        }
      }
      // Also preserve foil info at the top level
      card = { ...card, ...foilInfo };
      
      // CRITICAL: Don't clear image_uris or force English lookup for deck cards
      // This preserves the specific printing that the user has in their deck
    }
    // If we don't have specific printing data, or this is a search result, use name-based lookup
    else if (cardName) {

      // Create a clean card object that prioritizes just the name
      // This ensures CardPreview will use the Scryfall API to get an English version
      card = {
        ...card,
        ...foilInfo, // Preserve foil information
        forceEnglish: true, // Signal to CardPreview that we want English cards only
        forceHighRes: true, // Signal that we want high resolution images
        name: cardName, // Ensure name is at the top level for the Scryfall API URL
        // PERFORMANCE FIX: Don't clear image_uris if we already have them - this avoids API calls
        // image_uris: null,
        // Keep the card structure but update it
        card: card.card
          ? {
              ...card.card,
              ...foilInfo, // Preserve foil information in nested card too
              name: cardName,
              // PERFORMANCE FIX: Don't clear image_uris if we already have them - this avoids API calls
              // image_uris: null,
            }
          : {
              name: cardName,
              ...foilInfo,
              // Only set image_uris to null if we don't have any existing image data
              image_uris: card.image_uris || card.scryfall_json?.image_uris || null,
            },
      };
    }



    // Make sure we properly format the object for the CardPreview component
    const previewObject = {
      ...foilInfo, // Include foil information at the top level
      // Preserve printing information if available
      printing: card.printing,
      card: {
        ...card,
        ...foilInfo, // Also include foil information in the card object
        // Ensure printing information is available in nested card object too
        printing: card.printing,
      },
      top: 0, // For fixed preview these aren't used, but required by the component
      left: 0,
    };

    setFixedPreview(previewObject);
  }, []);

  const [pendingColorFetches, setPendingColorFetches] = useState(new Set());
  const isMounted = useRef(true);
  const fetchInProgress = useRef(false);
  const lastFetchedId = useRef(null);
  const preloadedImages = useRef(new Map());
  const navigate = useNavigate();

  // Global modal state for the entire page
  const [globalModalState, setGlobalModalState] = useState({
    isOpen: false,
    cardName: null,
    activeComponentId: null,
    cardObj: null,
  });

  // Debug: Track all instances
  useEffect(() => {
    return () => {
      // Component cleanup
    };
  }, []);

  const [deck, setDeck] = useState(null);
  const [edit, setEdit] = useState(false);
  const [name, setName] = useState("");
  const [cards, setCards] = useState([]);
  const [loading, setLoading] = useState(true);
  // Initialize with card back but will persist last viewed card
  const [fixedPreview, setFixedPreview] = useState({ card: null });

  const [otagSuggestions, setOtagSuggestions] = useState([]);
  const [otagLoading, setOtagLoading] = useState(false);
  const [search, setSearch] = useState("");
  const [groupBy, setGroupBy] = useState("type"); // 'type', 'manaValue', 'colorIdentity', 'collectionStatus'
  const [sortBy, setSortBy] = useState("name-asc"); // 'name-asc', 'name-desc', 'price-asc', 'price-desc'
  const [hidePrices, setHidePrices] = useState(false); // Hide card prices by default
  const [showMana, setShowMana] = useState(true); // Show mana symbols toggle
  const [viewMode, setViewMode] = useState("list"); // 'list' or 'grid' view mode
  
  // Collection update tracker to force re-render when collection changes
  const [collectionUpdateCounter, setCollectionUpdateCounter] = useState(0);
  
  // Bulk edit functionality
  const [bulkEditMode, setBulkEditMode] = useState(false);
  const [selectedCards, setSelectedCards] = useState(new Set());

  // Clear bulk selections when grouping changes
  useEffect(() => {
    setSelectedCards(new Set());
  }, [groupBy, sortBy]);
  const [searchResults, setSearchResults] = useState([]);
  const [searchLoading, setSearchLoading] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false);
  const [noResultsMsg, setNoResultsMsg] = useState("");
  const [updatingPrinting, setUpdatingPrinting] = useState(false);
  
  // Keyboard navigation for search dropdown
  const [selectedSearchIndex, setSelectedSearchIndex] = useState(-1);
  
  // Debounced function to reset selection after fast mouse movements
  const debouncedResetSelection = useMemo(
    () => debounce(() => {
      setSelectedSearchIndex(-1);
    }, 100),
    []
  );
  
  // Search results modal state
  const [showSearchModal, setShowSearchModal] = useState(false);
  const [allSearchResults, setAllSearchResults] = useState([]);
  const [searchModalLoading, setSearchModalLoading] = useState(false);

  // Tech Ideas and Sideboard state
  const [techIdeas, setTechIdeas] = useState([]);
  const [sideboard, setSideboard] = useState([]);

  // Handle escape key for modal
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === 'Escape' && showSearchModal) {
        setShowSearchModal(false);
      }
    };

    if (showSearchModal) {
      document.addEventListener('keydown', handleKeyDown);
      // Focus the modal container for keyboard accessibility
      const modalContainer = document.querySelector('[data-search-modal]');
      if (modalContainer) {
        modalContainer.focus();
      }
      
      // Prevent background scrolling when modal is open
      document.body.style.overflow = 'hidden';
    } else {
      // Restore background scrolling when modal is closed
      document.body.style.overflow = 'unset';
    }

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      // Ensure we restore scrolling on cleanup
      document.body.style.overflow = 'unset';
    };
  }, [showSearchModal]);

  // Reset keyboard selection when search results change
  useEffect(() => {
    setSelectedSearchIndex(-1);
  }, [searchResults, showDropdown]);

  // Handle oracle tag search from CardActionsModal
  const handleOracleTagSearch = useCallback((oracleTag) => {
    console.log(`[DeckViewEdit] 🏷️ Oracle tag search requested: ${oracleTag}`);
    
    // Format the oracle tag for search query
    const searchQuery = `oracletag:${oracleTag}`;
    
    try {
      // Use the existing search infrastructure
      setSearch(searchQuery);
      setShowDropdown(true);
      setSelectedSearchIndex(-1);
      
      // Clear any existing results and show loading
      setSearchResults([]);
      setNoResultsMsg("");
      setSearchLoading(true);
      
      console.log(`[DeckViewEdit] 🔍 Initiating oracle tag search with query: ${searchQuery}`);
      
      // The existing debouncedSearch will handle the actual API call
      // This will trigger the useEffect that monitors the search state
      
    } catch (error) {
      console.error('[DeckViewEdit] Error initiating oracle tag search:', error);
      setNoResultsMsg(`Error searching for oracle tag "${oracleTag}"`);
      setSearchLoading(false);
    }
  }, [setSearch, setShowDropdown, setSelectedSearchIndex, setSearchResults, setNoResultsMsg, setSearchLoading]);

  // Also add function to open search modal directly with oracle tag results
  const handleOracleTagSearchModal = useCallback(async (oracleTag) => {
    console.log(`[DeckViewEdit] 🏷️ Oracle tag search modal requested: ${oracleTag}`);
    
    try {
      setSearchModalLoading(true);
      setShowSearchModal(true);
      
      // Format the search query for oracle tags
      const searchQuery = `oracletag:${oracleTag}`;
      const encodedQuery = encodeURIComponent(searchQuery);
      
      // Set the search term so the modal title shows correctly
      setSearch(`Oracle Tag: ${oracleTag.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`);
      
      // Use Scryfall API to search for cards with this oracle tag
      const response = await fetch(`https://api.scryfall.com/cards/search?q=${encodedQuery}&unique=cards&order=name`);
      
      if (!response.ok) {
        if (response.status === 404) {
          throw new Error(`No cards found with oracle tag "${oracleTag}"`);
        }
        throw new Error(`Search failed: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      const results = data.data || [];
      
      console.log(`[DeckViewEdit] ✅ Found ${results.length} cards with oracle tag "${oracleTag}"`);
      
      setAllSearchResults(results);
      
    } catch (error) {
      console.error('[DeckViewEdit] Error in oracle tag search modal:', error);
      setAllSearchResults([]);
      setSearch(`Oracle Tag Error: ${oracleTag}`);
      // Show error in modal
      toast.error(`Failed to search for oracle tag "${oracleTag}": ${error.message}`);
    } finally {
      setSearchModalLoading(false);
    }
  }, [setSearchModalLoading, setShowSearchModal, setAllSearchResults, setSearch]);

  // Add card to shopping cart
  const handleAddToShoppingCart = useCallback((card) => {
    try {
      // Get current cart from localStorage
      const existingCart = JSON.parse(localStorage.getItem('shoppingCart') || '[]');
      
      // Check if card already exists in cart
      const existingItemIndex = existingCart.findIndex(item => item.id === card.id);
      
      if (existingItemIndex !== -1) {
        // Card exists, increment quantity
        existingCart[existingItemIndex].quantity = (existingCart[existingItemIndex].quantity || 1) + 1;
        toast.success(`Increased ${card.name} quantity to ${existingCart[existingItemIndex].quantity}`);
      } else {
        // Card doesn't exist, add new item
        const cartItem = {
          id: card.id || card.scryfall_id,
          name: card.name,
          set_name: card.set_name,
          type_line: card.type_line,
          image_url: card.image_uris?.normal || card.image_uris?.small,
          price: card.prices?.usd || card.prices?.usd_foil || '0.00',
          quantity: 1,
          dateAdded: new Date().toISOString()
        };
        
        existingCart.push(cartItem);
        toast.success(`Added ${card.name} to shopping cart`);
      }
      
      // Save updated cart
      localStorage.setItem('shoppingCart', JSON.stringify(existingCart));
      
      // Dispatch custom event to update navbar counter
      window.dispatchEvent(new CustomEvent('cartUpdated'));
      
    } catch (error) {
      console.error('Error adding to shopping cart:', error);
      toast.error('Failed to add card to shopping cart');
    }
  }, []);

  const handleAddCard = async (cardToAdd) => {
    console.log('[SEARCH DEBUG] handleAddCard called with:', cardToAdd);
    console.log('[SEARCH DEBUG] deck exists:', !!deck);
    console.log('[SEARCH DEBUG] cardToAdd exists:', !!cardToAdd);
    if (!deck || !cardToAdd) {
      console.log('[SEARCH DEBUG] Early return - missing deck or cardToAdd');
      return;
    }

    // Check if the card already exists in the deck
    const existingCardIndex = cards.findIndex((card) => {
      const cardName = card.card?.name || card.name;
      return cardName === cardToAdd.name;
    });

    console.log('[SEARCH DEBUG] existingCardIndex:', existingCardIndex);
    console.log('[SEARCH DEBUG] cardToAdd.name:', cardToAdd.name);

    if (existingCardIndex !== -1) {
      console.log('[SEARCH DEBUG] Card already exists, incrementing quantity');
      // Card already exists, increment its quantity instead of adding a new entry
      const existingCard = cards[existingCardIndex];
      const currentQuantity = existingCard.count || existingCard.quantity || 1;
      const newQuantity = currentQuantity + 1;

      // Use the existing handleUpdateCard function to update the quantity
      handleUpdateCard(existingCard, { quantity: newQuantity });

      // Force a deck state update to ensure stats and UI refresh properly
      setDeck(prevDeck => {
        if (!prevDeck) return prevDeck;
        
        const updatedCards = prevDeck.cards.map(card => {
          const cardName = card.card?.name || card.name;
          if (cardName === cardToAdd.name) {
            return {
              ...card,
              count: newQuantity,
              quantity: newQuantity
            };
          }
          return card;
        });
        
        return {
          ...prevDeck,
          cards: updatedCards,
          lastUpdated: Date.now() // Force React to detect the change
        };
      });

      toast.success(`Added ${cardToAdd.name} to deck (now ${newQuantity})`);
      return;
    }

    // Card doesn't exist, proceed with adding it as a new entry
    try {
      const token = localStorage.getItem("token");
      const apiUrl = import.meta.env.VITE_API_URL;

      // Use the Scryfall ID from the search result (now properly returned by backend)
      const scryfallId = cardToAdd.scryfall_id || cardToAdd.id;

      // // console.log(`[ADD CARD] 🔍 Scryfall ID validation for ${cardToAdd.name}:`, {
      //   scryfall_id: cardToAdd.scryfall_id,
      //   id: cardToAdd.id,
      //   finalId: scryfallId,
      //   idFormat: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(scryfallId || ''),
      //   hasValidId: !!scryfallId && scryfallId.length === 36
      // });

      if (!scryfallId) {
        console.error("[ADD CARD] ❌ No Scryfall ID found in card data:", cardToAdd);
        toast.error("Unable to add card: missing ID information");
        return;
      }

      // Determine foil status for the card being added (needed for both regular and fallback paths)
      let foilStatus = false;
      
      // ENHANCED FOIL DETECTION: Always validate against finishes, don't trust search result foil property blindly
      // First, check what finishes the card actually supports
      const finishes = cardToAdd.finishes || [];
      const supportsFoil = finishes.includes('foil') || finishes.includes('etched');
      const supportsNonFoil = finishes.includes('nonfoil');
      
      // ULTRA-CONSERVATIVE FOIL VALIDATION: Default to non-foil to prevent server errors
      if (cardToAdd.foil === true) {
        // Search result claims it's foil, but this is often wrong and causes server errors
        // Let's be extremely conservative and only accept foil for cards that are DEFINITELY foil-only
        if (finishes.length > 0 && !supportsNonFoil && supportsFoil) {
          // Only accept foil=true for foil-only cards (no nonfoil finish available)
          foilStatus = true;
        } else {
          // For all other cases, override to non-foil to prevent server errors
          foilStatus = false;
        }
      } else if (cardToAdd.foil === false) {
        foilStatus = false;
      } else {
        // No explicit foil status - analyze finishes to determine correct status
        if (!supportsNonFoil && supportsFoil && finishes.length > 0) {
          // Foil-only card - but only if we have solid finishes data
          foilStatus = true;
        } else {
          // Default to non-foil for safety in all other cases
          foilStatus = false;
        }
      }

      // Validate ID format (UUID format)
      const isValidUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(scryfallId);
      if (!isValidUUID) {
        console.error(`[ADD CARD] ⚠️ Invalid Scryfall ID format: ${scryfallId}`);
        // // console.log(`[ADD CARD] 🔄 Falling back to name-based addition...`);
        
        // Try name-based addition immediately if ID is invalid
        try {
          const nameRequestBody = {
            name: cardToAdd.name,
            count: 1,
            foil: foilStatus // Use the properly determined foil status
          };
          
          console.log(`[ADD CARD] 📤 Name-based fallback request:`, JSON.stringify(nameRequestBody, null, 2));
          
          const nameResponse = await fetch(`${apiUrl}/api/decks/${deck._id}/cards`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
            credentials: "include",
            body: JSON.stringify(nameRequestBody),
          });
          
          if (nameResponse.ok) {
            console.log(`[ADD CARD] ✅ Name-based fallback succeeded!`);
            const updatedDeck = await nameResponse.json();
            const finalDeck = {
              ...updatedDeck,
              cards: ensureCommanderInCards(updatedDeck)
            };
            setDeck(finalDeck);
            setCards(finalDeck.cards);
            toast.success(`Added ${cardToAdd.name} to deck`);
            return;
          } else {
            const nameError = await nameResponse.text();
            console.error(`[ADD CARD] ❌ Name-based fallback failed:`, nameError);
            toast.error(`Failed to add ${cardToAdd.name}: Card data issues`);
            return;
          }
        } catch (nameErr) {
          console.error(`[ADD CARD] ❌ Name-based fallback threw error:`, nameErr);
          toast.error(`Failed to add ${cardToAdd.name}: Network error`);
          return;
        }
      }

      // // console.log(`[ADD CARD] 🎯 Final foil status for ${cardToAdd.name}: ${foilStatus}`);

      // Prepare request body with the correct Scryfall ID and foil status
      const requestBody = {
        scryfall_id: scryfallId,
        count: 1,
        foil: foilStatus, // Include foil status in request
      };

      // Include printing information if available to preserve specific printing
      if (cardToAdd.set) {
        requestBody.set = cardToAdd.set;
      }
      if (cardToAdd.collector_number) {
        requestBody.collector_number = cardToAdd.collector_number;
      }
      if (cardToAdd.finishes && cardToAdd.finishes.length > 0) {
        requestBody.finishes = cardToAdd.finishes;
      }

      // // console.log(`[ADD CARD] 📤 Final request body for ${cardToAdd.name}:`, JSON.stringify(requestBody, null, 2));
      // // console.log(`[ADD CARD] 🌐 Making request to: ${apiUrl}/api/decks/${deck._id}/cards`);

      // Add the card to the deck
      const response = await fetch(`${apiUrl}/api/decks/${deck._id}/cards`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        credentials: "include",
        body: JSON.stringify(requestBody),
      });

      if (response.ok) {
        const updatedDeck = await response.json();

        // CRITICAL FIX: Ensure commander is always present in the deck after server update
        const finalDeck = {
          ...updatedDeck,
          cards: ensureCommanderInCards(updatedDeck)
        };

        // PRICE SYNC FIX: Ensure deck list and modal always show the same price
        try {
          const newlyAddedCard = finalDeck.cards.find(card => {
            const cardName = card.card?.name || card.name;
            return cardName === cardToAdd.name;
          });

          if (newlyAddedCard && scryfallId) {
            // CRITICAL FIX: Use the same prints search approach as the modal for identical data
            // This ensures we get the exact same price data that the modal would show
            const cardName = cardToAdd.name;
            const printsSearchUri = `https://api.scryfall.com/cards/search?q=unique:prints+!"${encodeURIComponent(cardName)}"`;
            
            const scryfallResponse = await fetch(printsSearchUri);
            if (scryfallResponse.ok) {
              const printsData = await scryfallResponse.json();
              
              // Find the specific printing that matches our scryfallId (same logic as modal)
              const freshScryfallData = printsData.data?.find(p => p.id === scryfallId) || printsData.data?.[0];
              
              if (freshScryfallData) {
                // // console.log(`[ADD CARD] Using prints search data for ${cardName}, found ${printsData.data?.length} printings`);
                
                // Calculate the price using the same logic as the modal for perfect synchronization
              const prices = freshScryfallData.prices || {};
              const finishes = freshScryfallData.finishes || [];
              const promoTypes = freshScryfallData.promo_types || [];
              
              // Use the exact same price calculation logic as the modal
              const isFoilOnly = 
                (freshScryfallData.foil === true && freshScryfallData.nonfoil === false) ||
                (finishes.includes('foil') && !finishes.includes('nonfoil'));
              
              let modalPrice = null;
              
              if (isFoilOnly) {
                if (finishes.includes('etched') || freshScryfallData.frame_effects?.includes('etched')) {
                  modalPrice = prices.usd_etched || prices.usd_foil || prices.usd || null;
                } else if (promoTypes.includes('surgefoil') || promoTypes.includes('rainbow') || 
                           promoTypes.includes('textured') || promoTypes.includes('boosterfun')) {
                  modalPrice = prices.usd_foil || prices.usd || null;
                } else {
                  modalPrice = prices.usd_foil || prices.usd || null;
                }
              } else if (cardToAdd.foil === true) {
                modalPrice = prices.usd_foil || prices.usd || null;
              } else {
                modalPrice = prices.usd || null;
              }
              
              // CRITICAL FIX: Mirror modal logic - only use $0.10 fallback when modalPrice is null
              if (modalPrice === null) {
                const typeLine = freshScryfallData.type_line || "";
                const isBasic = typeLine.toLowerCase().includes("basic land") || BASIC_LAND_PRINTINGS[cardToAdd.name];
                
                if (isBasic) {
                  modalPrice = 0.10;
                  // // console.log(`[ADD CARD] Using fallback modalPrice for basic land ${cardToAdd.name}: $${modalPrice}`);
                }
              }
              
              // Update the card with fresh pricing data AND the exact modal price
              const updatedCards = finalDeck.cards.map(card => {
                const cardName = card.card?.name || card.name;
                if (cardName === cardToAdd.name) {
                  // Validate modalPrice to prevent undefined values
                  const validModalPrice = (modalPrice !== undefined && modalPrice !== null && modalPrice !== "undefined") ? modalPrice : null;
                  // // console.log(`[ADD CARD] Setting modalPrice for ${cardName}: $${validModalPrice} (using prints search like modal)`);
                  return {
                    ...card,
                    // Update nested card structure with fresh Scryfall data
                    card: {
                      ...card.card,
                      scryfall_json: freshScryfallData,
                      prices: freshScryfallData.prices,
                      // Store the exact modal price for consistency
                      modalPrice: validModalPrice
                    },
                    // Also update any top-level scryfall data
                    scryfall_json: freshScryfallData,
                    prices: freshScryfallData.prices,
                    modalPrice: validModalPrice, // Store modal price at top level too
                    lastUpdated: Date.now()
                  };
                }
                return card;
              });

              finalDeck.cards = updatedCards;
              }
            }
          }
        } catch (priceError) {
          console.warn('Could not fetch fresh price data for newly added card:', priceError);
          // Non-critical error, don't prevent card addition
        }

        // CRITICAL FIX: Merge enhanced data from existing cards with server response
        // This prevents other cards from reverting to different printings when adding a new card
        const mergedCards = finalDeck.cards.map(serverCard => {
          const cardName = serverCard.card?.name || serverCard.name;
          
          // Find the existing card with enhanced data (if any)
          const existingCard = cards.find(existingCard => {
            const existingCardName = existingCard.card?.name || existingCard.name;
            return existingCardName === cardName;
          });
          
          if (existingCard && existingCard !== serverCard) {
            // Merge enhanced data from existing card with server updates
            return {
              ...serverCard,
              // Preserve enhanced scryfall data and pricing from existing card
              card: {
                ...serverCard.card,
                ...(existingCard.card?.scryfall_json && {
                  scryfall_json: existingCard.card.scryfall_json
                }),
                ...(existingCard.card?.prices && {
                  prices: existingCard.card.prices
                }),
                ...(existingCard.card?.modalPrice !== undefined && {
                  modalPrice: existingCard.card.modalPrice
                })
              },
              // Also preserve top-level enhanced data
              ...(existingCard.scryfall_json && {
                scryfall_json: existingCard.scryfall_json
              }),
              ...(existingCard.prices && {
                prices: existingCard.prices
              }),
              ...(existingCard.modalPrice !== undefined && {
                modalPrice: existingCard.modalPrice
              })
            };
          }
          
          // For new cards or cards without existing enhanced data, return as-is
          return serverCard;
        });
        
        const mergedDeck = {
          ...finalDeck,
          cards: mergedCards
        };
        
        setDeck(mergedDeck);
        setCards(mergedCards);

        toast.success(`Added ${cardToAdd.name} to deck`);
        
        // Verify the card was added with correct foil status
        setTimeout(() => {
          const addedCard = mergedCards.find(card => {
            const cardName = card.card?.name || card.name;
            return cardName === cardToAdd.name;
          });
          
          if (addedCard) {
            const actualFoilStatus = addedCard.foil === true;
            // // console.log(`[ADD CARD] Verification: ${cardToAdd.name} added with foil status: ${actualFoilStatus} (intended: ${foilStatus})`);
            
            // if (actualFoilStatus !== foilStatus) {
            //   console.warn(`[ADD CARD] Foil status mismatch detected for ${cardToAdd.name} - this should not happen with the fix`);
            // }
          }
        }, 100);
      } else {
        // Enhanced error handling with detailed diagnosis
        let errorData;
        try {
          errorData = await response.json();
        } catch (e) {
          try {
            errorData = { msg: await response.text() };
          } catch (e2) {
            errorData = { msg: 'Unknown error - could not parse response' };
          }
        }
        
        console.error(`[ADD CARD] ❌ Server error ${response.status} for ${cardToAdd.name}:`, errorData);
        console.error(`[ADD CARD] 🔍 Request that failed:`, JSON.stringify(requestBody, null, 2));
        console.error(`[ADD CARD] 📋 Original card data:`, cardToAdd);
        
        // Provide specific error messages based on the error
        if (response.status === 500 && errorData.msg && errorData.msg.includes('external service error')) {
          console.error(`[ADD CARD] 🚨 External service error detected for ${cardToAdd.name}`);
          console.error(`[ADD CARD] 🔍 Possible causes:`);
          console.error(`   - Invalid scryfall_id: ${scryfallId}`);
          console.error(`   - Invalid set/collector_number combination: ${requestBody.set}/${requestBody.collector_number}`);
          console.error(`   - Conflicting finishes data: ${JSON.stringify(requestBody.finishes)}`);
          console.error(`   - Scryfall API is down or rate-limited`);
          console.error(`   - Specific printing has corrupted data on Scryfall`);
          
          // Universal problematic card detection
          const isProblematicCard = (cardData) => {
            // Pattern-based detection for cards likely to cause issues
            const problematicPatterns = [
              // CLB set cards (Commander Legends: Battle for Baldur's Gate)
              cardData.set === 'clb',
              // Cards with very high collector numbers (often have metadata issues)
              parseInt(cardData.collector_number) > 300,
              // Cards from sets known to have Scryfall API issues
              ['afr', 'clb', 'hbg'].includes(cardData.set),
              // Cards with certain naming patterns that cause issues
              cardData.name?.includes('Gate') && cardData.set === 'clb',
              // Field of the Dead from any set (known problematic)
              cardData.name === 'Field of the Dead'
            ];
            
            return problematicPatterns.some(pattern => pattern);
          };
          
          if (isProblematicCard(cardToAdd)) {
            console.log(`[ADD CARD] 🚨 Card matches problematic patterns - activating enhanced fallback strategies`);
          }
          
          // Try a minimal request without extra metadata
          console.log(`[ADD CARD] 🔄 Attempting minimal request without metadata...`);
          const minimalRequestBody = {
            scryfall_id: scryfallId,
            count: 1,
            foil: foilStatus
          };
          
          console.log(`[ADD CARD] 📤 Minimal request body:`, JSON.stringify(minimalRequestBody, null, 2));
          
          try {
            const retryResponse = await fetch(`${apiUrl}/api/decks/${deck._id}/cards`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              credentials: "include",
              body: JSON.stringify(minimalRequestBody),
            });
            
            if (retryResponse.ok) {
              console.log(`[ADD CARD] ✅ Minimal request succeeded!`);
              const updatedDeck = await retryResponse.json();
              const finalDeck = {
                ...updatedDeck,
                cards: ensureCommanderInCards(updatedDeck)
              };
              setDeck(finalDeck);
              setCards(finalDeck.cards);
              toast.success(`Added ${cardToAdd.name} to deck`);
              return;
            } else {
              const retryError = await retryResponse.json().catch(() => ({ msg: 'Unknown error' }));
              console.error(`[ADD CARD] ❌ Minimal request also failed:`, retryError);
            }
          } catch (retryErr) {
            console.error(`[ADD CARD] ❌ Minimal request threw error:`, retryErr);
          }
          
          // Try alternative approaches to work around problematic card data
          console.log(`[ADD CARD] 🔄 Attempting alternative card addition strategies...`);
          
          // Strategy 1: Try with ultra-minimal request (just ID and count)
          try {
            console.log(`[ADD CARD] 🔄 Strategy 1: Ultra-minimal request (ID + count only)...`);
            const ultraMinimalBody = {
              scryfall_id: scryfallId,
              count: 1
              // Deliberately omit foil, set, collector_number, finishes
            };
            
            console.log(`[ADD CARD] 📤 Ultra-minimal request:`, JSON.stringify(ultraMinimalBody, null, 2));
            
            const ultraResponse = await fetch(`${apiUrl}/api/decks/${deck._id}/cards`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              credentials: "include",
              body: JSON.stringify(ultraMinimalBody),
            });
            
            if (ultraResponse.ok) {
              console.log(`[ADD CARD] ✅ Ultra-minimal request succeeded!`);
              const updatedDeck = await ultraResponse.json();
              const finalDeck = {
                ...updatedDeck,
                cards: ensureCommanderInCards(updatedDeck)
              };
              setDeck(finalDeck);
              setCards(finalDeck.cards);
              toast.success(`Added ${cardToAdd.name} to deck`);
              return;
            } else {
              const ultraError = await ultraResponse.json().catch(() => ({ msg: 'Unknown error' }));
              console.error(`[ADD CARD] ❌ Ultra-minimal request failed:`, ultraError);
            }
          } catch (ultraErr) {
            console.error(`[ADD CARD] ❌ Ultra-minimal request threw error:`, ultraErr);
          }
          
          // Strategy 2: Try name-based addition when Scryfall ID is problematic
          try {
            console.log(`[ADD CARD] 🔄 Strategy 2: Name-based addition...`);
            const nameRequestBody = {
              name: cardToAdd.name,
              count: 1,
              foil: foilStatus
            };
            
            // Include set information if available
            if (cardToAdd.set) {
              nameRequestBody.set = cardToAdd.set;
            }
            
            console.log(`[ADD CARD] 📤 Name-based request:`, JSON.stringify(nameRequestBody, null, 2));
            
            const nameResponse = await fetch(`${apiUrl}/api/decks/${deck._id}/cards`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              credentials: "include",
              body: JSON.stringify(nameRequestBody),
            });
            
            if (nameResponse.ok) {
              console.log(`[ADD CARD] ✅ Name-based request succeeded!`);
              const updatedDeck = await nameResponse.json();
              const finalDeck = {
                ...updatedDeck,
                cards: ensureCommanderInCards(updatedDeck)
              };
              setDeck(finalDeck);
              setCards(finalDeck.cards);
              toast.success(`Added ${cardToAdd.name} to deck`);
              return;
            } else {
              const nameError = await nameResponse.json().catch(() => ({ msg: 'Unknown error' }));
              console.error(`[ADD CARD] ❌ Name-based request also failed:`, nameError);
            }
          } catch (nameErr) {
            console.error(`[ADD CARD] ❌ Name-based request threw error:`, nameErr);
          }
          
          // Strategy 3: Try known alternative printings for problematic cards
          console.log(`[ADD CARD] 🔄 Strategy 3: Checking for known alternative printings...`);
          
          // Known alternative printings for problematic cards
          const knownAlternatives = {
            // Citadel Gate: CLB version has issues, PLST version is cleaner
            'c0e6f002-9a10-49a1-8604-2b8ff57732dd': {
              name: 'Citadel Gate',
              alternativeId: '7dca83ce-1b75-4dcc-a839-598106a92ca9',
              set: 'plst',
              collector_number: 'CLB-349',
              reason: 'PLST version is non-foil only, avoiding foil metadata conflicts'
            },
            // Field of the Dead: M20 #247 version causes 500 errors, try Special Guests version
            '470ca3f4-29aa-4c4c-8ff2-8cdd70c69943': {
              name: 'Field of the Dead',
              alternativeId: '2cf97898-1e05-4c0e-896f-ba6713bf6a7b',
              set: 'spg',
              collector_number: '28',
              reason: 'M20 #247 version causes external service errors, Special Guests version is stable'
            },
            // Field of the Dead: M20 version might have data issues, try Core Set 2020 Promos
            'f20a4ff7-b5e9-4b24-9e40-75ad3b6ce0e0': {
              name: 'Field of the Dead',
              alternativeId: '470ca3f4-29aa-4c4c-8ff2-8cdd70c69943',
              set: 'pm20',
              collector_number: '247s',
              reason: 'Promo version may have cleaner data than regular M20 version'
            },
            // Black Dragon Gate: CLB #347 version causes 500 errors, substitute Baldur's Gate as functional equivalent
            'c4ceb589-c741-44ac-98c8-3d997953ee61': {
              name: 'Black Dragon Gate',
              alternativeId: '2436aa14-9200-4295-8041-b682cf3c4216', // Baldur's Gate
              alternateName: 'Baldur\'s Gate',
              set: 'clb',
              collector_number: '345',
              reason: 'CLB #347 version causes external service errors, substituting Baldur\'s Gate as functional equivalent (both are gates that can tap for any color)',
              isSubstitute: true
            }
          };
          
          const alternative = knownAlternatives[scryfallId];
          if (alternative) {
            console.log(`[ADD CARD] 🔄 Found known alternative for ${alternative.name}: ${alternative.set} #${alternative.collector_number}`);
            console.log(`[ADD CARD] 📋 Reason: ${alternative.reason}`);
            
            try {
              const altRequestBody = {
                scryfall_id: alternative.alternativeId,
                count: 1,
                foil: alternative.set === 'plst' ? false : foilStatus // PLST version is non-foil only
              };
              
              console.log(`[ADD CARD] 📤 Known alternative request:`, JSON.stringify(altRequestBody, null, 2));
              
              const altResponse = await fetch(`${apiUrl}/api/decks/${deck._id}/cards`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${token}`,
                },
                credentials: "include",
                body: JSON.stringify(altRequestBody),
              });
              
              if (altResponse.ok) {
                console.log(`[ADD CARD] ✅ Known alternative succeeded: ${alternative.set} printing`);
                const updatedDeck = await altResponse.json();
                const finalDeck = {
                  ...updatedDeck,
                  cards: ensureCommanderInCards(updatedDeck)
                };
                setDeck(finalDeck);
                setCards(finalDeck.cards);
                
                // Different messages for alternatives vs substitutes
                if (alternative.isSubstitute) {
                  toast.success(`Added ${alternative.alternateName} to deck (substituted for ${alternative.name} due to server issues)`);
                } else {
                  toast.success(`Added ${cardToAdd.name} to deck (${alternative.set} printing)`);
                }
                return;
              } else {
                const altError = await altResponse.json().catch(() => ({ msg: 'Unknown error' }));
                console.error(`[ADD CARD] ❌ Known alternative also failed:`, altError);
              }
            } catch (altErr) {
              console.error(`[ADD CARD] ❌ Known alternative threw error:`, altErr);
            }
          }
          
          // Strategy 4: Try to find other alternative printings via search
          try {
            console.log(`[ADD CARD] 🔄 Strategy 4: Searching for other alternative printings...`);
            const searchResponse = await fetch(`${apiUrl}/api/cards/search?q=${encodeURIComponent(cardToAdd.name)}&limit=10`);
            if (searchResponse.ok) {
              const searchData = await searchResponse.json();
              const alternativeCards = searchData.data?.filter(card => 
                card.name === cardToAdd.name && card.id !== scryfallId
              ) || [];
              
              console.log(`[ADD CARD] 🔍 Found ${alternativeCards.length} additional alternative printings`);
              
              for (const altCard of alternativeCards) {
                console.log(`[ADD CARD] 🔄 Trying additional alternative: ${altCard.set} #${altCard.collector_number} (${altCard.id})`);
                
                const alternativeRequestBody = {
                  scryfall_id: altCard.id,
                  count: 1,
                  foil: foilStatus
                };
                
                try {
                  const altResponse = await fetch(`${apiUrl}/api/decks/${deck._id}/cards`, {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${token}`,
                    },
                    credentials: "include",
                    body: JSON.stringify(alternativeRequestBody),
                  });
                  
                  if (altResponse.ok) {
                    console.log(`[ADD CARD] ✅ Additional alternative succeeded: ${altCard.set} #${altCard.collector_number}`);
                    const updatedDeck = await altResponse.json();
                    const finalDeck = {
                      ...updatedDeck,
                      cards: ensureCommanderInCards(updatedDeck)
                    };
                    setDeck(finalDeck);
                    setCards(finalDeck.cards);
                    toast.success(`Added ${cardToAdd.name} to deck (${altCard.set} printing)`);
                    return;
                  } else {
                    console.log(`[ADD CARD] ❌ Additional alternative ${altCard.set} also failed`);
                  }
                } catch (altErr) {
                  console.log(`[ADD CARD] ❌ Additional alternative ${altCard.set} threw error:`, altErr);
                }
              }
              
              console.log(`[ADD CARD] 🔍 All alternative printings failed`);
            }
          } catch (searchErr) {
            console.error(`[ADD CARD] ❌ Alternative printing search failed:`, searchErr);
          }
          
          // Final fallback: try to manually add with minimal data and let user handle via modal
          console.log(`[ADD CARD] 🔄 Final attempt: prompting user to add manually...`);
          
          const shouldAddManually = confirm(
            `Unable to automatically add "${cardToAdd.name}" due to a server issue.\n\n` +
            `This might be a temporary problem with the card data or external services.\n\n` +
            `Would you like to try searching for this card again, or manually search for an alternative printing?`
          );
          
          if (shouldAddManually) {
            // Clear the search and let user try again
            setSearch('');
            setShowDropdown(false);
            toast.info(`Please search for "${cardToAdd.name}" again and try a different printing if available.`);
            return;
          }
          
          toast.error(`Unable to add ${cardToAdd.name}: The card data service is experiencing issues with this specific printing. Try searching for the card again or contact support if the problem persists.`);
        } else {
          toast.error(`Failed to add card to deck: ${errorData.msg || 'Unknown error'}`);
        }
      }
    } catch (error) {
      console.error("Error adding card to deck:", error);
      toast.error("Error adding card to deck. Please try again.");
    }
  };

  // Expose handleAddCard function globally for modal integration
  useEffect(() => {
    if (typeof window !== 'undefined') {
      // Clean search value before exposing globally - prevent console contamination
      let cleanSearch = search;
      if (typeof search === 'string') {
        // Reject searches with emojis or excessive length (likely console contamination)
        if (search.length > 200 || /[🚀🔍🎯]/u.test(search)) {
          cleanSearch = ''; // Reset to empty if contaminated
        }
      }
      
      // Store the current component instance and its functions globally
      window.deckViewEditComponent = {
        handleAddCard,
        handleAddToTechIdeas,
        handleAddToSideboard,
        handleMoveToSideboard,
        deck,
        cards,
        techIdeas,
        sideboard,
        search: cleanSearch, // Expose cleaned search value for external scripts
        getCommanderColorIdentity, // Expose color identity function for external scripts
        // Add helper function for external script to get filtered oracle tag results
        getFilteredOracleTagResults: async (query) => {
          if (!query.includes('otag:') && !query.includes('oracletag:')) {
            return [];
          }
          
          try {
            // Convert otag: to oracletag: for Scryfall
            let scryfallQuery = query.replace('otag:', 'oracletag:');
            
            // Fetch ALL pages from Scryfall, not just the first page
            let allResults = [];
            let nextPageUrl = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(scryfallQuery)}&unique=cards&order=name`;
            
            console.log('🔍 Oracle tag Scryfall URL (starting):', nextPageUrl);
            
            // Fetch all pages
            while (nextPageUrl) {
              const response = await fetch(nextPageUrl);
              
              if (!response.ok) {
                console.log('❌ Scryfall response not ok:', response.status);
                break;
              }
              
              const data = await response.json();
              const pageResults = data.data || [];
              allResults = allResults.concat(pageResults);
              
              console.log(`📦 Page results: ${pageResults.length} cards (total so far: ${allResults.length})`);
              
              // Check if there are more pages
              nextPageUrl = data.has_more ? data.next_page : null;
              
              // Safety check to prevent infinite loops
              if (allResults.length > 500) {
                console.warn('⚠️ Stopping pagination at 500 cards to prevent excessive requests');
                break;
              }
            }
            
            console.log(`📦 Raw Scryfall results (all pages): ${allResults.length} cards`);
            
            // Apply color identity filtering if commander exists
            const currentColorId = getCommanderColorIdentity();
            console.log('🎯 Commander color identity:', currentColorId);
            
            if (currentColorId) {
              const commanderColors = currentColorId.split('').sort();
              console.log('🎨 Commander colors array:', commanderColors);
              
              const beforeFiltering = allResults.length;
              allResults = allResults.filter(card => {
                const cardColors = (card.color_identity || []).map(c => c.toLowerCase()).sort();
                const isAllowed = cardColors.every(color => commanderColors.includes(color));
                
                // Log a few examples for debugging, especially Red/Green cards
                if (cardColors.includes('r') || cardColors.includes('g') || cardColors.length === 0) {
                  console.log(`🔍 Card "${card.name}": colors=[${cardColors.join(',')}] commander=[${commanderColors.join(',')}] allowed=${isAllowed}`);
                }
                
                return isAllowed;
              });
              
              console.log(`✅ After color filtering: ${allResults.length} cards (was ${beforeFiltering})`);
            }
            
            return allResults;
          } catch (error) {
            console.error('Error in getFilteredOracleTagResults:', error);
            return [];
          }
        }
      };
      window.deckEditApp = window.deckViewEditComponent; // Alias for backward compatibility
      
      console.log('🔗 DeckViewEdit functions exposed globally for modal integration');
    }
    
    // Cleanup on unmount
    return () => {
      if (typeof window !== 'undefined') {
        delete window.deckViewEditComponent;
        delete window.deckEditApp;
      }
    };
  }, [handleAddCard, handleAddToTechIdeas, handleAddToSideboard, handleMoveToSideboard, deck, cards, techIdeas, sideboard, search]);

  // Get deck ID from URL params (for loading a specific deck)
  // ...existing code...

  // Commander color identity cache to avoid repeated Scryfall API calls
  const [commanderColorCache, setCommanderColorCache] = useState(new Map());

  // Memoize commander names to avoid re-calculating on every render
  const commanderNames = useMemo(() => {
    if (!deck) return [];

    let commanders = [];
    if (
      deck.commander &&
      Array.isArray(deck.commander) &&
      deck.commander.length > 0
    ) {
      commanders = deck.commander.filter((comm) => comm != null);
    } else if (
      deck.commander &&
      typeof deck.commander === "object" &&
      deck.commander !== null &&
      !Array.isArray(deck.commander)
    ) {
      commanders = [deck.commander];
    } else if (typeof deck.commander === "string" && deck.commander.trim()) {
      commanders = [deck.commander];
    }

    // Also check commanderNames field for unresolved commanders
    if (
      deck.commanderNames &&
      Array.isArray(deck.commanderNames) &&
      deck.commanderNames.length > 0
    ) {
      const nameCommanders = deck.commanderNames.filter(
        (name) => typeof name === "string" && name.trim(),
      );
      commanders = commanders.concat(nameCommanders);
    }

    return commanders
      .map((comm) => {
        const name = comm.card?.name || comm.name || comm;
        return typeof name === "string" ? name.toLowerCase() : "";
      })
      .filter((name) => name);
  }, [deck]);

  const handlePrintingUpdate = async (originalCardObj, newPrintingCard) => {
    if (!originalCardObj || !newPrintingCard) {
      console.error("Invalid card data provided for printing update.");
      toast.error("Could not update card printing. Invalid data.");
      return;
    }

    // Use the specific printing update state instead of the main loading state
    // This prevents the full screen loading indicator from showing
    setUpdatingPrinting(true);
    const originalName = originalCardObj.card?.name || originalCardObj.name;

    // CRITICAL FIX: Ensure the new printing card has CMC data
    // If the new printing card doesn't have CMC, try to get it from the original card or calculate it
    if (newPrintingCard && typeof newPrintingCard.cmc === 'undefined') {
      // Try to get CMC from the original card first
      const originalCmc = originalCardObj?.scryfall_json?.cmc || 
                         originalCardObj?.card?.scryfall_json?.cmc || 
                         originalCardObj?.cmc || 
                         originalCardObj?.card?.cmc;
      
      if (originalCmc !== undefined) {
        newPrintingCard.cmc = originalCmc;
      }
    }

    try {
      // CRITICAL FIX: Determine foil capabilities of the new printing and adjust foil status accordingly
      const finishes = Array.isArray(newPrintingCard.finishes) ? newPrintingCard.finishes : [];
      const hasNonFoilFinish = finishes.includes('nonfoil');
      const hasFoilFinish = finishes.includes('foil') || finishes.includes('etched');
      
      // DEBUG: Log the foil capabilities of the new printing
      console.log(`[DEBUG FOIL] Analyzing foil capabilities for "${originalName}":`, {
        finishes: finishes,
        hasNonFoilFinish: hasNonFoilFinish,
        hasFoilFinish: hasFoilFinish,
        set: newPrintingCard.set,
        collector_number: newPrintingCard.collector_number,
        isEtched: finishes.includes('etched'),
        newPrintingCard: newPrintingCard
      });
      
      // Fallback: If finishes array is empty, try to infer from other data
      // Some older sets or special printings might not have finishes data
      let inferredHasNonFoil = hasNonFoilFinish;
      let inferredHasFoil = hasFoilFinish;
      
      if (finishes.length === 0) {
        // If no finishes data, make reasonable assumptions based on set and card type
        // Most normal sets support both foil and non-foil by default
        // Special sets like Commander's Arsenal might be foil-only
        // Very old sets (pre-foil era) are non-foil only
        const setCode = newPrintingCard.set?.toLowerCase();
        const isVeryOldSet = ['lea', 'leb', '2ed', 'arn', 'atq', 'leg', 'drk', 'fem', 'ice', 'hml', 'all', 'mir', 'vis', 'wth', 'tmp', 'sth', 'exo'].includes(setCode);
        const isSpecialFoilSet = ['ocm1', 'pcm1'].includes(setCode); // Commander's Arsenal and similar
        
        // DEBUG: Log the set analysis
        console.log(`[DEBUG FOIL] No finishes data, analyzing set "${setCode}":`, {
          isVeryOldSet: isVeryOldSet,
          isSpecialFoilSet: isSpecialFoilSet
        });
        
        if (isVeryOldSet) {
          // Pre-foil era sets - non-foil only
          inferredHasNonFoil = true;
          inferredHasFoil = false;
          console.log(`[DEBUG FOIL] Pre-foil era set detected, setting non-foil only`);
        } else if (isSpecialFoilSet) {
          // Special foil-only sets
          inferredHasNonFoil = false;
          inferredHasFoil = true;
          console.log(`[DEBUG FOIL] Special foil-only set detected`);
        } else {
          // Modern sets - assume both available
          inferredHasNonFoil = true;
          inferredHasFoil = true;
          console.log(`[DEBUG FOIL] Modern set detected, assuming both finishes available`);
        }
      } else {
        // Use actual finishes data - this is the preferred path for accurate handling
        console.log(`[DEBUG FOIL] Using actual finishes data from Scryfall for ${originalName} (${newPrintingCard.set}):`, finishes);
      }
      
      // DEBUG: Log final inferred capabilities
      console.log(`[DEBUG FOIL] Final inferred foil capabilities:`, {
        inferredHasNonFoil: inferredHasNonFoil,
        inferredHasFoil: inferredHasFoil
      });
      
      // Determine the adjusted foil status based on printing capabilities and current status
      const currentFoilStatus = originalCardObj.foil || originalCardObj.card?.foil || false;
      let adjustedFoilStatus = currentFoilStatus;
      
      // DEBUG: Log current foil status before adjustment
      console.log(`[DEBUG FOIL] Current foil status for "${originalName}": ${currentFoilStatus}`);
      
      // CRITICAL: If the modal has calculated a specific foil status for the modalPrice, use that instead
      // BUT validate it against the printing's actual capabilities
      if (newPrintingCard.modalFoilStatus !== undefined) {
        const modalSuggestedFoilStatus = newPrintingCard.modalFoilStatus;
        console.log(`[DEBUG FOIL] Modal suggested foil status for ${originalName}: ${modalSuggestedFoilStatus}`);
        
        // Validate the modal's suggestion against the printing's actual capabilities
        if (modalSuggestedFoilStatus === true) {
          // Modal wants foil - check if the printing supports foil
          if (inferredHasFoil) {
            adjustedFoilStatus = true;
            console.log(`[DEBUG FOIL] Using modal foil status (foil) - printing supports foil`);
          } else {
            // Modal wants foil but printing doesn't support it - force non-foil
            adjustedFoilStatus = false;
            console.log(`[DEBUG FOIL] Modal wanted foil but printing is non-foil only - forcing non-foil`);
          }
        } else {
          // Modal wants non-foil - check if the printing supports non-foil
          if (inferredHasNonFoil) {
            adjustedFoilStatus = false;
            console.log(`[DEBUG FOIL] Using modal foil status (non-foil) - printing supports non-foil`);
          } else {
            // Modal wants non-foil but printing doesn't support it - force foil
            adjustedFoilStatus = true;
            console.log(`[DEBUG FOIL] Modal wanted non-foil but printing is foil only - forcing foil`);
          }
        }
      } else {
        // Fallback: Calculate adjusted foil status based on printing capabilities
        // If the new printing is foil-only, force foil to true
        if (!inferredHasNonFoil && inferredHasFoil) {
          adjustedFoilStatus = true;
          console.log(`[DEBUG FOIL] New printing is foil-only, setting foil to true`);
        }
        // If the new printing is non-foil-only, force foil to false
        else if (inferredHasNonFoil && !inferredHasFoil) {
          adjustedFoilStatus = false;
          console.log(`[DEBUG FOIL] New printing is non-foil-only, setting foil to false`);
        }
        // If both finishes are available, preserve the current foil status
        else if (inferredHasNonFoil && inferredHasFoil) {
          adjustedFoilStatus = currentFoilStatus;
          console.log(`[DEBUG FOIL] Both finishes available, preserving current foil status: ${currentFoilStatus}`);
        }
        console.log(`[DEBUG FOIL] Final calculated foil status for ${originalName}: ${adjustedFoilStatus}`);
      }
      
      // CRITICAL PRICE SYNC FIX: Use modalPrice from modal if available, otherwise calculate it
      // This ensures perfect synchronization between modal display and deck list
      let modalPrice = null;
      
      // Check if modalPrice was already calculated in the modal and passed to us
      if (newPrintingCard.modalPrice !== undefined && newPrintingCard.modalPrice !== null) {
        modalPrice = newPrintingCard.modalPrice;
        console.log(`[PRINTING UPDATE] Using modalPrice from modal for ${originalName}: $${modalPrice}`);
      } else {
        // Fallback: Calculate modalPrice using the same logic as the modal
        const prices = newPrintingCard.prices || {};
        const printingFinishes = newPrintingCard.finishes || [];
        
        // Use the exact same price calculation logic as the modal
        const isFoilOnly = 
          (newPrintingCard.foil === true && newPrintingCard.nonfoil === false) ||
          (printingFinishes.includes('foil') && !printingFinishes.includes('nonfoil'));
        
        if (isFoilOnly) {
          if (printingFinishes.includes('etched') || newPrintingCard.frame_effects?.includes('etched')) {
            modalPrice = prices.usd_etched || prices.usd_foil || prices.usd || null;
          } else {
            modalPrice = prices.usd_foil || prices.usd || null;
          }
        } else if (adjustedFoilStatus) {
          modalPrice = prices.usd_foil || prices.usd || null;
        } else {
          modalPrice = prices.usd || null;
        }
        
        // CRITICAL FIX: Mirror modal logic - only use $0.10 fallback when modalPrice is null
        if (modalPrice === null) {
          const typeLine = newPrintingCard.type_line || "";
          const isBasic = typeLine.toLowerCase().includes("basic land") || BASIC_LAND_PRINTINGS[originalName];
          
          if (isBasic) {
            modalPrice = 0.10;
            console.log(`[PRINTING UPDATE] Using fallback modalPrice for basic land ${originalName}: $${modalPrice}`);
          }
        }
        
        console.log(`[PRINTING UPDATE] Calculated modalPrice for ${originalName} (${adjustedFoilStatus ? 'foil' : 'non-foil'}): $${modalPrice}`);
      }
      
      // Create a new card object structure for the updated card.
      // This will replace the old card data while preserving important fields.
      const newCardData = {
        // Preserve original ID and MongoDB refs
        _id: originalCardObj._id,
        id: originalCardObj.id,

        // Use name from the card object or directly from originalCardObj
        name: originalCardObj.card?.name || originalCardObj.name,

        // Preserve quantity/count
        count: originalCardObj.count || 1,

        // Use adjusted foil status based on new printing capabilities
        foil: adjustedFoilStatus,

        // Update with new printing ID - critical for updates to work correctly
        printing: newPrintingCard.id,
        
        // CRITICAL: Include modalPrice for price consistency - validate to prevent undefined
        modalPrice: (modalPrice !== undefined && modalPrice !== null && modalPrice !== "undefined") ? modalPrice : null,
        
        // Include mana-related fields at top level to preserve grouping by mana value
        cmc: newPrintingCard.cmc,
        mana_cost: newPrintingCard.mana_cost,
        type_line: newPrintingCard.type_line,
        color_identity: newPrintingCard.color_identity,

        // Update the full card reference
        card: {
          // Keep the original MongoDB ID if it exists
          ...(originalCardObj.card?._id
            ? { _id: originalCardObj.card._id }
            : {}),

          // Add essential fields from the new printing
          name: newPrintingCard.name,
          set: newPrintingCard.set,
          collector_number: newPrintingCard.collector_number,
          
          // Include mana-related fields to preserve grouping by mana value
          cmc: newPrintingCard.cmc,
          mana_cost: newPrintingCard.mana_cost,
          type_line: newPrintingCard.type_line,
          color_identity: newPrintingCard.color_identity,

          // CRITICAL: Set foil status at card level too
          foil: adjustedFoilStatus,

          // CRITICAL: Include modalPrice at card level too for consistency
          modalPrice: modalPrice,

          // Add prices directly to card object for easier access
          prices: newPrintingCard.prices || {},

          // Important to include image_uris at card level too for previews
          image_uris: newPrintingCard.image_uris || null,

          // Include the full Scryfall data on the card for previews
          scryfall_json: newPrintingCard,
        },

        // Update the cached full data - critical for previews to work
        scryfall_json: newPrintingCard,

        // Add image_uris for immediate preview
        image_uris: newPrintingCard.image_uris || null,
      };

      // OPTIMIZATION: Only update the UI once by doing all state updates in a batch
      // Create a single state update transaction

      // 1. First update the fixed preview if it's currently showing this card
      // This ensures that when you hover the card in the deck list, it shows the new printing
      const currentPreviewCard = fixedPreview?.card;
      const previewCardName =
        currentPreviewCard?.name || currentPreviewCard?.card?.name;

      if (currentPreviewCard && previewCardName === originalName) {
        // We need to update the preview state with the new printing information
        // console.log('[DeckViewEdit] Updating fixed preview to show the new printing');

        // Create an updated card object for the preview
        const updatedPreviewCard = {
          ...currentPreviewCard,
          printing: newPrintingCard.id,
          foil: adjustedFoilStatus, // Use adjusted foil status
          scryfall_json: newPrintingCard,
          image_uris: newPrintingCard.image_uris,
          // Update the nested card object if it exists
          ...(currentPreviewCard.card
            ? {
                card: {
                  ...currentPreviewCard.card,
                  ...newCardData.card,
                  foil: adjustedFoilStatus, // Also update in nested card object
                },
              }
            : {}),
        };

        // Update the fixed preview
        setFixedPreview({
          card: updatedPreviewCard,
          top: 0, // For fixed preview these aren't used, but required by the component
          left: 0,
        });

        // Also call handleCardHover to ensure a consistent update
        handleCardHover({
          name: originalName,
          printing: newPrintingCard.id,
          foil: adjustedFoilStatus, // Include adjusted foil status
          scryfall_json: newPrintingCard,
          image_uris: newPrintingCard.image_uris,
        });
      }

      // 2. Update the modal state to reflect the newly selected printing
      if (modalState.isOpen && modalState.cardObj) {
        const updatedModalCard = {
          ...modalState.cardObj,
          printing: newPrintingCard.id,
          foil: adjustedFoilStatus, // Use adjusted foil status
          scryfall_json: newPrintingCard,
          image_uris: newPrintingCard.image_uris,
          card: {
            ...modalState.cardObj.card,
            ...newCardData.card,
            foil: adjustedFoilStatus, // Also update in nested card object
          },
        };

        setModalState({
          isOpen: true,
          cardObj: updatedModalCard,
        });
      }

      // 3. Update all matching cards in the master cards list
      const updatedCards = cards.map((c) => {
        if (c && (c.card?.name || c.name) === originalName) {
          
          console.log(`[PRINTING UPDATE] Updating card "${originalName}" in deck list with modalPrice: $${modalPrice}`);
          
          // Return a new object with the updated printing data
          const updated = {
            ...c,
            printing: newPrintingCard.id,
            foil: adjustedFoilStatus, // Use the adjusted foil status
            scryfall_json: newPrintingCard,
            image_uris: newPrintingCard.image_uris,
            modalPrice: modalPrice, // CRITICAL: Update modalPrice for immediate price sync
            // Include mana-related fields at top level
            cmc: newCardData.cmc,
            mana_cost: newCardData.mana_cost,
            type_line: newCardData.type_line,
            color_identity: newCardData.color_identity,
            card: {
              ...c.card,
              ...newCardData.card,
              foil: adjustedFoilStatus, // Also update foil status in nested card object
              modalPrice: modalPrice, // Also update modalPrice in nested card object
            },
          };
          
          return updated;
        }
        return c;
      });

      // Update local state for immediate UI feedback (before API call)
      setCards(updatedCards);

      // Helper function to check if a string is a valid MongoDB ObjectId
      const isValidObjectId = (id) => {
        return id && typeof id === "string" && /^[0-9a-fA-F]{24}$/.test(id);
      };

      // Create a clean version of the cards for the API
      const cleanCards = updatedCards.map((card) => {
        // CRITICAL FIX: Validate modalPrice to prevent undefined from being sent to server
        const validModalPrice = (card.modalPrice !== undefined && card.modalPrice !== null && card.modalPrice !== "undefined") ? card.modalPrice : null;
        
        // Basic card info that's always needed
        let cleanCard = {
          name: card.card?.name || card.name,
          count: card.count || 1,
          printing: card.printing || null,
          ...(card.foil !== undefined ? { foil: card.foil } : {}),
          // CRITICAL FIX: Include modalPrice to persist synchronized pricing - only if not null
          ...(validModalPrice !== null ? { modalPrice: validModalPrice } : {}),
        };

        // Debug logging for modalPrice persistence
        if (validModalPrice !== null) {
          console.log(`[CLEAN CARDS] Including modalPrice for ${cleanCard.name}: $${validModalPrice}`);
        }

        // Handle MongoID references properly
        if (card._id && isValidObjectId(card._id)) {
          cleanCard._id = card._id;
        }

        // Handle the card reference based on what we have
        if (card.card) {
          if (typeof card.card === "object" && card.card !== null) {
            if (card.card._id && isValidObjectId(card.card._id)) {
              cleanCard.card = card.card._id;
            } else if (card.card.name) {
              cleanCard.cardName = card.card.name;
            }
          } else if (typeof card.card === "string") {
            if (isValidObjectId(card.card)) {
              cleanCard.card = card.card;
            } else {
              cleanCard.cardName = card.card;
            }
          }
        }

        return cleanCard;
      });

      // console.log('[DeckViewEdit] Sending updated cards to server:', cleanCards);

      // DEBUG: Log what we're actually sending to the server for modalPrice
      const cardsWithModalPriceBeingSent = cleanCards.filter(card => card.modalPrice !== undefined);
      if (cardsWithModalPriceBeingSent.length > 0) {
        console.log(`[SERVER SEND] Sending ${cardsWithModalPriceBeingSent.length} cards with modalPrice to server:`, 
          cardsWithModalPriceBeingSent.map(card => `${card.name}: $${card.modalPrice}`).join(', ')
        );
        console.log(`[SERVER SEND] Full card data being sent:`, JSON.stringify(cardsWithModalPriceBeingSent[0], null, 2));
      } else {
        console.log(`[SERVER SEND] NO cards with modalPrice being sent to server`);
      }

      // Make the API call to save changes to the server
      const apiUrl = import.meta.env.VITE_API_URL;
      const res = await fetch(`${apiUrl}/api/decks/${id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          cards: cleanCards,
          name: name || deck.name,
          techIdeas: techIdeas,
          sideboard: sideboard,
        }),
      });

      // Check if the response is ok
      if (!res.ok) {
        let errorText;
        try {
          const errorData = await res.json();
          errorText = JSON.stringify(errorData);
          console.error(`Server error (${res.status}):`, errorData);
        } catch (e) {
          errorText = await res.text();
          console.error(`Server error (${res.status}):`, errorText);
        }
        throw new Error(`Server responded with ${res.status}: ${errorText}`);
      }

      const updatedCardData = await res.json();
      // console.log('[DeckViewEdit] Server returned updated deck:', updatedCardData);

      // CRITICAL FIX: Clean up modalPrice values from server response - convert undefined to null
      if (updatedCardData?.cards) {
        updatedCardData.cards = updatedCardData.cards.map(serverCard => {
          const cleanServerModalPrice = (serverCard.modalPrice !== undefined && serverCard.modalPrice !== null && serverCard.modalPrice !== "undefined") ? serverCard.modalPrice : null;
          const cleanServerNestedModalPrice = (serverCard.card?.modalPrice !== undefined && serverCard.card?.modalPrice !== null && serverCard.card?.modalPrice !== "undefined") ? serverCard.card?.modalPrice : null;
          
          return {
            ...serverCard,
            modalPrice: cleanServerModalPrice,
            ...(serverCard.card ? {
              card: {
                ...serverCard.card,
                modalPrice: cleanServerNestedModalPrice
              }
            } : {})
          };
        });
      }

      // DEBUG: Check if server returns modalPrice data
      const serverCards = updatedCardData?.cards || [];
      const serverCardsWithModalPrice = serverCards.filter(card => (card.modalPrice !== null && card.modalPrice !== undefined) || (card.card?.modalPrice !== null && card.card?.modalPrice !== undefined));
      if (serverCardsWithModalPrice.length > 0) {
        console.log(`[SERVER RESPONSE] Server returned ${serverCardsWithModalPrice.length} cards with modalPrice:`, 
          serverCardsWithModalPrice.map(card => {
            const name = card.card?.name || card.name;
            const modalPrice = card.modalPrice || card.card?.modalPrice;
            return `${name}: $${modalPrice}`;
          }).join(', ')
        );
      } else {
        console.log(`[SERVER RESPONSE] Server returned NO cards with modalPrice`);
      }

      // Update the deck state ONLY ONCE, with the combined changes
      // No need to trigger another state update since we've already
      // updated the UI with our local changes
      setDeck((prev) => ({
        ...prev,
        ...updatedCardData,
        cards: updatedCards, // Keep our local card state with all the UI-needed fields
      }));

      // CRITICAL FIX: Update PrintingCache so modal reopening uses the correct printing
      // This ensures consistency between deck list and modal when reopening
      const selectedPrinting = {
        id: newPrintingCard.id,
        set: newPrintingCard.set,
        collector_number: newPrintingCard.collector_number,
        scryfall_id: newPrintingCard.id,
        set_name: newPrintingCard.set_name,
        rarity: newPrintingCard.rarity,
        prices: newPrintingCard.prices,
        finishes: newPrintingCard.finishes,
        modalPrice: modalPrice
      };
      
      // Get existing cached printings to preserve the full list
      const existingCache = PrintingCache.get(originalName);
      
      if (existingCache && existingCache.printings && Array.isArray(existingCache.printings) && existingCache.printings.length > 1) {
        // Only update cache if we have multiple printings cached (preserve full list)
        let allPrintings = existingCache.printings.map(printing => {
          if (printing.id === newPrintingCard.id) {
            // Update the existing printing with new data
            return { ...printing, ...selectedPrinting };
          }
          return printing;
        });
        
        // If the new printing wasn't in the existing list, add it
        if (!allPrintings.find(p => p.id === newPrintingCard.id)) {
          allPrintings.push(selectedPrinting);
        }
        
        // Update cache with all printings preserved, but new printing selected
        PrintingCache.set(originalName, allPrintings, selectedPrinting);
        console.log(`[PRINTING UPDATE] Updated PrintingCache for "${originalName}" with ${allPrintings.length} total printings, selected: ${newPrintingCard.set?.toUpperCase()} #${newPrintingCard.collector_number}`);
      } else {
        // Don't update cache if we only have 1 printing or no cache - let modal fetch full list
        // This prevents creating single-printing caches that look incomplete
        console.log(`[PRINTING UPDATE] Skipping PrintingCache update for "${originalName}" - insufficient cached data (will let modal fetch full list)`);
      }

      toast.success(`Updated ${originalName} to ${newPrintingCard.set_name}.`);
    } catch (error) {
      console.error("Failed to save updated deck:", error);

      // Provide more specific error messages
      if (error.message.includes("mongoose")) {
        toast.error(
          "Failed to save printing change due to a server connection issue. Please try again.",
        );
      } else if (error.message.includes("not defined")) {
        toast.error(
          "Failed to save printing change due to a code issue. The developers have been notified.",
        );
        console.error(
          "Code Error in handlePrintingUpdate:",
          error.message,
          error.stack,
        );
      } else {
        toast.error(`Failed to save printing change: ${error.message}`);
      }
    } finally {
      // Reset the printing update state instead of the main loading state
      setUpdatingPrinting(false);
    }
  };

  // Global Escape key handler to close modal at any time
  useEffect(() => {
    const handleGlobalKeyDown = (e) => {
      if (e.key === "Escape" && modalState.isOpen) {
        e.preventDefault();
        // console.log('[DeckViewEdit] Global Escape key pressed, closing modal'); // DEBUG
        setModalState({ isOpen: false, cardObj: null });
      }
    };

    // Add event listener when component mounts
    window.addEventListener("keydown", handleGlobalKeyDown);

    return () => {
      // Clean up event listener when component unmounts
      window.removeEventListener("keydown", handleGlobalKeyDown);
    };
  }, []); // Empty dependency array - this effect runs once on mount

  // Global Escape key handler for modal
  useEffect(() => {
    function handleGlobalEscape(e) {
      if (e.key === "Escape" && modalState.isOpen) {
        // console.log('[DeckViewEdit] Global Escape key pressed, closing modal'); // DEBUG
        e.preventDefault();
        e.stopPropagation();
        setModalState({ isOpen: false, cardObj: null });
      }
    }

    // Add listener when modal is open, remove when closed
    if (modalState.isOpen) {
      // console.log('[DeckViewEdit] Adding global Escape key listener'); // DEBUG
      document.addEventListener("keydown", handleGlobalEscape, true); // Use capture phase
      window.addEventListener("keydown", handleGlobalEscape, true); // Also listen on window
    }

    return () => {
      // console.log('[DeckViewEdit] Removing global Escape key listener'); // DEBUG
      document.removeEventListener("keydown", handleGlobalEscape, true);
      window.removeEventListener("keydown", handleGlobalEscape, true);
    };
  }, [modalState.isOpen]);

  useEffect(() => {
    isMounted.current = true;

    // Validate deck ID format (should be 24 character hex string)
    if (!id || !/^[0-9a-fA-F]{24}$/.test(id)) {
      console.error("[DeckViewEdit] Invalid deck ID format:", id);
      toast.error("Invalid deck ID. Redirecting to home page...");
      setTimeout(() => {
        navigate("/");
      }, 2000);
      setLoading(false);
      return;
    }

    // Prevent multiple simultaneous fetches or duplicate fetches for same ID
    if (fetchInProgress.current || lastFetchedId.current === id) {
      // console.log('[DEBUG] Skipping duplicate fetch for deck ID:', id);
      return;
    }

    // console.log('[DEBUG] Starting fetch for deck ID:', id);
    fetchInProgress.current = true;
    lastFetchedId.current = id;

    const abortController = new AbortController();

    // Add timeout to prevent hanging requests
    const timeoutId = setTimeout(() => {
      console.error("Request timeout for deck ID:", id);
      abortController.abort();
    }, 10000); // 10 second timeout

    // Add cache-busting parameter to force fresh requests
    const cacheBust = `?_cb=${Date.now()}`;
    const apiUrl = import.meta.env.VITE_API_URL;
    fetch(`${apiUrl}/api/decks/${id}${cacheBust}`, {
      signal: abortController.signal,
      cache: "no-cache",
      headers: {
        "Cache-Control": "no-cache",
        Pragma: "no-cache",
      },
    })
      .then(async (r) => {
        clearTimeout(timeoutId);
        // console.log('[DEBUG] API Response:', r.status, 'for deck ID:', id); // Track which request succeeds/fails

        if (!r.ok) {
          if (r.status === 404) {
            console.error("404 Error for deck ID:", id);
            throw new Error("DECK_NOT_FOUND");
          }
          throw new Error(`HTTP ${r.status}: ${r.statusText}`);
        }
        return r.json();
      })
      .then((data) => {
        if (!isMounted.current) return;

        console.log('[DEBUG] Deck data loaded from server:', {
          name: data.name,
          cards: data.cards?.length,
          techIdeas: data.techIdeas?.length || 0,
          sideboard: data.sideboard?.length || 0
        });

        // 🐛 DEBUG: Log foil status in containers
        if (data.techIdeas?.length > 0) {
          console.log('[DEBUG] Tech Ideas cards:', data.techIdeas.map(card => ({
            name: card.name,
            foil: card.foil,
            printing: card.printing
          })));
        }
        if (data.sideboard?.length > 0) {
          console.log('[DEBUG] Sideboard cards:', data.sideboard.map(card => ({
            name: card.name,
            foil: card.foil,
            printing: card.printing
          })));
        }

        // console.log('[DEBUG] Processing deck data:', data?.name, 'Cards count:', data?.cards?.length);

        // CRITICAL FIX: Clean up modalPrice values from initial data load - convert undefined to null
        if (data?.cards) {
          data.cards = data.cards.map(card => {
            const cleanModalPrice = (card.modalPrice !== undefined && card.modalPrice !== null && card.modalPrice !== "undefined") ? card.modalPrice : null;
            const cleanNestedModalPrice = (card.card?.modalPrice !== undefined && card.card?.modalPrice !== null && card.card?.modalPrice !== "undefined") ? card.card?.modalPrice : null;
            
            // 🔧 PRINTING PREFERENCES: Apply user's preferred printing if available
            const cardName = card.card?.name || card.name;
            const userPreference = PrintingPreferences.get(cardName);
            
            let updatedCard = {
              ...card,
              modalPrice: cleanModalPrice,
              ...(card.card ? {
                card: {
                  ...card.card,
                  modalPrice: cleanNestedModalPrice
                }
              } : {})
            };
            
            // If user has a printing preference, override the server data
            if (userPreference && userPreference.id) {
              // console.log(`[DECK LOAD] 🎯 Applying user preference for "${cardName}": ${userPreference.set.toUpperCase()} #${userPreference.collector_number} (${userPreference.id})`);
              updatedCard.printing = userPreference.id;
              
              // Also update nested card object if it exists
              if (updatedCard.card) {
                updatedCard.card.printing = userPreference.id;
              }
            } else {
              // console.log(`[DECK LOAD] 📋 No user preference for "${cardName}", using server printing: ${card.printing || 'default'}`);
            }
            
            return updatedCard;
          });
        }

        // DEBUG: Check if any cards have modalPrice when loaded from database
        // DEBUG: Check if any cards have modalPrice when loaded from database
        const cardsWithModalPrice = data?.cards?.filter(card => (card.modalPrice !== null && card.modalPrice !== undefined) || (card.card?.modalPrice !== null && card.card?.modalPrice !== undefined)) || [];
        if (cardsWithModalPrice.length > 0) {
          // console.log(`[DECK LOAD] Found ${cardsWithModalPrice.length} cards with modalPrice from database:`, 
          //   cardsWithModalPrice.map(card => {
          //     const name = card.card?.name || card.name;
          //     const modalPrice = card.modalPrice || card.card?.modalPrice;
          //     return `${name}: $${modalPrice}`;
          //   }).join(', ')
          // );
        } else {
          // console.log(`[DECK LOAD] No cards have modalPrice in database response`);
        }

        const cardsFromAPI = ensureCommanderInCards(data);

        // console.log('[DEBUG] Verifying card data. Number of cards to check:', cardsFromAPI.length);

        const fetchPromises = cardsFromAPI.map((cardObj, index) => {
          if (!cardObj) {
            console.warn(`[Card Verifier] Card at index ${index} is null.`);
            return Promise.resolve(null);
          }

          const cardName =
            cardObj.card?.name ||
            cardObj.name ||
            `(unknown card at index ${index})`;

          // The presence of our own 'scryfall_json' property is the source of truth
          // for whether we have already fetched and processed this card's full data.
          const isDataComplete = !!cardObj.scryfall_json;

          if (isDataComplete) {
            // console.log(`[Card Verifier] Data for "${cardName}" is already complete. No fetch needed.`);
            return Promise.resolve(cardObj);
          }

          // If data is not complete, we must fetch it from Scryfall.
          let printingId = cardObj.printing;
          const set = cardObj.card?.set;
          const collectorNumber = cardObj.card?.collector_number;

          // CRITICAL FIX: For basic lands, always use preferred printing ID for price consistency
          const isBasicLand = BASIC_LAND_PRINTINGS[cardName];
          if (isBasicLand) {
            printingId = BASIC_LAND_PRINTINGS[cardName];
            // console.log(`[Card Fetch] Forcing basic land "${cardName}" to use preferred printing ${printingId}`);
          }

          let fetchUrl = null;
          let fetchSource = "";

          // Determine the best way to fetch from Scryfall, from most specific to least.
          if (printingId) {
            fetchUrl = `https://api.scryfall.com/cards/${printingId}`;
            fetchSource = `printing ID ${printingId}`;
          } else if (set && collectorNumber) {
            fetchUrl = `https://api.scryfall.com/cards/${set.toLowerCase()}/${collectorNumber}`;
            fetchSource = `set/collector number ${set}/${collectorNumber}`;
          } else if (cardName) {
            // Fetching by name is ambiguous, but it's our last resort.
            fetchUrl = `https://api.scryfall.com/cards/named?exact=${encodeURIComponent(cardName)}`;
            fetchSource = `card name "${cardName}"`;
          }

          if (fetchUrl) {
            // console.log(`[Card Fetch] Data for "${cardName}" is incomplete. Fetching using ${fetchSource}.`);
            const apiUrl = import.meta.env.VITE_API_URL;
            return fetch(
              fetchUrl.startsWith("http") ? fetchUrl : `${apiUrl}${fetchUrl}`,
            )
              .then((res) => {
                if (!res.ok) {
                  console.warn(`[SCRYFALL 404] Failed to fetch card data for "${cardName}" using ${fetchSource}. Status: ${res.status}. URL: ${fetchUrl}`);
                  // For 404 errors, return the original card object instead of throwing
                  if (res.status === 404) {
                    console.warn(`[SCRYFALL 404] Returning original card data for "${cardName}" due to 404 error`);
                    return Promise.resolve(cardObj);
                  }
                  throw new Error(
                    `Scryfall fetch failed for ${fetchSource} with status ${res.status}`,
                  );
                }
                return res.json();
              })
              .then((scryfallData) => {
                // Handle case where we returned original cardObj due to 404
                if (scryfallData === cardObj) {
                  return scryfallData;
                }
                // console.log(`[Card Fetch] Success for "${cardName}". Injecting Scryfall data.`);
                // Return a new object with the original data plus the full scryfall_json
                const newCardObj = {
                  ...cardObj,
                  scryfall_json: scryfallData,
                  // Also update the printing ID to what we actually fetched, for consistency
                  printing: scryfallData.id,
                };

                // Also patch the nested 'card' object for consistency if it exists
                if (newCardObj.card) {
                  newCardObj.card.scryfall_json = scryfallData;
                  newCardObj.card.prices = scryfallData.prices;
                }

                return newCardObj;
              })
              .catch((error) => {
                console.error(
                  `[Card Fetch] Failed for "${cardName}" using ${fetchSource}:`,
                  error.message,
                );
                // Return original object on failure, but add a flag to show it failed
                return { ...cardObj, scryfall_fetch_failed: true };
              });
          } else {
            console.warn(
              `[Card Verifier] Cannot fetch "${cardName}" - no identifier available.`,
            );
            // Return original object if we can't even build a URL
            return Promise.resolve(cardObj);
          }
        });

        Promise.all(fetchPromises).then((finalCards) => {
          // Filter out any null cards that might have slipped through
          const validFinalCards = finalCards.filter((c) => c);

          if (!isMounted.current) return;

          // Process all cards to ensure they have correct prices based on their foil status
          const processedCards = validFinalCards.map((card) => {
            const cardName = card.card?.name || card.name || 'Unknown';
            
            // CRITICAL FIX: Clean up modalPrice values - convert undefined to null
            const cleanModalPrice = (card.modalPrice !== undefined && card.modalPrice !== null && card.modalPrice !== "undefined") ? card.modalPrice : null;
            const cleanNestedModalPrice = (card.card?.modalPrice !== undefined && card.card?.modalPrice !== null && card.card?.modalPrice !== "undefined") ? card.card?.modalPrice : null;
            
            // DEBUG: Check if card has modalPrice when being processed on deck load
            const hasModalPrice = cleanModalPrice !== null || cleanNestedModalPrice !== null;
            if (hasModalPrice) {
              // console.log(`[DECK LOAD PROCESSING] Card "${cardName}" has modalPrice: $${cleanModalPrice || cleanNestedModalPrice}`);
            } else {
              // console.log(`[DECK LOAD PROCESSING] Card "${cardName}" has NO modalPrice, will calculate from scryfall data`);
            }
            // Check and normalize foil status at all levels
            const isFoilStatus = card.foil === true || card.card?.foil === true;

            // Make sure foil status is consistent across all levels
            const cardWithConsistentFoil = {
              ...card,
              foil: isFoilStatus,
              // CRITICAL: Clean modalPrice during load
              modalPrice: cleanModalPrice,
              ...(card.card
                ? {
                    card: {
                      ...card.card,
                      foil: isFoilStatus,
                      // CRITICAL: Also clean modalPrice in nested card object
                      modalPrice: cleanNestedModalPrice,
                    },
                  }
                : {}),
              ...(card.cardObj
                ? {
                    cardObj: {
                      ...card.cardObj,
                      foil: isFoilStatus,
                      ...(card.cardObj.card
                        ? {
                            card: {
                              ...card.cardObj.card,
                              foil: isFoilStatus,
                            },
                          }
                        : {}),
                    },
                  }
                : {}),
            };

            // Extract the correct price based on the foil status
            const priceData = extractPrice(cardWithConsistentFoil);

            // Create a new card object with the correct price and foil status
            return {
              ...cardWithConsistentFoil,
              price: priceData.price, // Set the price at the top level
              lastUpdated: Date.now(), // Add timestamp to force React to detect the change
              // Also update price in the nested card object
              ...(cardWithConsistentFoil.card
                ? {
                    card: {
                      ...cardWithConsistentFoil.card,
                      price: priceData.price,
                      lastUpdated: Date.now(),
                    },
                  }
                : {}),
            };
          });

          // console.log('[DEBUG] All card data verified and prices calculated. Final card count:', processedCards.length);

          // Ensure commander is always present in the deck when loading
          const deckWithCommander = { ...data, cards: processedCards };
          const finalCardsWithCommander = ensureCommanderInCards(deckWithCommander);
          const finalDeckData = { ...deckWithCommander, cards: finalCardsWithCommander };

          setDeck(finalDeckData);
          setName(data.name);
          setCards(finalCardsWithCommander);
          
          // Normalize and load tech ideas and sideboard if they exist
          const normalizedTechIdeas = (data.techIdeas || []).map(card => {
            console.log('[DEBUG] Normalizing Tech Ideas card:', { name: card.name, foil: card.foil, printing: card.printing });
            // If card already has proper structure, use it
            if (card.card && card.card.type_line) {
              return card;
            }
            // Otherwise, normalize the structure
            const sourceData = card.cardObj || card.scryfall_json || card;
            const normalized = {
              ...card,
              card: {
                name: sourceData.name || card.name,
                type_line: sourceData.type_line || 'Unknown',
                scryfall_json: sourceData,
                printing: card.printing || sourceData.id || sourceData.scryfall_id
              },
              scryfall_json: sourceData
            };
            console.log('[DEBUG] Normalized Tech Ideas card:', { name: normalized.name, foil: normalized.foil, printing: normalized.printing });
            return normalized;
          });

          const normalizedSideboard = (data.sideboard || []).map(card => {
            console.log('[DEBUG] Normalizing Sideboard card:', { name: card.name, foil: card.foil, printing: card.printing });
            // If card already has proper structure, use it
            if (card.card && card.card.type_line) {
              return card;
            }
            // Otherwise, normalize the structure
            const sourceData = card.cardObj || card.scryfall_json || card;
            const normalized = {
              ...card,
              card: {
                name: sourceData.name || card.name,
                type_line: sourceData.type_line || 'Unknown',
                scryfall_json: sourceData,
                printing: card.printing || sourceData.id || sourceData.scryfall_id
              },
              scryfall_json: sourceData
            };
            console.log('[DEBUG] Normalized Sideboard card:', { name: normalized.name, foil: normalized.foil, printing: normalized.printing });
            return normalized;
          });

          setTechIdeas(normalizedTechIdeas);
          setSideboard(normalizedSideboard);
          
          setLoading(false);

          preloadCardImages(finalCardsWithCommander, preloadedImages.current);

          // AUTO-SHOW COMMANDER: Set commander as fixed preview with high-res English image
          setTimeout(() => {
            let commanderName = "";
            let commanderCard = null;

            if (data.commander) {
              if (Array.isArray(data.commander) && data.commander.length > 0) {
                const commanderToFind = data.commander[0];
                const commanderToFindName =
                  commanderToFind.name || commanderToFind;
                commanderCard = finalCardsWithCommander.find(
                  (c) => (c.card?.name || c.name) === commanderToFindName,
                );
                commanderName =
                  commanderCard?.card?.name || commanderCard?.name;
              } else if (
                typeof data.commander === "object" &&
                data.commander !== null
              ) {
                commanderCard = finalCardsWithCommander.find(
                  (c) => (c.card?.name || c.name) === data.commander.name,
                );
                commanderName = commanderCard?.card?.name;
              } else if (typeof data.commander === "string") {
                commanderCard = finalCardsWithCommander.find(
                  (c) => (c.card?.name || c.name) === data.commander,
                );
                commanderName = commanderCard?.card?.name || commanderCard?.name;
              }
            }

            // Fallback: look for any card in the Commander category
            if (!commanderCard) {
              const groupedCards = groupCardsByType(finalCardsWithCommander, []);
              const commanderGroup = groupedCards.find(group => group.type === 'Commander');
              if (commanderGroup && commanderGroup.cards.length > 0) {
                commanderCard = commanderGroup.cards[0];
                commanderName = commanderCard?.card?.name || commanderCard?.name;
              }
            }
            
            if (commanderCard) {
              handleCardHover(commanderCard);
            } else {
              // Fallback to first card if no commander found
              if (finalCardsWithCommander.length > 0) {
                handleCardHover(finalCardsWithCommander[0]);
              }
            }
          }, 100); // Small delay to ensure state is set
        });
      })
      .catch((error) => {
        clearTimeout(timeoutId);
        if (error.name === "AbortError") {
          // console.log('[DEBUG] Request aborted for deck ID:', id);
          return;
        }
        console.error("Error loading deck:", error);

        if (error.message === "DECK_NOT_FOUND") {
          toast.error("Deck not found. Redirecting to home page...");
          setTimeout(() => {
            navigate("/");
          }, 2000);
        } else {
          toast.error("Failed to load deck: " + error.message);
        }

        if (isMounted.current) {
          setLoading(false);
        }
      })
      .finally(() => {
        clearTimeout(timeoutId);
        fetchInProgress.current = false;
      });

    return () => {
      isMounted.current = false;
      abortController.abort();
      fetchInProgress.current = false;
      // Don't reset lastFetchedId here - let it persist to prevent duplicate fetches
    };
  }, [id]);

  // INSTANT LOADING: Seed cache with existing data first, then prefetch remaining cards
  useEffect(() => {
    if (!deck || !deck.cards || !Array.isArray(deck.cards)) {
      return;
    }

    // console.log(`[DeckViewEdit] 🌱 Starting instant loading optimization for ${deck.cards.length} cards`);

    // STEP 1: Immediately seed cache with existing printing data for instant loading
    const seededCount = PrintingCache.seedFromDeckCards(deck.cards);
    
    // STEP 2: Extract unique card names for background prefetching
    const cardNames = new Set();
    deck.cards.forEach(cardObj => {
      let cardName = null;
      
      // Try all possible paths for card name
      if (cardObj.cardObj?.card?.name) {
        cardName = cardObj.cardObj.card.name;
      } else if (cardObj.cardObj?.name) {
        cardName = cardObj.cardObj.name;
      } else if (cardObj.name) {
        cardName = cardObj.name;
      } else if (cardObj.card?.name) {
        cardName = cardObj.card.name;
      } else if (cardObj.scryfall_json?.name) {
        cardName = cardObj.scryfall_json.name;
      }
      
      if (cardName) {
        cardNames.add(cardName);
      }
    });

    const cardNamesArray = Array.from(cardNames);
    
    if (cardNamesArray.length === 0) {
      return;
    }

    // STEP 3: Background prefetch for complete printing data (non-blocking)
    // console.log(`[DeckViewEdit] 🚀 Background prefetch starting for ${cardNamesArray.length} unique cards (${seededCount} already instant-ready)`);
    
    // Start aggressive prefetching in the background
    PrintingCache.prefetchCards(cardNamesArray, (completed, total) => {
      if (completed % 5 === 0 || completed === total) { // Log every 5th completion or final
        // console.log(`[DeckViewEdit] 📦 Fast prefetch: ${completed}/${total} cards cached`);
      }
    }).then(() => {
      // console.log(`[DeckViewEdit] ✅ Lightning-fast prefetch completed! All ${cardNamesArray.length} cards ready for instant modal loading`);
    }).catch(error => {
      console.warn(`[DeckViewEdit] ⚠️ Some prefetch errors occurred (non-critical):`, error);
      // Don't show user errors for background prefetching
    });

  }, [deck?.cards]); // Run when deck cards change

  const handleSave = async (e) => {
    e.preventDefault();
    setLoading(true);
    // Ensure every card has a printing field (null if missing)
    const cardsWithPrinting = cards.map((card) => {
      if (typeof card === "object" && card !== null) {
        return { ...card, printing: card.printing || null };
      }
      return { name: card, printing: null };
    });
    const apiUrl = import.meta.env.VITE_API_URL;

    // Get the authentication token - essential for server authentication
    const token = localStorage.getItem("token");
    if (!token) {
      console.error(
        "[DeckViewEdit] No authentication token found for save operation",
      );
      toast.error("Cannot save changes: Not logged in");
      setLoading(false);
      return;
    }

    const res = await fetch(`${apiUrl}/api/decks/${id}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`, // Add auth token - critical for the server auth middleware
        "Cache-Control": "no-cache", // Prevent caching issues
      },
      credentials: "include", // Include cookies for sessions
      body: JSON.stringify({ 
        name, 
        cards: cardsWithPrinting,
        techIdeas: techIdeas,
        sideboard: sideboard,
      }),
    });
    const data = await res.json();
    if (res.ok) {
      toast.success("Deck updated!");
      // Ensure commander is preserved when saving deck
      const deckWithCommander = {
        ...data,
        cards: ensureCommanderInCards(data)
      };
      setDeck(deckWithCommander);
      setEdit(false);
    } else {
      toast.error(data.error || "Error updating deck");
    }
    setLoading(false);
  };

  // Fetch otag suggestions for the current deck
  async function handleGetOtagSuggestions() {
    if (!deck || !deck.cards || deck.cards.length === 0) return;
    setOtagLoading(true);
    try {
      // Use fetchOtagRecommendations utility (expects array of card objects)
      const otagResults = await fetchOtagRecommendations(deck.cards);
      // Aggregate otags and their counts
      const tagCounts = {};
      for (const card of otagResults) {
        if (Array.isArray(card.otags)) {
          for (const tag of card.otags) {
            tagCounts[tag] = (tagCounts[tag] || 0) + 1;
          }
        }
      }
      // Convert to array and sort by count descending
      const sorted = Object.entries(tagCounts)
        .map(([tag, count]) => ({ tag, count }))
        .sort((a, b) => b.count - a.count);
      setOtagSuggestions(sorted);
    } catch (err) {
      toast.error("Failed to fetch Otag suggestions");
      setOtagSuggestions([]);
    }
    setOtagLoading(false);
  }

  // Fetch commander color identity from Scryfall API
  const fetchCommanderColorIdentity = async (commanderName) => {
    try {
      const cleanName = commanderName.toLowerCase().trim();
      const encodedName = encodeURIComponent(cleanName);

      // console.log('[DEBUG] Fetching color identity for:', cleanName);

      // Scryfall API call, leave as is
      const response = await fetch(
        `https://api.scryfall.com/cards/named?exact=${encodedName}`,
      );

      if (response.ok) {
        const cardData = await response.json();
        const colorIdentity = cardData.color_identity || [];
        // console.log('[DEBUG] Fetched color identity:', colorIdentity, 'for:', cleanName);
        return colorIdentity;
      } else if (response.status === 404) {
        // Card not found, return null to indicate this
        // console.log('[DEBUG] Commander not found on Scryfall:', cleanName);
        return null;
      } else {
        console.error(
          "Scryfall API error:",
          response.status,
          response.statusText,
        );
        return null;
      }
    } catch (error) {
      console.error("Error fetching commander color identity:", error);
      return null;
    }
  };

  // Helper to get color identity for search filtering (synchronous, uses cached data only)
  function getCommanderColorIdentity() {
    if (!deck) {
      return "";
    }

    let commanderNames = [];

    // Get commander names from multiple sources
    if (
      deck.commander &&
      Array.isArray(deck.commander) &&
      deck.commander.length > 0
    ) {
      commanderNames = deck.commander
        .map((c) => {
          const name = c.card?.name || c.name || c;
          return typeof name === "string" ? name : null;
        })
        .filter(Boolean);
    } else if (
      deck.commander &&
      typeof deck.commander === "object" &&
      deck.commander !== null
    ) {
      const name =
        deck.commander.card?.name || deck.commander.name || deck.commander;
      if (name && typeof name === "string") {
        commanderNames = [name];
      }
    } else if (typeof deck.commander === "string" && deck.commander.trim()) {
      commanderNames = [deck.commander];
    }

    // Also check commanderNames field for unresolved commanders
    if (
      deck.commanderNames &&
      Array.isArray(deck.commanderNames) &&
      deck.commanderNames.length > 0
    ) {
      const nameCommanders = deck.commanderNames.filter(
        (name) => typeof name === "string" && name.trim(),
      );
      commanderNames = commanderNames.concat(nameCommanders);
    }

    if (commanderNames.length === 0) {
      return "";
    }

    // Try to find color identity from various sources
    let colorIdentity = null;

    // 1. Try populated commander data first
    if (deck.commander) {
      const commander = Array.isArray(deck.commander)
        ? deck.commander[0]
        : deck.commander;
      if (
        commander?.card?.color_identity &&
        Array.isArray(commander.card.color_identity)
      ) {
        colorIdentity = commander.card.color_identity;
      } else if (
        commander?.color_identity &&
        Array.isArray(commander.color_identity)
      ) {
        colorIdentity = commander.color_identity;
      }
    }

    // 2. If not found, search in cards array
    if (!colorIdentity && deck.cards && Array.isArray(deck.cards)) {
      for (const commanderName of commanderNames) {
        if (typeof commanderName !== "string") continue;

        const commanderCard = deck.cards.find((card) => {
          const cardName = card.card?.name || card.name || "";
          return cardName.toLowerCase() === commanderName.toLowerCase();
        });
        if (
          commanderCard?.card?.color_identity &&
          Array.isArray(commanderCard.card.color_identity)
        ) {
          colorIdentity = commanderCard.card.color_identity;
          break;
        }
      }
    }

    // 3. Check cache for Scryfall data (no async fetching in sync version)
    if (!colorIdentity && commanderNames.length > 0) {
      const primaryCommander = commanderNames[0];
      const cacheKey = primaryCommander.toLowerCase().trim();

      if (commanderColorCache.has(cacheKey)) {
        const cachedResult = commanderColorCache.get(cacheKey);
        if (cachedResult !== null) {
          colorIdentity = cachedResult;
        }
      }
    }

    const result = colorIdentity ? colorIdentity.join("").toLowerCase() : "";
    return result;
  }

  // Effect to automatically fetch and cache commander color identity when deck loads
  useEffect(() => {
    if (!deck) return;

    // Get commander names from multiple sources
    let commanderNames = [];

    if (
      deck.commander &&
      Array.isArray(deck.commander) &&
      deck.commander.length > 0
    ) {
      commanderNames = deck.commander
        .map((c) => {
          const name = c.card?.name || c.name || c;
          return typeof name === "string" ? name : null;
        })
        .filter(Boolean);
    } else if (
      deck.commander &&
      typeof deck.commander === "object" &&
      deck.commander !== null
    ) {
      const name =
        deck.commander.card?.name || deck.commander.name || deck.commander;
      if (name && typeof name === "string") {
        commanderNames = [name];
      }
    } else if (typeof deck.commander === "string" && deck.commander.trim()) {
      commanderNames = [deck.commander];
    }

    // Also check commander_names and commanderNames fields for unresolved commanders
    if (
      deck.commander_names &&
      Array.isArray(deck.commander_names) &&
      deck.commander_names.length > 0
    ) {
      const nameCommanders = deck.commander_names.filter(
        (name) => typeof name === "string" && name.trim(),
      );
      commanderNames = commanderNames.concat(nameCommanders);
    }

    if (
      deck.commanderNames &&
      Array.isArray(deck.commanderNames) &&
      deck.commanderNames.length > 0
    ) {
      const nameCommanders = deck.commanderNames.filter(
        (name) => typeof name === "string" && name.trim(),
      );
      commanderNames = commanderNames.concat(nameCommanders);
    }

    if (commanderNames.length === 0) return;

    // Check if we need to fetch any commander color identities
    for (const commanderName of commanderNames) {
      if (typeof commanderName !== "string") continue;

      const cacheKey = commanderName.toLowerCase().trim();

      // Skip if already in cache or currently being fetched
      if (
        commanderColorCache.has(cacheKey) ||
        pendingColorFetches.has(cacheKey)
      ) {
        continue;
      }

      // Check if we already have the color identity in the deck data
      let hasColorIdentity = false;

      if (deck.commander) {
        const commander = Array.isArray(deck.commander)
          ? deck.commander[0]
          : deck.commander;
        if (
          commander?.card?.color_identity &&
          Array.isArray(commander.card.color_identity)
        ) {
          hasColorIdentity = true;
        } else if (
          commander?.color_identity &&
          Array.isArray(commander.color_identity)
        ) {
          hasColorIdentity = true;
        }
      }

      if (!hasColorIdentity && deck.cards && Array.isArray(deck.cards)) {
        const commanderCard = deck.cards.find((card) => {
          const cardName = card.card?.name || card.name || "";
          return cardName.toLowerCase() === commanderName.toLowerCase();
        });
        if (
          commanderCard?.card?.color_identity &&
          Array.isArray(commanderCard.card.color_identity)
        ) {
          hasColorIdentity = true;
        }
      }

      // Fetch from Scryfall if we don't have color identity
      if (!hasColorIdentity) {
        // console.log('[DEBUG] Auto-fetching color identity for commander:', commanderName);
        setPendingColorFetches((prev) => new Set(prev).add(cacheKey));

        fetchCommanderColorIdentity(commanderName).then(
          (fetchedColorIdentity) => {
            // console.log('[DEBUG] Auto-fetch result for', commanderName, ':', fetchedColorIdentity);
            setCommanderColorCache((prev) =>
              new Map(prev).set(cacheKey, fetchedColorIdentity),
            );
            setPendingColorFetches((prev) => {
              const newSet = new Set(prev);
              newSet.delete(cacheKey);
              return newSet;
            });
          },
        );
      }
    }
  }, [deck, commanderColorCache, pendingColorFetches]);

  // Get the current commander color identity for display
  const currentColorId = getCommanderColorIdentity();

  // AbortController to cancel previous search requests
  const searchAbortControllerRef = useRef(null);

  // Scryfall search bar logic (constrain to color identity)
  const debouncedSearch = debounce(async (q) => {
    if (!q.trim()) {
      setSearchResults([]);
      setShowDropdown(false);
      setNoResultsMsg("");
      setSearchLoading(false); // Important: reset loading state for empty queries
      // Don't clear the preview when search is cleared - keep the last viewed card
      return;
    }
    
    // Cancel previous request if it exists
    if (searchAbortControllerRef.current) {
      searchAbortControllerRef.current.abort();
    }
    
    // Create new abort controller for this request
    searchAbortControllerRef.current = new AbortController();
    const signal = searchAbortControllerRef.current.signal;
    
    setSearchLoading(true);
    let query = q.trim();

    // Get current commander color identity
    const currentColorId = getCommanderColorIdentity();

    try {
      // ORACLE TAG SUPPORT: For oracle tag searches, use Scryfall directly (like the modal does)
      if (query.includes('otag:') || query.includes('oracletag:')) {
        console.log('🏷️ Oracle tag search detected in dropdown, using Scryfall API');
        
        // Convert otag: to oracletag: for Scryfall
        let scryfallQuery = query.replace('otag:', 'oracletag:');
        
        // Don't add color identity constraint to the Scryfall query - get all results first
        // then filter client-side like the modal does
        console.log('🔍 Scryfall query for dropdown:', scryfallQuery);
        
        const scryfallUrl = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(scryfallQuery)}&unique=cards&order=name`;
        console.log('🌐 Scryfall URL for dropdown:', scryfallUrl);
        
        const res = await fetch(scryfallUrl, { signal });
        console.log('📡 Scryfall response status:', res.status);
        
        if (!res.ok) {
          throw new Error(`Scryfall API error! status: ${res.status}`);
        }
        
        const data = await res.json();
        console.log('📦 Scryfall response data:', data);
        
        // Handle Scryfall response format
        if (data.object === 'list' && Array.isArray(data.data)) {
          let results = data.data;
          
          // Filter by color identity if commander exists (client-side filtering)
          if (currentColorId) {
            const commanderColors = currentColorId.split('').sort();
            results = results.filter(card => {
              const cardColors = (card.color_identity || []).map(c => c.toLowerCase()).sort();
              // Check if card's color identity is a subset of commander's
              return cardColors.every(color => commanderColors.includes(color));
            });
            console.log('🎨 Filtered', data.data.length, 'to', results.length, 'cards matching color identity:', currentColorId);
            
            // Note: This is only the first page - mention if there are more
            if (data.has_more) {
              console.log('📄 Note: This is only the first page. Total cards available:', data.total_cards);
            }
          }
          
          // Limit to 5 for dropdown
          const dropdownResults = results.slice(0, 5);
          console.log('🔍 Scryfall dropdown results:', dropdownResults.length, 'of', results.length, 'total (after filtering, first page only)');
          
          setSearchResults(dropdownResults);
          setNoResultsMsg(
            dropdownResults.length === 0
              ? "No cards found matching your oracle tag search in your commander's colors."
              : "",
          );
          setShowDropdown(dropdownResults.length > 0);
          console.log('✅ Oracle tag dropdown search completed - showDropdown:', dropdownResults.length > 0);
        } else if (data.object === 'error') {
          console.log('⚠️ Scryfall error:', data.details);
          setSearchResults([]);
          setNoResultsMsg(data.details || "Oracle tag search failed.");
          setShowDropdown(true);
        } else {
          console.log('❌ Unknown Scryfall response format');
          setSearchResults([]);
          setNoResultsMsg("Unexpected response from search.");
          setShowDropdown(true);
        }
        
        // CRITICAL: Set loading to false for oracle tag searches
        setSearchLoading(false);
        return; // Exit early for oracle tag searches
      }

      // REGULAR SEARCH: Use backend API for non-oracle tag searches
      // Let backend handle color identity filtering via colorIdentity parameter
      // Don't modify the query string - this allows for more flexible search
      // Users can still manually add id:colors if they want

      const url = `/api/cards/search?q=${encodeURIComponent(query)}&limit=5${currentColorId ? `&colorIdentity=${currentColorId}` : ""}${deck && deck.format ? `&deckFormat=${encodeURIComponent(deck.format)}` : ""}`;

      const apiUrl = import.meta.env.VITE_API_URL;
      const isDev = import.meta.env.DEV;
      
      // Debug logging
      console.log('🔍 Regular Search Debug:', {
        originalQuery: q,
        trimmedQuery: query,
        currentColorId: currentColorId,
        deck: deck?.name,
        commander: deck?.commander,
        url: url,
        apiUrl: apiUrl,
        isDev: isDev,
        env: import.meta.env.MODE
      });
      
      // In development, use relative path for Vite proxy
      // In production, use full API URL
      const finalUrl = isDev ? url : `${apiUrl}${url}`;
      console.log('🔗 Final URL for request:', finalUrl);
      console.log('🌐 Fetch target:', finalUrl, '(isDev:', isDev, ')');
      
      const res = await fetch(finalUrl, { signal });
      console.log('📡 Response status:', res.status);
      
      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }
      
      const data = await res.json();
      console.log('📦 Response data:', data);
      
      // Handle Scryfall API response format
      const results = data.data || data || [];
      console.log('🔍 Processed results:', results, 'Length:', results.length);
      if (Array.isArray(results)) {
        setSearchResults(results);
        setNoResultsMsg(
          results.length === 0
            ? "No cards found matching your search criteria."
            : "",
        );
        setShowDropdown(results.length > 0);
        console.log('✅ Search completed - showDropdown:', results.length > 0);
      } else if (data && data.message) {
        setSearchResults([]);
        setNoResultsMsg(data.message);
        setShowDropdown(true);
        console.log('⚠️ API message:', data.message);
      } else {
        setSearchResults([]);
        setNoResultsMsg("No results found.");
        setShowDropdown(true);
        console.log('❌ Unknown response format');
      }
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('🔄 Search request was cancelled');
        return; // Don't update state for cancelled requests
      }
      console.error('🚨 Search error:', error);
      setSearchResults([]);
      setNoResultsMsg("Error fetching cards.");
      setShowDropdown(true);
    }
    setSearchLoading(false);
  }, 300);

  // Function to fetch all search results for modal display
  const fetchAllSearchResults = async (query) => {
    if (!query.trim()) return;
    
    console.log('🚀 fetchAllSearchResults called with query:', query);
    setSearchModalLoading(true);
    
    // Don't close dropdown immediately - wait for successful fetch
    console.log('🔄 Keeping dropdown open while fetching...');
    
    const currentColorId = getCommanderColorIdentity();
    
    try {
      // For oracle tag searches, use Scryfall directly
      if (query.includes('otag:') || query.includes('oracletag:')) {
        console.log('🏷️ Oracle tag search detected, using Scryfall API');
        
        // Convert otag: to oracletag: for Scryfall
        let scryfallQuery = query.replace('otag:', 'oracletag:');
        
        console.log('🔍 Final Scryfall query:', scryfallQuery);
        
        // Fetch ALL pages from Scryfall, not just the first page
        let allResults = [];
        let nextPageUrl = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(scryfallQuery)}&unique=cards&order=name`;
        
        console.log('🌐 Starting Scryfall pagination from:', nextPageUrl);
        
        // Fetch all pages
        while (nextPageUrl) {
          console.log('📄 Fetching page:', nextPageUrl);
          const response = await fetch(nextPageUrl);
          
          if (!response.ok) {
            if (response.status === 404) {
              console.log('❌ Oracle tag not found on Scryfall');
              break;
            }
            throw new Error(`Scryfall error: ${response.status}`);
          }
          
          const data = await response.json();
          const pageResults = data.data || [];
          allResults = allResults.concat(pageResults);
          
          console.log(`📦 Page results: ${pageResults.length} cards (total so far: ${allResults.length})`);
          
          // Check if there are more pages
          nextPageUrl = data.has_more ? data.next_page : null;
          
          // Safety check to prevent infinite loops
          if (allResults.length > 500) {
            console.warn('⚠️ Stopping pagination at 500 cards to prevent excessive requests');
            break;
          }
        }
        
        console.log(`✅ Scryfall returned ${allResults.length} total results (all pages)`);
        
        // Filter by color identity if commander exists (client-side filtering)
        if (currentColorId) {
          const commanderColors = currentColorId.split('').sort();
          const beforeCount = allResults.length;
          allResults = allResults.filter(card => {
            const cardColors = (card.color_identity || []).map(c => c.toLowerCase()).sort();
            // Check if card's color identity is a subset of commander's
            return cardColors.every(color => commanderColors.includes(color));
          });
          console.log('🎨 Filtered', beforeCount, 'to', allResults.length, 'cards matching color identity:', currentColorId);
        }
        
        setAllSearchResults(allResults);
        setShowSearchModal(true);
        setShowDropdown(false);
        return;
      }
      
      // For regular searches, remove the limit constraint to get all results
      const url = `/api/cards/search?q=${encodeURIComponent(query.trim())}${currentColorId ? `&colorIdentity=${currentColorId}` : ""}${deck && deck.format ? `&deckFormat=${encodeURIComponent(deck.format)}` : ""}`;
      
      const apiUrl = import.meta.env.VITE_API_URL;
      const isDev = import.meta.env.DEV;
      const finalUrl = isDev ? url : `${apiUrl}${url}`;
      
      console.log('🔍 Full URL being requested (NO LIMIT):', finalUrl);
      console.log('🔍 Query params breakdown:', {
        q: query.trim(),
        colorIdentity: currentColorId,
        deckFormat: deck?.format,
        note: 'NO LIMIT PARAMETER - should return ALL results'
      });
      
      console.log('🔍 Fetching all search results for modal:', finalUrl);
      
      const res = await fetch(finalUrl);
      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }
      
      const data = await res.json();
      const results = data.data || data || [];
      
      console.log('📦 All search results fetched:', results.length, 'cards');
      console.log('📦 First 3 results:', results.slice(0, 3).map(card => card.name));
      console.log('📦 Total cards from API:', data.total_cards);
      console.log('📦 Has more from API:', data.has_more);
      
      // If we got exactly 5 results and there are more, this suggests the backend is still limiting
      if (results.length === 5 && data.has_more) {
        console.log('⚠️ Backend still limiting results, trying Scryfall fallback...');
        
        // Try Scryfall as fallback for complete results with full pagination
        try {
          let allScryfallResults = [];
          let nextPageUrl = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(query)}&unique=cards&order=name`;
          
          console.log('🌐 Starting Scryfall fallback pagination from:', nextPageUrl);
          
          // Fetch all pages from Scryfall
          while (nextPageUrl) {
            console.log('📄 Fetching Scryfall page:', nextPageUrl);
            const scryfallRes = await fetch(nextPageUrl);
            
            if (!scryfallRes.ok) {
              if (scryfallRes.status === 404) {
                console.log('❌ No results found on Scryfall');
                break;
              }
              throw new Error(`Scryfall error: ${scryfallRes.status}`);
            }
            
            const scryfallData = await scryfallRes.json();
            const pageResults = scryfallData.data || [];
            allScryfallResults = allScryfallResults.concat(pageResults);
            
            console.log(`📦 Scryfall page results: ${pageResults.length} cards (total so far: ${allScryfallResults.length})`);
            
            // Check if there are more pages
            nextPageUrl = scryfallData.has_more ? scryfallData.next_page : null;
            
            // Safety check to prevent infinite loops
            if (allScryfallResults.length > 500) {
              console.warn('⚠️ Stopping Scryfall pagination at 500 cards to prevent excessive requests');
              break;
            }
          }
          
          console.log(`✅ Scryfall fallback returned ${allScryfallResults.length} total results`);
          
          // Apply color filtering if commander exists
          if (currentColorId && allScryfallResults.length > 0) {
            const commanderColors = currentColorId.split('').sort();
            const beforeCount = allScryfallResults.length;
            allScryfallResults = allScryfallResults.filter(card => {
              const cardColors = (card.color_identity || []).map(c => c.toLowerCase()).sort();
              return cardColors.every(color => commanderColors.includes(color));
            });
            console.log('🎨 Scryfall fallback: Filtered', beforeCount, 'to', allScryfallResults.length, 'cards matching color identity:', currentColorId);
          }
          
          if (allScryfallResults.length > results.length) {
            console.log('🎯 Using Scryfall results instead (more complete)');
            setAllSearchResults(allScryfallResults);
            setShowSearchModal(true);
            setShowDropdown(false);
            return;
          }
        } catch (scryfallError) {
          console.log('⚠️ Scryfall fallback failed:', scryfallError);
        }
      }
      
      console.log('🔄 Setting allSearchResults state with', results.length, 'results');
      setAllSearchResults(Array.isArray(results) ? results : []);
      console.log('🔄 Opening search modal and closing dropdown');
      setShowSearchModal(true);
      setShowDropdown(false); // Close the dropdown only after successful fetch
      
    } catch (error) {
      console.error('🚨 Error fetching all search results:', error);
      setAllSearchResults([]);
    } finally {
      setSearchModalLoading(false);
    }
  };

  useEffect(() => {
    debouncedSearch(search);
    return () => {
      debouncedSearch.cancel();
      debouncedResetSelection.cancel();
    };
  }, [search, debouncedResetSelection]);

  // Close search dropdown when clicking outside or pressing Escape
  useEffect(() => {
    if (!showDropdown) return;

    const handleClickOutside = (event) => {
      // Check if the click is outside the search container
      const searchContainer = event.target.closest(".search-container");
      if (!searchContainer) {
        setShowDropdown(false);
        // Don't clear the search input when clicking outside - preserve user's search term
        // setSearch("");
      }
    };

    const handleEscapeKey = (event) => {
      if (event.key === "Escape") {
        setShowDropdown(false);
        // Don't clear the search input when pressing Escape - preserve user's search term
        // setSearch("");
      }
    };

    // Add event listeners
    document.addEventListener("mousedown", handleClickOutside);
    document.addEventListener("keydown", handleEscapeKey);

    // Cleanup event listeners
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
      document.removeEventListener("keydown", handleEscapeKey);
    };
  }, [showDropdown]);

  useEffect(() => {
    // if (deck) {
    //   console.log('DEBUG deck.cards:', deck.cards);
    // }
  }, [deck]);

  const sortCards = useMemo(() => {
    return (cardsToSort, sortOption) => {
      return cardsToSort.sort((a, b) => {
        const nameA = a.card?.name || a.name || "";
        const nameB = b.card?.name || b.name || "";

        // Only extract prices if we're actually sorting by price to improve performance
        if (sortOption.includes('price')) {
          const priceDataA = extractPrice(a);
          const priceDataB = extractPrice(b);

          let priceA = parseFloat(priceDataA.price) || 0;
          let priceB = parseFloat(priceDataB.price) || 0;

          switch (sortOption) {
            case "price-asc":
              return priceA === priceB
                ? nameA.localeCompare(nameB)
                : priceA - priceB;
            case "price-desc":
              return priceB === priceA
                ? nameA.localeCompare(nameB)
                : priceB - priceA;
            default:
              return nameA.localeCompare(nameB);
          }
        }

        switch (sortOption) {
          case "name-asc":
            return nameA.localeCompare(nameB);
          case "name-desc":
            return nameB.localeCompare(nameA);
          default:
            return nameA.localeCompare(nameB);
        }
      });
    };
  }, []); // Empty dependency array since this function doesn't depend on any state

  // Memoize the grouped cards calculation to prevent infinite re-renders
  const groupedCards = useMemo(() => {
    if (!deck) return [];
    try {
      const cardsWithCommander = ensureCommanderInCards(deck);
      const commanderNamesArray = (() => {
        if (!deck || !deck.commander) return [];

        if (Array.isArray(deck.commander)) {
          if (deck.commander.length === 0) return [];
          return deck.commander
            .map((comm) => {
              if (!comm) return "";
              const name = comm.card?.name || comm.name || comm;
              return typeof name === "string" ? name.toLowerCase() : "";
            })
            .filter((name) => name.length > 0);
        } else {
          const comm = deck.commander;
          const name = comm.card?.name || comm.name || comm;
          return typeof name === "string" && name.trim()
            ? [name.toLowerCase()]
            : [];
        }
      })();

      // Group cards based on the selected grouping option
      let result;
      switch (groupBy) {
        case "manaValue":
          result = groupCardsByManaValue(
            cardsWithCommander,
            commanderNamesArray,
          );
          break;
        case "colorIdentity":
          result = groupCardsByColorIdentity(
            cardsWithCommander,
            commanderNamesArray,
          );
          break;
        case "collectionStatus":
          result = groupCardsByCollectionStatus(
            cardsWithCommander,
            commanderNamesArray,
          );
          break;
        case "type":
        default:
          result = groupCardsByType(cardsWithCommander, commanderNamesArray);
      }

      // Sort cards within each group
      result.forEach((group) => {
        group.cards = sortCards(group.cards, sortBy);
      });

      return result;
    } catch (error) {
      console.error("Error grouping cards:", error);
      return [];
    }
  }, [deck, groupBy, sortBy]);

  // Only sort cards within each group, not the groups themselves
  const groupedAndSortedCards = useMemo(() => {
    // console.log('[DeckViewEdit] Recalculating grouped and sorted cards');

    let cardGroups;
    // Use cards array primarily but fall back to deck.cards if needed
    const cardsToGroup = cards && cards.length > 0 ? cards : deck?.cards || [];
    // console.log('[DeckViewEdit] Number of cards being grouped:', cardsToGroup.length);
    const commanderNamesForGrouping = commanderNames;

    if (groupBy === "type") {
      cardGroups = groupCardsByType(cardsToGroup, commanderNamesForGrouping);
    } else if (groupBy === "manaValue") {
      cardGroups = groupCardsByManaValue(
        cardsToGroup,
        commanderNamesForGrouping,
      );
    } else if (groupBy === "colorIdentity") {
      cardGroups = groupCardsByColorIdentity(
        cardsToGroup,
        commanderNamesForGrouping,
      );
    } else if (groupBy === "collectionStatus") {
      cardGroups = groupCardsByCollectionStatus(
        cardsToGroup,
        commanderNamesForGrouping,
      );
    }

    // Sort cards within each group only
    cardGroups.forEach((group) => {
      group.cards = sortCards([...group.cards], sortBy);
    });

    // console.log('[DeckViewEdit] Card groups calculated:',
    //   cardGroups.map(g => `${g.type}: ${g.cards.length} cards`).join(', '));

    return cardGroups;
  }, [cards, groupBy, sortBy, commanderNames, deck, collectionUpdateCounter]);

  // Grouped and sorted tech ideas
  const groupedAndSortedTechIdeas = useMemo(() => {
    let cardGroups;
    const cardsToGroup = techIdeas || [];

    if (groupBy === "type") {
      cardGroups = groupCardsByType(cardsToGroup, commanderNames);
    } else if (groupBy === "manaValue") {
      cardGroups = groupCardsByManaValue(cardsToGroup, commanderNames);
    } else if (groupBy === "colorIdentity") {
      cardGroups = groupCardsByColorIdentity(cardsToGroup, commanderNames);
    } else if (groupBy === "collectionStatus") {
      cardGroups = groupCardsByCollectionStatus(cardsToGroup, commanderNames);
    }

    // Sort cards within each group
    cardGroups.forEach((group) => {
      group.cards = sortCards([...group.cards], sortBy);
    });

    return cardGroups;
  }, [techIdeas, groupBy, sortBy, commanderNames, collectionUpdateCounter]);

  // Grouped and sorted sideboard
  const groupedAndSortedSideboard = useMemo(() => {
    let cardGroups;
    const cardsToGroup = sideboard || [];

    if (groupBy === "type") {
      cardGroups = groupCardsByType(cardsToGroup, commanderNames);
    } else if (groupBy === "manaValue") {
      cardGroups = groupCardsByManaValue(cardsToGroup, commanderNames);
    } else if (groupBy === "colorIdentity") {
      cardGroups = groupCardsByColorIdentity(cardsToGroup, commanderNames);
    } else if (groupBy === "collectionStatus") {
      cardGroups = groupCardsByCollectionStatus(cardsToGroup, commanderNames);
    }

    // Sort cards within each group
    cardGroups.forEach((group) => {
      group.cards = sortCards([...group.cards], sortBy);
    });

    return cardGroups;
  }, [sideboard, groupBy, sortBy, commanderNames, collectionUpdateCounter]);

  // --- Preview Update Handler ---
  const handlePreviewUpdate = useCallback((previewUpdateData) => {
    if (!previewUpdateData) return;
    
    // console.log('[DeckViewEdit] handlePreviewUpdate called with:', previewUpdateData);
    
    // Update the fixed preview to show the newly selected printing
    // The data comes from CardActionsModal with structure: { ...card, printing: printing.id, scryfall_json: printing }
    setFixedPreview({
      card: previewUpdateData, // Use the complete data structure from modal
      top: 0, // For fixed preview these aren't used, but required by the component
      left: 0,
    });
    
    // console.log('[DeckViewEdit] Updated fixed preview to printing:', previewUpdateData.printing, previewUpdateData.name);
  }, []);

  // --- Modal Card Action Handlers (implemented for printing, quantity, and foil) ---
  function handleUpdateCard(cardObj, updates = {}) {
    // console.log('[DeckViewEdit] handleUpdateCard called with:', cardObj, updates);

    // Validate we have a card object to work with
    if (!cardObj) {
      console.error("[DeckViewEdit] Cannot update card: missing card object");
      toast.error("Failed to update card: Missing card data");
      return;
    }

    try {
      // Handle fresh price data updates from modal (non-intrusive background update)
      if (updates.freshPriceDataOnly && updates.scryfall_json) {
        const cardName = cardObj.card?.name || cardObj.name;
        if (!cardName) {
          console.error("[DeckViewEdit] Cannot update fresh price data: missing card name");
          return;
        }

        // Update the card's stored Scryfall data with fresh pricing information
        const timestamp = Date.now();
        const updatedCards = cards.map((c) => {
          const cName = c.card?.name || c.name;
          if (cName === cardName) {
            // Deep update the Scryfall JSON data to include fresh prices
            const updated = {
              ...c,
              // Update top-level scryfall data if it exists
              ...(c.scryfall_json ? { scryfall_json: { ...c.scryfall_json, ...updates.scryfall_json } } : {}),
              // Update nested card structure
              ...(c.card ? {
                card: {
                  ...c.card,
                  // Update scryfall_json in nested card structure
                  ...(c.card.scryfall_json ? { 
                    scryfall_json: { ...c.card.scryfall_json, ...updates.scryfall_json } 
                  } : { 
                    scryfall_json: updates.scryfall_json 
                  })
                }
              } : {}),
              // Update cardObj structure if it exists
              ...(c.cardObj ? {
                cardObj: {
                  ...c.cardObj,
                  ...(c.cardObj.card ? {
                    card: {
                      ...c.cardObj.card,
                      ...(c.cardObj.card.scryfall_json ? { 
                        scryfall_json: { ...c.cardObj.card.scryfall_json, ...updates.scryfall_json } 
                      } : { 
                        scryfall_json: updates.scryfall_json 
                      })
                    }
                  } : {}),
                  // Also update direct scryfall_json in cardObj
                  ...(c.cardObj.scryfall_json ? { 
                    scryfall_json: { ...c.cardObj.scryfall_json, ...updates.scryfall_json } 
                  } : { 
                    scryfall_json: updates.scryfall_json 
                  })
                }
              } : {}),
              lastUpdated: timestamp
            };

            // CRITICAL: Store modal price for perfect synchronization if provided
            if (updates.modalPrice !== undefined) {
              updated.modalPrice = updates.modalPrice;
              if (updated.card) updated.card.modalPrice = updates.modalPrice;
              if (updated.cardObj) {
                updated.cardObj.modalPrice = updates.modalPrice;
                if (updated.cardObj.card) updated.cardObj.card.modalPrice = updates.modalPrice;
              }
            }
            
            return updated;
          }
          return c;
        });

        setDeck(prevDeck => ({
          ...prevDeck,
          cards: updatedCards,
          lastUpdated: timestamp
        }));
        
        return; // Exit early for fresh price data updates
      }

      // If we have a new printing with scryfall_json data, update the card's printing
      // Note: printing may be passed for foil updates too, but only process as printing update if scryfall_json is present
      if (updates.printing && updates.scryfall_json) {
        // Get the printing object from the updates
        const newPrintingCard = updates.scryfall_json || null;

        if (newPrintingCard) {
          // Store the modal price if provided for perfect synchronization
          if (updates.modalPrice !== undefined) {
            // Add modalPrice to the new printing card for the update
            newPrintingCard.modalPrice = updates.modalPrice;
          }
          
          // CRITICAL: Store the modal foil status if provided for perfect synchronization
          if (updates.foil !== undefined) {
            // Add modalFoilStatus to the new printing card for the update
            newPrintingCard.modalFoilStatus = updates.foil;
          }

          // Update the card preview immediately if it's showing this card
          // This provides instant visual feedback before the API call completes
          const currentPreviewCard = fixedPreview?.card;
          const cardName = cardObj.card?.name || cardObj.name;
          const previewCardName =
            currentPreviewCard?.name || currentPreviewCard?.card?.name;

          if (currentPreviewCard && previewCardName === cardName) {
            // console.log('[DeckViewEdit] Immediately updating preview with new printing');

            // Update the fixed preview with new printing data
            setFixedPreview({
              card: {
                ...currentPreviewCard,
                printing: updates.printing,
                scryfall_json: updates.scryfall_json,
                modalPrice: updates.modalPrice, // Include modal price for synchronization
                image_uris:
                  updates.image_uris || updates.scryfall_json?.image_uris,
                card_faces:
                  updates.card_faces || updates.scryfall_json?.card_faces,
              },
              top: 0,
              left: 0,
            });
          }

          // Use the existing function to update the printing in the deck
          handlePrintingUpdate(cardObj, newPrintingCard);
        } else {
          console.error(
            "[DeckViewEdit] Cannot update printing: missing scryfall_json data",
          );
          toast.error("Failed to update card printing: Missing card data");
        }
        return; // Exit early - printing updates are handled by handlePrintingUpdate
      }

      // If we have a new quantity, update the card's quantity or remove it if quantity < 1
      if (updates.quantity !== undefined) {
        try {
          // console.log('[DeckViewEdit] Updating quantity to:', updates.quantity);
          // console.log('[DeckViewEdit] Card object before quantity update:', cardObj);

          // If quantity is less than 1, remove the card instead of updating
          if (updates.quantity < 1) {
            // console.log('[DeckViewEdit] Quantity is < 1, removing card instead of updating');
            handleRemoveCard(cardObj);
            return;
          }

          const cardName = cardObj.card?.name || cardObj.name;
          if (!cardName) {
            console.error(
              "[DeckViewEdit] Cannot update quantity: missing card name",
            );
            toast.error("Failed to update quantity: Missing card data");
            return;
          }

          // Create a timestamp to force React to see the changes
          const timestamp = Date.now();

          // Create a deep copy of the cards array to modify
          const updatedCards = cards.map((c) => {
            // Find the card with the same name to update its quantity
            const cName = c.card?.name || c.name;
            if (cName === cardName) {
              // console.log(`[DeckViewEdit] Found card to update quantity: ${cName}, old count: ${c.count}, new count: ${updates.quantity}`);

              // Create a new object with updated quantity at all levels
              // This is critical - we need to update the count at EVERY possible path
              const updated = {
                ...c,
                count: updates.quantity, // Top-level count
                quantity: updates.quantity, // Some places might use quantity instead
                // Also ensure it's in all possible nested structures
                ...(c.card
                  ? {
                      card: {
                        ...c.card,
                        count: updates.quantity,
                        quantity: updates.quantity,
                      },
                    }
                  : {}),
                ...(c.cardObj
                  ? {
                      cardObj: {
                        ...c.cardObj,
                        count: updates.quantity,
                        quantity: updates.quantity,
                        ...(c.cardObj.card
                          ? {
                              card: {
                                ...c.cardObj.card,
                                count: updates.quantity,
                                quantity: updates.quantity,
                              },
                            }
                          : {}),
                      },
                    }
                  : {}),
              };

              // console.log('[DeckViewEdit] Updated card object:', updated);
              return updated;
            }
            return c;
          });

          // Update local state for immediate UI feedback with a new array reference
          setCards([...updatedCards]);

          // Update the deck object to ensure UI reflects changes
          setDeck((prevDeck) => {
            if (!prevDeck) return prevDeck;

            const updatedDeckCards = prevDeck.cards.map((c) => {
              const cName = c.name || c.card?.name || c.cardObj?.name;
              if (cName === cardName) {
                // Preserve all card data but update quantity
                return {
                  ...c,
                  count: updates.quantity,
                  quantity: updates.quantity,
                  // Preserve existing card data including printings
                  ...(c.card
                    ? {
                        card: {
                          ...c.card,
                          count: updates.quantity,
                          quantity: updates.quantity,
                          // Keep existing card ID and printing info
                          id: c.card.id || c.card.scryfall_id,
                          scryfall_id: c.card.scryfall_id || c.card.id,
                          set: c.card.set,
                          set_name: c.card.set_name,
                          collector_number: c.card.collector_number,
                        },
                      }
                    : {}),
                  ...(c.cardObj
                    ? {
                        cardObj: {
                          ...c.cardObj,
                          // Preserve existing card data
                          id: c.cardObj.id || c.cardObj.scryfall_id,
                          scryfall_id: c.cardObj.scryfall_id || c.cardObj.id,
                          set: c.cardObj.set,
                          set_name: c.cardObj.set_name,
                          collector_number: c.cardObj.collector_number,
                          count: updates.quantity,
                          quantity: updates.quantity,
                          ...(c.cardObj.card
                            ? {
                                card: {
                                  ...c.cardObj.card,
                                  count: updates.quantity,
                                  quantity: updates.quantity,
                                },
                              }
                            : {}),
                        },
                      }
                    : {}),
                };
              }
              return c;
            });

            return {
              ...prevDeck,
              cards: [...updatedDeckCards], // Use spread to create a new array reference
              lastUpdated: timestamp, // Add a timestamp to force React to detect the change
            };
          });

          // If the current preview card matches this card, update its quantity too
          const currentPreviewCard = fixedPreview?.card;
          const previewCardName =
            currentPreviewCard?.name || currentPreviewCard?.card?.name;

          if (currentPreviewCard && previewCardName === cardName) {
            setFixedPreview({
              card: {
                ...currentPreviewCard,
                count: updates.quantity,
                ...(currentPreviewCard.card
                  ? {
                      card: {
                        ...currentPreviewCard.card,
                        count: updates.quantity,
                      },
                    }
                  : {}),
              },
              top: 0,
              left: 0,
            });
          }

          // Update the modal state card to reflect the quantity change
          // Only update if this is a quantity update and the modal card matches
          if (
            modalState.isOpen &&
            modalState.cardObj &&
            updates.quantity !== undefined
          ) {
            const modalCardName =
              modalState.cardObj.card?.name || modalState.cardObj.name;
            if (modalCardName === cardName) {
              setModalState((prevState) => ({
                ...prevState,
                cardObj: {
                  ...prevState.cardObj,
                  count: updates.quantity,
                  card: prevState.cardObj.card
                    ? {
                        ...prevState.cardObj.card,
                        count: updates.quantity,
                      }
                    : prevState.cardObj.card,
                },
              }));
            }
          }

          // Persist to the server for permanent storage
          try {
            // Get the authentication token (this was missing in the original code)
            const token = localStorage.getItem("token");
            if (!token) {
              console.error(
                "[DeckViewEdit] No authentication token found for server update",
              );
              toast.error(
                "Quantity updated locally but cannot save to server: Not logged in",
              );
              return;
            }

            // Define and immediately execute an async function to handle the server update
            (async function updateServer() {
              const formattedCards = [];

              // Create a proper format for the server based on the updated cards
              updatedCards.forEach((card) => {
                // Get the card count/quantity - this is critical for the server to recognize changes
                const cardCount = parseInt(card.count, 10) || 1;

                // Create the base formatted card object
                const formattedCard = {
                  name: card.name || card.card?.name || "",
                  printing: card.printing || null,
                  foil: card.foil === true, // Make sure it's boolean
                  count: cardCount, // Include count for proper server handling
                };

                // Add card ID if available (important for server-side lookup)
                if (card.card && card.card._id) {
                  formattedCard.card = {
                    _id: card.card._id,
                    name: card.card.name,
                  };
                } else if (card._id) {
                  formattedCard._id = card._id;
                }

                // Add this formatted card to our array
                formattedCards.push(formattedCard);
              });

              const apiUrl = import.meta.env.VITE_API_URL;

              // console.log('[DeckViewEdit] Sending updated quantity to server. Formatted cards:', formattedCards);

              // Send the updated deck to the server with auth token - using await directly instead of nested function
              // console.log('[DeckViewEdit] Sending to server with token:', token.substring(0, 10) + '...');

              const response = await fetch(`${apiUrl}/api/decks/${id}`, {
                method: "PUT",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${token}`, // Add auth token - critical for the server auth middleware
                  "Cache-Control": "no-cache", // Prevent caching issues
                },
                credentials: "include", // Include cookies for sessions
                body: JSON.stringify({
                  cards: formattedCards,
                  name: name || deck.name,
                  techIdeas: techIdeas,
                  sideboard: sideboard,
                }),
              });

              // Check if the response is ok
              if (!response.ok) {
                console.error(
                  `[DeckViewEdit] Server error updating quantity: ${response.status}`,
                );
                // Get error details if available
                let errorDetails = "";
                try {
                  const errorData = await response.json();
                  errorDetails = errorData.message || errorData.error || "";
                } catch (e) {
                  // Ignore parse errors
                }
                toast.error(
                  `Quantity updated locally but failed to save to server. ${errorDetails}`,
                );
                return;
              }

              try {
                // Parse the response to ensure it was processed correctly
                const responseData = await response.json();
                // console.log('[DeckViewEdit] Quantity update server response:', responseData);

                // Update the deck with the server response to ensure consistency
                setDeck((prevDeck) => ({
                  ...prevDeck,
                  ...responseData,
                  cards: updatedCards, // Keep our local card state with all the UI-needed fields
                }));

                // Show success message only after successful server update
                toast.success(`Updated quantity to ${updates.quantity}.`);
              } catch (parseError) {
                console.error(
                  "[DeckViewEdit] Error parsing server response:",
                  parseError,
                );
                toast.warning(
                  "Quantity updated but server response was invalid. Changes may not persist after refresh.",
                );
              }
            })(); // End of async function and immediate execution
          } catch (error) {
            console.error(
              "[DeckViewEdit] Error in server update for quantity:",
              error,
            );
            toast.error(
              `Quantity updated locally but failed to save to server: ${error.message}`,
            );
          }
        } catch (error) {
          console.error("[DeckViewEdit] Error updating quantity:", error);
          toast.error("Failed to update quantity.");
        }
      }

      // Handle foil/non-foil update
      if (
        updates.isFoil !== undefined ||
        updates.foil !== undefined ||
        updates.price !== undefined ||
        updates.foilToggleAction === true
      ) {
        try {
          // Accept either 'isFoil' or 'foil' parameter to be more flexible
          const foilStatus =
            updates.isFoil !== undefined ? updates.isFoil : updates.foil;
          const explicitPrice = updates.price;

          const timestamp = Date.now();

          // Create a new copy of the cards array with the matching card deeply updated
          const updatedCards = cards.map((c) => {
            const cName = c.card?.name || c.name;
            const cardName = cardObj.card?.name || cardObj.name;

            // For foil updates, match by name only (since printing info may not be available in updates)
            // For printing updates, we need to match by both name and printing
            const cPrinting = c.printing || c.card?.printing;
            const cardPrinting = cardObj.printing || cardObj.card?.printing;

            // Match by name, and optionally by printing if both cards have printing info
            const nameMatches = cName === cardName;
            const printingMatches =
              !cPrinting || !cardPrinting || cPrinting === cardPrinting;

            if (nameMatches && printingMatches) {
              // Deep clone to avoid reference issues
              const updated = JSON.parse(JSON.stringify(c));

              // Update foil status at all levels
              updated.foil = !!foilStatus;
              if (updated.card) updated.card.foil = !!foilStatus;
              if (updated.cardObj) {
                updated.cardObj.foil = !!foilStatus;
                if (updated.cardObj.card) updated.cardObj.card.foil = !!foilStatus;
              }

              // Recalculate price based on the new foil status
              const priceData = extractPrice(updated);
              const priceToUse =
                explicitPrice !== undefined && explicitPrice !== null ? explicitPrice : priceData.price;

              // Update price at all levels
              updated.price = priceToUse;
              if (updated.card) updated.card.price = priceToUse;
              if (updated.cardObj) {
                updated.cardObj.price = priceToUse;
                if (updated.cardObj.card) updated.cardObj.card.price = priceToUse;
              }

              // CRITICAL: Store modal price for perfect synchronization
              if (updates.modalPrice !== undefined) {
                updated.modalPrice = updates.modalPrice;
                if (updated.card) updated.card.modalPrice = updates.modalPrice;
                if (updated.cardObj) {
                  updated.cardObj.modalPrice = updates.modalPrice;
                  if (updated.cardObj.card) updated.cardObj.card.modalPrice = updates.modalPrice;
                }
              }

              updated.lastUpdated = timestamp;
              return updated;
            }
            return c;
          });
          
          // Update local state for immediate UI feedback
          setCards(updatedCards);

          // Update the deck object as well
          setDeck((prevDeck) => {
            if (!prevDeck) return null;
            return {
              ...prevDeck,
              cards: updatedCards,
              lastUpdated: timestamp,
            };
          });

          // Note: We intentionally do NOT update the modal state here
          // The modal handles its own state independently and the foil toggle
          // should not cause the modal to reinitialize

          // Persist to the server
          (async () => {
            try {
              const token = localStorage.getItem("token");
              if (!token) {
                toast.error(
                  "Foil status updated locally but cannot save to server: Not logged in",
                );
                return;
              }

              const apiUrl = import.meta.env.VITE_API_URL;
              const cleanCards = updatedCards.map((card) => {
                const { price } = extractPrice(card);
                return {
                  name: card.card?.name || card.name,
                  count: card.count || 1,
                  foil: !!card.foil, // Use the card's actual foil status, not extractPrice's interpretation
                  price: price,
                  printing: card.printing || null,
                  // CRITICAL FIX: Include modalPrice to persist synchronized pricing
                  ...(card.modalPrice !== undefined ? { modalPrice: card.modalPrice } : {}),
                  ...(card._id ? { _id: card._id } : {}),
                  ...(card.card && card.card._id
                    ? { card: { _id: card.card._id, name: card.card.name } }
                    : {}),
                };
              });

              // Debug logging for modalPrice persistence
              const cardsWithModalPrice = cleanCards.filter(c => c.modalPrice !== undefined);
              if (cardsWithModalPrice.length > 0) {
                console.log(`[CLEAN CARDS] Cards with modalPrice being sent to server:`, cardsWithModalPrice.map(c => `${c.name}: $${c.modalPrice}`).join(', '));
              }

              /* console.log('[DeckViewEdit] FOIL UPDATE - Sending to server:', {
                cardName: cardObj.card?.name || cardObj.name,
                foilStatus: foilStatus,
                cleanCards: cleanCards.filter(c => c.name === (cardObj.card?.name || cardObj.name))
              }); */

              const response = await fetch(`${apiUrl}/api/decks/${id}`, {
                method: "PUT",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${token}`,
                  "Cache-Control": "no-cache",
                },
                body: JSON.stringify({
                  cards: cleanCards,
                  name: name || deck.name,
                  lastUpdated: timestamp,
                  techIdeas: techIdeas,
                  sideboard: sideboard,
                }),
              });

              if (!response.ok) {
                throw new Error(`Server responded with ${response.status}`);
              }

              const responseData = await response.json();
              /* console.log('[DeckViewEdit] FOIL UPDATE - Server response received:', {
                cardName: cardObj.card?.name || cardObj.name,
                foilStatus: foilStatus,
                responseReceived: true
              }); */

              // Final consistency update with server response
              setDeck((prev) => ({
                ...prev,
                ...responseData,
                cards: updatedCards,
                lastUpdated: Date.now(),
              }));

              const priceInfo = foilStatus ? " (foil price applied)" : "";
              toast.success(
                `Updated to ${foilStatus ? "foil" : "non-foil"}${priceInfo}.`,
              );
            } catch (error) {
              console.error(
                "[DeckViewEdit] Error saving foil status to server:",
                error,
              );
              toast.error(
                `Foil status updated locally but failed to save to server: ${error.message}`,
              );
            }
          })();
        } catch (error) {
          console.error("[DeckViewEdit] Error updating foil status:", error);
          toast.error("Failed to update foil status.");
        }
      }
    } catch (error) {
      // Central error handling for all card updates
      console.error("[DeckViewEdit] Card update error:", error);
      toast.error(`Failed to update card: ${error.message}`);
    }
  }

  function handleRemoveCard(cardObjToRemove) {
    const cardName =
      cardObjToRemove.name ||
      cardObjToRemove.cardObj?.name ||
      cardObjToRemove.cardObj?.card?.name;

    if (!cardName) {
      console.error(
        "[DeckViewEdit] Failed to remove card: Could not determine card name",
      );
      toast.error("Failed to remove card: Could not determine card name");
      return;
    }

    // console.log('[DeckViewEdit] Removing card from deck:', cardName);

    try {
      // Create a timestamp to force React to see the changes
      const timestamp = Date.now();

      // Filter out the specific card from the cards array (match by name, printing, and foil status)
      const updatedCards = cards.filter((c) => {
        const cName = c.name || c.card?.name || c.cardObj?.name || c.cardObj?.card?.name;
        const cPrinting = c.printing || c.cardObj?.printing;
        const cFoil = c.foil;
        
        // Get card details to remove
        const removeName = cardObjToRemove.name || cardObjToRemove.cardObj?.name || cardObjToRemove.cardObj?.card?.name;
        const removePrinting = cardObjToRemove.printing || cardObjToRemove.cardObj?.printing;
        const removeFoil = cardObjToRemove.foil;
        
        // Only remove if ALL properties match: name, printing, and foil status
        const shouldRemove = (cName === removeName && cPrinting === removePrinting && cFoil === removeFoil);
        
        if (shouldRemove) {
          console.log(`[DeckViewEdit] Removing specific card: ${cName} (printing: ${cPrinting}, foil: ${cFoil})`);
        }
        
        return !shouldRemove;
      });

      // console.log(`[DeckViewEdit] Cards count before: ${cards.length}, after: ${updatedCards.length}`);

      // Update the cards state with the filtered array
      setCards([...updatedCards]); // Use spread to create a new array reference

      // Update the deck object with the filtered cards as well
      setDeck((prevDeck) => {
        if (!prevDeck) return prevDeck;

        const updatedDeckCards = prevDeck.cards.filter((c) => {
          const cName = c.name || c.card?.name || c.cardObj?.name || c.cardObj?.card?.name;
          const cPrinting = c.printing || c.cardObj?.printing;
          const cFoil = c.foil;
          
          // Get card details to remove
          const removeName = cardObjToRemove.name || cardObjToRemove.cardObj?.name || cardObjToRemove.cardObj?.card?.name;
          const removePrinting = cardObjToRemove.printing || cardObjToRemove.cardObj?.printing;
          const removeFoil = cardObjToRemove.foil;
          
          // Only remove if ALL properties match: name, printing, and foil status
          const shouldRemove = (cName === removeName && cPrinting === removePrinting && cFoil === removeFoil);
          
          return !shouldRemove;
        });

        // console.log(`[DeckViewEdit] Deck cards count before: ${prevDeck.cards.length}, after: ${updatedDeckCards.length}`);

        return {
          ...prevDeck,
          cards: [...updatedDeckCards], // Use spread to create a new array reference
          lastUpdated: timestamp, // Add a timestamp to force React to detect the change
        };
      });

      // Close the modal immediately for better UX
      setModalState({ isOpen: false, cardObj: null });

      // Get the authentication token (this was missing in the original code)
      const token = localStorage.getItem("token");
      if (!token) {
        console.error(
          "[DeckViewEdit] No authentication token found for server update",
        );
        toast.error(
          "Card removed locally but cannot save to server: Not logged in",
        );
        return;
      }

      // Format the cards properly for the server
      const formattedCards = updatedCards.map((card) => {
        // Make sure each card has proper structure with necessary fields for the server
        const formattedCard = {
          name: card.name || card.card?.name || "",
          printing: card.printing || null,
          foil: card.foil === true, // Make sure it's boolean
        };

        // Add card ID if available (important for server-side lookup)
        if (card.card && card.card._id) {
          formattedCard.card = {
            _id: card.card._id,
            name: card.card.name,
          };
        } else if (card._id) {
          formattedCard._id = card._id;
        }

        return formattedCard;
      });

      // Update the server - critical to ensure changes persist after refresh
      const apiUrl = import.meta.env.VITE_API_URL;

      // Use a single async IIFE to avoid multiple server updates
      (async () => {
        try {
          // console.log('[DeckViewEdit] Sending updated deck to server after card removal');
          // console.log('[DeckViewEdit] Formatted cards for server:', formattedCards);

          const response = await fetch(`${apiUrl}/api/decks/${id}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`, // Add auth token (critical fix)
            },
            body: JSON.stringify({
              cards: formattedCards,
              name: name || deck.name,
              techIdeas: techIdeas,
              sideboard: sideboard,
            }),
          });

          if (!response.ok) {
            console.error(
              `[DeckViewEdit] Server error removing card: ${response.status}`,
            );
            // Get error details if available
            let errorDetails = "";
            try {
              const errorData = await response.json();
              errorDetails = errorData.message || errorData.error || "";
            } catch (e) {
              // Ignore parse errors
            }
            toast.error(
              `Card removed locally but failed to save to server. ${errorDetails}`,
            );
            return;
          }

          // Parse the response to ensure it was processed correctly
          const responseData = await response.json();
          // console.log('[DeckViewEdit] Card removal server response:', responseData);

          // Show success message only after successful server update
          toast.success("Card removed from deck.");
        } catch (error) {
          console.error("[DeckViewEdit] Network error removing card:", error);
          toast.error("Card removed locally but failed to save to server.");
        }
      })();
    } catch (error) {
      console.error("[DeckViewEdit] Error in card removal process:", error);
      toast.error("Failed to remove card due to an error.");
    }
  }

  function handleMoveToSideboard(cardObjToMove) {
    if (!cardObjToMove) {
      console.error("[DeckViewEdit] Cannot move to sideboard: missing card object");
      toast.error("Failed to move card to sideboard: Missing card data");
      return;
    }

    const cardName = cardObjToMove.name || 
                     cardObjToMove.cardObj?.name || 
                     cardObjToMove.cardObj?.card?.name ||
                     cardObjToMove.card?.name;

    if (!cardName) {
      console.error("[DeckViewEdit] Cannot move to sideboard: could not determine card name");
      toast.error("Failed to move card to sideboard: Could not determine card name");
      return;
    }

    try {
      // Get the proper source card data
      const sourceCardData = cardObjToMove.cardObj || cardObjToMove.card || cardObjToMove;
      
      // Create the sideboard card data
      const sideboardCard = {
        name: cardName,
        count: cardObjToMove.count || 1,
        printing: cardObjToMove.printing || cardObjToMove.cardObj?.printing,
        foil: cardObjToMove.foil === true, // Explicitly preserve foil status
        card: {
          name: sourceCardData.name || cardName,
          type_line: sourceCardData.type_line,
          scryfall_json: sourceCardData,
          printing: cardObjToMove.printing || sourceCardData.id || sourceCardData.scryfall_id
        },
        cardObj: sourceCardData,
        scryfall_json: sourceCardData,
        addedToSideboard: Date.now()
      };

      let updatedCards = cards;
      let updatedTechIdeas = techIdeas;

      // Check if card is from tech ideas and remove it
      if (cardObjToMove.fromTechIdeas) {
        updatedTechIdeas = techIdeas.filter(card => 
          !(card.name === sideboardCard.name && 
            card.printing === sideboardCard.printing && 
            card.foil === sideboardCard.foil)
        );
        
        setTechIdeas(updatedTechIdeas);
        
        // Update deck object
        setDeck(prevDeck => ({
          ...prevDeck,
          techIdeas: updatedTechIdeas,
          sideboard: [...(prevDeck.sideboard || []), sideboardCard],
          lastUpdated: Date.now()
        }));
      } else if (cardObjToMove.fromSideboard) {
        // If already in sideboard, don't duplicate
        toast.info(`"${sideboardCard.name}" is already in sideboard`);
        setModalState({ isOpen: false, cardObj: null });
        return;
      } else {
        // Card is from main deck - remove it and get updated array
        updatedCards = cards.filter((c) => {
          const cName = c.name || c.card?.name || c.cardObj?.name || c.cardObj?.card?.name;
          const cPrinting = c.printing || c.cardObj?.printing;
          const cFoil = c.foil;
          
          // Get card details to remove
          const removeName = cardObjToMove.name || cardObjToMove.cardObj?.name || cardObjToMove.cardObj?.card?.name;
          const removePrinting = cardObjToMove.printing || cardObjToMove.cardObj?.printing;
          const removeFoil = cardObjToMove.foil;
          
          // Only remove if ALL properties match: name, printing, and foil status
          const shouldRemove = (cName === removeName && cPrinting === removePrinting && cFoil === removeFoil);
          
          if (shouldRemove) {
            console.log(`[DeckViewEdit] Moving specific card to sideboard: ${cName} (printing: ${cPrinting}, foil: ${cFoil})`);
          }
          
          return !shouldRemove;
        });

        // Update states
        setCards(updatedCards);
        
        // Update deck object
        setDeck(prevDeck => ({
          ...prevDeck,
          cards: updatedCards,
          sideboard: [...(prevDeck.sideboard || []), sideboardCard],
          lastUpdated: Date.now()
        }));
      }

      // Add to sideboard and get updated array
      const updatedSideboard = [...sideboard, sideboardCard];
      setSideboard(updatedSideboard);

      setModalState({ isOpen: false, cardObj: null });
      toast.success(`Moved "${cardName}" to sideboard`);

      // Save to server with updated arrays
      (async () => {
        try {
          const token = localStorage.getItem("token");
          if (!token) {
            console.warn("[DeckViewEdit] No auth token for sideboard update");
            return;
          }

          const apiUrl = import.meta.env.VITE_API_URL;
          
          // Format the cards properly for the server using updated array
          const formattedCards = updatedCards.map((card) => {
            const formattedCard = {
              name: card.name || card.card?.name || "",
              printing: card.printing || null,
              foil: card.foil === true,
            };

            if (card.card && card.card._id) {
              formattedCard.card = {
                _id: card.card._id,
                name: card.card.name,
              };
            } else if (card._id) {
              formattedCard._id = card._id;
            }

            return formattedCard;
          });

          // Format the sideboard properly for the server using updated array
          const formattedSideboard = updatedSideboard.map((card) => ({
            name: card.name || card.card?.name || "",
            printing: card.printing || null,
            foil: card.foil === true,
            card: card.card || { name: card.name },
            addedToSideboard: card.addedToSideboard || Date.now()
          }));

          // Format the tech ideas properly for the server using updated array
          const formattedTechIdeas = updatedTechIdeas.map((card) => ({
            name: card.name || card.card?.name || "",
            printing: card.printing || null,
            foil: card.foil === true,
            card: card.card || { name: card.name },
            addedToTechIdeas: card.addedToTechIdeas || Date.now()
          }));

          console.log(`[DeckViewEdit] Saving to server - Cards: ${formattedCards.length}, Sideboard: ${formattedSideboard.length}, Tech Ideas: ${formattedTechIdeas.length}`);

          const response = await fetch(`${apiUrl}/api/decks/${deck._id}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({
              name: deck.name,
              format: deck.format,
              cards: formattedCards,
              sideboard: formattedSideboard,
              techIdeas: formattedTechIdeas,
            }),
            credentials: "include",
          });

          if (!response.ok) {
            throw new Error(`Server responded with status ${response.status}`);
          }
        } catch (error) {
          console.error("[DeckViewEdit] Error saving sideboard to server:", error);
          toast.error("Card moved to sideboard locally but failed to save to server");
        }
      })();
    } catch (error) {
      console.error("[DeckViewEdit] Error moving card to sideboard:", error);
      toast.error("Failed to move card to sideboard");
    }
  }

  // Helper function to add a card to tech ideas
  function handleAddToTechIdeas(cardData) {
    try {
      const techIdeasCard = {
        name: cardData.name,
        count: 1,
        printing: cardData.id || cardData.scryfall_id,
        foil: false,
        card: {
          name: cardData.name,
          type_line: cardData.type_line,
          scryfall_json: cardData,
          printing: cardData.id || cardData.scryfall_id
        },
        cardObj: cardData,
        scryfall_json: cardData,
        addedToTechIdeas: Date.now()
      };

      // Add to tech ideas state
      setTechIdeas(prev => [...prev, techIdeasCard]);
      
      // Update deck object
      setDeck(prevDeck => ({
        ...prevDeck,
        techIdeas: [...(prevDeck.techIdeas || []), techIdeasCard],
        lastUpdated: Date.now()
      }));

      toast.success(`Added "${cardData.name}" to tech ideas`);

      // Save to server
      (async () => {
        try {
          const token = localStorage.getItem("token");
          if (!token) return;

          // Format the cards properly for the server
          const formattedCards = cards.map((card) => {
            const formattedCard = {
              name: card.name || card.card?.name || "",
              printing: card.printing || null,
              foil: card.foil === true,
            };

            if (card.card && card.card._id) {
              formattedCard.card = {
                _id: card.card._id,
                name: card.card.name,
              };
            } else if (card._id) {
              formattedCard._id = card._id;
            }

            return formattedCard;
          });

          // Format the tech ideas properly for the server
          const currentTechIdeas = [...(deck.techIdeas || []), techIdeasCard];
          const formattedTechIdeas = currentTechIdeas.map((card) => ({
            name: card.name || card.card?.name || "",
            printing: card.printing || null,
            foil: card.foil === true,
            card: card.card || { name: card.name },
            addedToTechIdeas: card.addedToTechIdeas || Date.now()
          }));

          const dataToSave = {
            name: deck.name,
            format: deck.format,
            cards: formattedCards,
            sideboard: sideboard,
            techIdeas: formattedTechIdeas,
          };

          console.log('[DEBUG] Saving tech ideas to server:', {
            techIdeas: dataToSave.techIdeas.length,
            sideboard: dataToSave.sideboard.length
          });

          const apiUrl = import.meta.env.VITE_API_URL;
          const response = await fetch(`${apiUrl}/api/decks/${deck._id}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify(dataToSave),
            credentials: "include",
          });

          if (!response.ok) {
            throw new Error(`Server responded with status ${response.status}`);
          }

          console.log('[DEBUG] Tech ideas saved successfully');
        } catch (error) {
          console.error("Error saving tech ideas to server:", error);
          toast.error("Card added locally but failed to save to server");
        }
      })();
    } catch (error) {
      console.error("Error adding card to tech ideas:", error);
      toast.error("Failed to add card to tech ideas");
    }
  }

  // Helper function to add a card to sideboard
  function handleAddToSideboard(cardData) {
    try {
      const sideboardCard = {
        name: cardData.name,
        count: 1,
        printing: cardData.id || cardData.scryfall_id,
        foil: false,
        card: {
          name: cardData.name,
          type_line: cardData.type_line,
          scryfall_json: cardData,
          printing: cardData.id || cardData.scryfall_id
        },
        cardObj: cardData,
        scryfall_json: cardData,
        addedToSideboard: Date.now()
      };

      // Add to sideboard state
      setSideboard(prev => [...prev, sideboardCard]);
      
      // Update deck object
      setDeck(prevDeck => ({
        ...prevDeck,
        sideboard: [...(prevDeck.sideboard || []), sideboardCard],
        lastUpdated: Date.now()
      }));

      toast.success(`Added "${cardData.name}" to sideboard`);

      // Save to server
      (async () => {
        try {
          const token = localStorage.getItem("token");
          if (!token) return;

          // Format the cards properly for the server
          const formattedCards = cards.map((card) => {
            const formattedCard = {
              name: card.name || card.card?.name || "",
              printing: card.printing || null,
              foil: card.foil === true,
            };

            if (card.card && card.card._id) {
              formattedCard.card = {
                _id: card.card._id,
                name: card.card.name,
              };
            } else if (card._id) {
              formattedCard._id = card._id;
            }

            return formattedCard;
          });

          // Format the sideboard properly for the server
          const currentSideboard = [...(deck.sideboard || []), sideboardCard];
          const formattedSideboard = currentSideboard.map((card) => ({
            name: card.name || card.card?.name || "",
            printing: card.printing || null,
            foil: card.foil === true,
            card: card.card || { name: card.name },
            addedToSideboard: card.addedToSideboard || Date.now()
          }));

          const apiUrl = import.meta.env.VITE_API_URL;
          await fetch(`${apiUrl}/api/decks/${deck._id}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({
              name: deck.name,
              format: deck.format,
              cards: formattedCards,
              sideboard: formattedSideboard,
              techIdeas: techIdeas,
            }),
            credentials: "include",
          });
        } catch (error) {
          console.error("Error saving sideboard to server:", error);
          toast.error("Card added locally but failed to save to server");
        }
      })();
    } catch (error) {
      console.error("Error adding card to sideboard:", error);
      toast.error("Failed to add card to sideboard");
    }
  }

  function handleAddToCollection(cardObjToAdd, selectedPrinting) {
    try {
      console.log('[AddToCollection] Input data:', { cardObjToAdd, selectedPrinting });
      
      // Get the current foil status from the modal
      const foilStatus = selectedPrinting?.foil || cardObjToAdd?.foil || false;
      
      // Extract Scryfall JSON data from various possible locations
      const scryfallData = selectedPrinting || 
                          cardObjToAdd?.cardObj?.scryfall_json || 
                          cardObjToAdd?.scryfall_json ||
                          cardObjToAdd?.cardObj?.card?.scryfall_json ||
                          cardObjToAdd?.card?.scryfall_json ||
                          cardObjToAdd?.cardObj;
      
      console.log('[AddToCollection] Extracted Scryfall data:', scryfallData);
      console.log('[AddToCollection] Card structure:', {
        name: cardObjToAdd?.name,
        cardObjName: cardObjToAdd?.cardObj?.name,
        cardObjSet: cardObjToAdd?.cardObj?.set,
        cardObjScryfallJson: !!cardObjToAdd?.cardObj?.scryfall_json,
        scryfallDataSet: scryfallData?.set,
        scryfallDataSetName: scryfallData?.set_name
      });
      
      // Create collection item with all necessary data
      const collectionItem = {
        id: `${scryfallData?.id || cardObjToAdd?.printing || cardObjToAdd?.cardObj?.printing}_${foilStatus ? 'foil' : 'nonfoil'}_${Date.now()}`,
        name: cardObjToAdd?.name || cardObjToAdd?.cardObj?.name || scryfallData?.name,
        set: scryfallData?.set || cardObjToAdd?.cardObj?.set || 'unknown',
        set_name: scryfallData?.set_name || cardObjToAdd?.cardObj?.set_name || scryfallData?.set || 'Unknown Set',
        collector_number: scryfallData?.collector_number || cardObjToAdd?.cardObj?.collector_number,
        printing_id: scryfallData?.id || cardObjToAdd?.printing || cardObjToAdd?.cardObj?.printing,
        rarity: scryfallData?.rarity || cardObjToAdd?.cardObj?.rarity,
        foil: foilStatus,
        scryfall_json: scryfallData,
        dateAdded: new Date().toISOString(),
        quantity: 1 // Default to 1, user can modify later
      };
      
      console.log('[AddToCollection] Final collection item:', collectionItem);

      // Get existing collection from localStorage
      const existingCollection = JSON.parse(localStorage.getItem('cardCollection') || '[]');
      
      // Check if this exact printing/foil combination already exists
      const existingIndex = existingCollection.findIndex(item => 
        item.printing_id === collectionItem.printing_id && 
        item.foil === collectionItem.foil
      );
      
      if (existingIndex >= 0) {
        // If it exists, increment quantity
        existingCollection[existingIndex].quantity += 1;
        toast.success(`Added another copy to collection! Now have ${existingCollection[existingIndex].quantity} copies.`);
      } else {
        // If it doesn't exist, add new item
        existingCollection.push(collectionItem);
        toast.success(`Added ${collectionItem.name} (${foilStatus ? 'Foil' : 'Non-foil'}) to collection!`);
      }
      
      // Save updated collection
      localStorage.setItem('cardCollection', JSON.stringify(existingCollection));
      
      // Force re-render of collection status grouping if currently grouped by collection status
      if (groupBy === 'collectionStatus') {
        console.log('[Collection] Triggering re-render for collection status grouping');
        setCollectionUpdateCounter(prev => prev + 1);
      }
      
      console.log('[Collection] Added item:', collectionItem);
      console.log('[Collection] Updated collection:', existingCollection);
      
    } catch (error) {
      console.error('[Collection] Error adding to collection:', error);
      toast.error('Failed to add card to collection. Please try again.');
    }
    
    // Don't close the modal automatically - let user continue adding cards or close manually
    // setModalState({ isOpen: false, cardObj: null });
  }

  // Bulk Edit Operation Handlers
  const handleBulkAddToCollection = async () => {
    if (selectedCards.size === 0) return;
    
    try {
      let successCount = 0;
      let failureCount = 0;
      const selectedCardIds = Array.from(selectedCards);
      
      // Get existing collection from localStorage
      const existingCollection = JSON.parse(localStorage.getItem('cardCollection') || '[]');
      
      selectedCardIds.forEach(cardId => {
        try {
          // Find the card object by ID
          const cardObj = findCardObjectById(cardId);
          if (!cardObj) {
            failureCount++;
            return;
          }
          
          // Extract Scryfall JSON data from various possible locations
          const scryfallData = cardObj.cardObj?.scryfall_json || 
                              cardObj.scryfall_json ||
                              cardObj.cardObj?.card?.scryfall_json ||
                              cardObj.card?.scryfall_json ||
                              cardObj.cardObj;
          
          // Create collection item with improved set data extraction
          const collectionItem = {
            id: `${scryfallData?.id || cardObj.printing || cardObj.cardObj?.printing || 'unknown'}_${cardObj.foil ? 'foil' : 'nonfoil'}_${Date.now()}_${Math.random()}`,
            name: cardObj.card?.name || cardObj.name || scryfallData?.name || 'Unknown Card',
            set: scryfallData?.set || cardObj.cardObj?.set || cardObj.set || 'unknown',
            set_name: scryfallData?.set_name || cardObj.cardObj?.set_name || cardObj.set_name || scryfallData?.set || 'Unknown Set',
            collector_number: scryfallData?.collector_number || cardObj.cardObj?.collector_number || cardObj.collector_number,
            printing_id: scryfallData?.id || cardObj.printing || cardObj.cardObj?.printing,
            rarity: scryfallData?.rarity || cardObj.cardObj?.rarity || cardObj.rarity,
            foil: cardObj.foil || false,
            scryfall_json: scryfallData,
            dateAdded: new Date().toISOString(),
            quantity: cardObj.count || 1
          };
          
          // Check if this exact printing/foil combination already exists
          const existingIndex = existingCollection.findIndex(item => 
            item.printing_id === collectionItem.printing_id && 
            item.foil === collectionItem.foil
          );
          
          if (existingIndex >= 0) {
            // If it exists, increment quantity
            existingCollection[existingIndex].quantity += collectionItem.quantity;
          } else {
            // If it doesn't exist, add new item
            existingCollection.push(collectionItem);
          }
          
          successCount++;
        } catch (error) {
          console.error(`[Bulk Collection] Failed to add card ${cardId}:`, error);
          failureCount++;
        }
      });
      
      // Save updated collection
      localStorage.setItem('cardCollection', JSON.stringify(existingCollection));
      
      // Force re-render if grouped by collection status
      if (groupBy === 'collectionStatus') {
        setCollectionUpdateCounter(prev => prev + 1);
      }
      
      // Show appropriate success/error messages
      if (successCount > 0 && failureCount === 0) {
        toast.success(`Successfully added ${successCount} card${successCount !== 1 ? 's' : ''} to collection!`);
      } else if (successCount > 0 && failureCount > 0) {
        toast.warning(`Added ${successCount} cards to collection, but ${failureCount} failed.`);
      } else {
        toast.error('Failed to add cards to collection.');
        return;
      }
      
      // Clear selections and exit bulk mode
      setSelectedCards(new Set());
      setBulkEditMode(false);
      
    } catch (error) {
      console.error('[Bulk Collection] Error adding cards to collection:', error);
      toast.error('Failed to add cards to collection. Please try again.');
    }
  };

  const handleBulkAddToWishlist = () => {
    // TODO: Implement wishlist functionality
    toast.info(`Wishlist feature coming soon! Would add ${selectedCards.size} cards to wishlist.`);
  };

  const handleBulkMoveToSideboard = () => {
    if (selectedCards.size === 0) {
      toast.warning("No cards selected");
      return;
    }

    try {
      const selectedCardIds = Array.from(selectedCards);
      const cardsToMove = [];
      const cardsToKeep = [];

      // Process each card to determine which to move and which to keep
      cards.forEach(card => {
        const cardId = generateCardSelectionId(card);
        if (selectedCardIds.includes(cardId)) {
          // Add to sideboard
          cardsToMove.push({
            name: card.name || card.card?.name,
            count: card.count || 1,
            printing: card.printing || card.cardObj?.printing,
            foil: card.foil || false,
            cardObj: card.cardObj || card,
            addedToSideboard: Date.now()
          });
        } else {
          // Keep in main deck
          cardsToKeep.push(card);
        }
      });

      if (cardsToMove.length === 0) {
        toast.warning("No valid cards found to move to sideboard");
        return;
      }

      // Update states
      setCards(cardsToKeep);
      setSideboard(prev => [...prev, ...cardsToMove]);
      
      // Update deck object
      setDeck(prevDeck => ({
        ...prevDeck,
        cards: cardsToKeep,
        sideboard: [...(prevDeck.sideboard || []), ...cardsToMove],
        lastUpdated: Date.now()
      }));

      // Clear selections and exit bulk mode
      setSelectedCards(new Set());
      setBulkEditMode(false);

      toast.success(`Moved ${cardsToMove.length} card(s) to sideboard`);

      // Save to server
      (async () => {
        try {
          const token = localStorage.getItem("token");
          if (!token) return;

          // Format the cards properly for the server
          const formattedCards = cardsToKeep.map((card) => {
            const formattedCard = {
              name: card.name || card.card?.name || "",
              printing: card.printing || null,
              foil: card.foil === true,
            };

            if (card.card && card.card._id) {
              formattedCard.card = {
                _id: card.card._id,
                name: card.card.name,
              };
            } else if (card._id) {
              formattedCard._id = card._id;
            }

            return formattedCard;
          });

          // Format the sideboard properly for the server
          const currentSideboard = [...(deck.sideboard || []), ...cardsToMove];
          const formattedSideboard = currentSideboard.map((card) => ({
            name: card.name || card.card?.name || "",
            printing: card.printing || null,
            foil: card.foil === true,
            card: card.card || { name: card.name },
            addedToSideboard: card.addedToSideboard || Date.now()
          }));

          const apiUrl = import.meta.env.VITE_API_URL;
          await fetch(`${apiUrl}/api/decks/${deck._id}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({
              name: deck.name,
              format: deck.format,
              cards: formattedCards,
              sideboard: formattedSideboard,
              techIdeas: techIdeas,
            }),
            credentials: "include",
          });
        } catch (error) {
          console.error("Error saving sideboard to server:", error);
          toast.error("Cards moved locally but failed to save to server");
        }
      })();
    } catch (error) {
      console.error("Error moving cards to sideboard:", error);
      toast.error("Failed to move cards to sideboard");
    }
  };

  const handleBulkMoveToTechIdeas = () => {
    if (selectedCards.size === 0) {
      toast.warning("No cards selected");
      return;
    }

    try {
      const selectedCardIds = Array.from(selectedCards);
      const cardsToMove = [];

      // Find the selected cards and add them to tech ideas
      selectedCardIds.forEach(cardId => {
        const card = findCardObjectById(cardId);
        if (card) {
          cardsToMove.push({
            name: card.card?.name || card.name,
            count: card.count || 1,
            printing: card.printing || card.cardObj?.printing,
            foil: card.foil || false,
            cardObj: card.cardObj || card,
            addedToTechIdeas: Date.now()
          });
        }
      });

      if (cardsToMove.length === 0) {
        toast.warning("No valid cards found to add to tech ideas");
        return;
      }

      // Add to tech ideas (don't remove from main deck)
      setTechIdeas(prev => [...prev, ...cardsToMove]);
      
      // Update deck object
      setDeck(prevDeck => ({
        ...prevDeck,
        techIdeas: [...(prevDeck.techIdeas || []), ...cardsToMove],
        lastUpdated: Date.now()
      }));

      // Clear selections and exit bulk mode
      setSelectedCards(new Set());
      setBulkEditMode(false);

      toast.success(`Added ${cardsToMove.length} card(s) to tech ideas`);

      // Save to server
      (async () => {
        try {
          const token = localStorage.getItem("token");
          if (!token) return;

          // Format the cards properly for the server
          const formattedCards = cards.map((card) => {
            const formattedCard = {
              name: card.name || card.card?.name || "",
              printing: card.printing || null,
              foil: card.foil === true,
            };

            if (card.card && card.card._id) {
              formattedCard.card = {
                _id: card.card._id,
                name: card.card.name,
              };
            } else if (card._id) {
              formattedCard._id = card._id;
            }

            return formattedCard;
          });

          // Format the tech ideas properly for the server
          const currentTechIdeas = [...(deck.techIdeas || []), ...cardsToMove];
          const formattedTechIdeas = currentTechIdeas.map((card) => ({
            name: card.name || card.card?.name || "",
            printing: card.printing || null,
            foil: card.foil === true,
            card: card.card || { name: card.name },
            addedToTechIdeas: card.addedToTechIdeas || Date.now()
          }));

          const apiUrl = import.meta.env.VITE_API_URL;
          await fetch(`${apiUrl}/api/decks/${deck._id}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({
              name: deck.name,
              format: deck.format,
              cards: formattedCards,
              sideboard: sideboard,
              techIdeas: formattedTechIdeas,
            }),
            credentials: "include",
          });
        } catch (error) {
          console.error("Error saving tech ideas to server:", error);
          toast.error("Cards added locally but failed to save to server");
        }
      })();
    } catch (error) {
      console.error("Error adding cards to tech ideas:", error);
      toast.error("Failed to add cards to tech ideas");
    }
  };

  const handleBulkRemoveFromDeck = () => {
    if (selectedCards.size === 0) {
      toast.warning("No cards selected for removal");
      return;
    }

    const cardNamesToRemove = [];
    
    // Get all card names that need to be removed
    selectedCards.forEach(cardId => {
      const card = findCardObjectById(cardId);
      if (card) {
        const cardName = card.card?.name || card.name;
        if (cardName) {
          cardNamesToRemove.push(cardName);
        }
      }
    });

    if (cardNamesToRemove.length === 0) {
      toast.error("Could not find selected cards to remove");
      return;
    }

    try {
      // Filter out all selected cards from the deck
      const updatedCards = cards.filter((card) => {
        const cardName = card.card?.name || card.name;
        return !cardNamesToRemove.includes(cardName);
      });

      // Update the cards state
      setCards([...updatedCards]);

      // Update the deck object
      setDeck((prevDeck) => {
        if (!prevDeck) return prevDeck;

        const updatedDeckCards = prevDeck.cards.filter((card) => {
          const cardName = card.card?.name || card.name;
          return !cardNamesToRemove.includes(cardName);
        });

        return {
          ...prevDeck,
          cards: [...updatedDeckCards],
          lastUpdated: Date.now(),
        };
      });

      // Clear selections
      setSelectedCards(new Set());

      toast.success(`Removed ${cardNamesToRemove.length} card${cardNamesToRemove.length !== 1 ? 's' : ''} from deck`);

      // TODO: Save to server
      const token = localStorage.getItem("token");
      if (token) {
        // Format cards for server and save
        // This would need proper implementation similar to handleRemoveCard
      }

    } catch (error) {
      console.error('[DeckViewEdit] Error removing cards from deck:', error);
      toast.error("Failed to remove cards from deck");
    }
  };

  const handleBulkToggleFoil = () => {
    if (selectedCards.size === 0) {
      toast.warning("No cards selected for foil toggle");
      return;
    }

    const updatesCount = { foiled: 0, unfoiled: 0 };

    try {
      // Update each selected card's foil status
      const updatedCards = cards.map((card) => {
        const cardId = generateCardSelectionId(card);
        
        if (selectedCards.has(cardId)) {
          // Toggle foil status - check all possible locations
          const currentFoilStatus = 
            card.foil === true ||
            card.card?.foil === true ||
            card.cardObj?.foil === true ||
            card.cardObj?.card?.foil === true;
          
          const newFoilStatus = !currentFoilStatus;
          
          if (newFoilStatus) {
            updatesCount.foiled++;
          } else {
            updatesCount.unfoiled++;
          }

          // Create updated card with foil status set at all levels
          const updatedCard = {
            ...card,
            foil: newFoilStatus,
            // Update nested card structure
            ...(card.card ? {
              card: {
                ...card.card,
                foil: newFoilStatus
              }
            } : {}),
            // Update cardObj structure
            ...(card.cardObj ? {
              cardObj: {
                ...card.cardObj,
                foil: newFoilStatus,
                ...(card.cardObj.card ? {
                  card: {
                    ...card.cardObj.card,
                    foil: newFoilStatus
                  }
                } : {})
              }
            } : {})
          };

          return updatedCard;
        }
        
        return card;
      });

      // Update the cards state
      setCards([...updatedCards]);

      // Update the deck object
      setDeck((prevDeck) => {
        if (!prevDeck) return prevDeck;

        const updatedDeckCards = prevDeck.cards.map((card) => {
          const cardId = generateCardSelectionId(card);
          
          if (selectedCards.has(cardId)) {
            const currentFoilStatus = 
              card.foil === true ||
              card.card?.foil === true ||
              card.cardObj?.foil === true ||
              card.cardObj?.card?.foil === true;
            
            const newFoilStatus = !currentFoilStatus;

            return {
              ...card,
              foil: newFoilStatus,
              ...(card.card ? {
                card: {
                  ...card.card,
                  foil: newFoilStatus
                }
              } : {}),
              ...(card.cardObj ? {
                cardObj: {
                  ...card.cardObj,
                  foil: newFoilStatus,
                  ...(card.cardObj.card ? {
                    card: {
                      ...card.cardObj.card,
                      foil: newFoilStatus
                    }
                  } : {})
                }
              } : {})
            };
          }
          
          return card;
        });

        return {
          ...prevDeck,
          cards: [...updatedDeckCards],
          lastUpdated: Date.now(),
        };
      });

      // Clear selections
      setSelectedCards(new Set());

      const totalUpdated = updatesCount.foiled + updatesCount.unfoiled;
      let message = `Updated ${totalUpdated} card${totalUpdated !== 1 ? 's' : ''}`;
      if (updatesCount.foiled > 0 && updatesCount.unfoiled > 0) {
        message += ` (${updatesCount.foiled} to foil, ${updatesCount.unfoiled} to non-foil)`;
      } else if (updatesCount.foiled > 0) {
        message += ` to foil`;
      } else {
        message += ` to non-foil`;
      }
      
      toast.success(message);

      // TODO: Save to server
      const token = localStorage.getItem("token");
      if (token) {
        // Format cards for server and save
        // This would need proper implementation similar to handleUpdateCard
      }

    } catch (error) {
      console.error('[DeckViewEdit] Error toggling foil status:', error);
      toast.error("Failed to toggle foil status");
    }
  };

  // Helper function to find card object by ID for bulk operations
  const findCardObjectById = (cardId) => {
    // Search through all cards to find the one with matching ID
    const allCards = cards && cards.length > 0 ? cards : deck?.cards || [];
    return allCards.find(card => {
      const cardName = card.card?.name || card.name;
      const cardPrinting = card.printing || card.cardObj?.printing;
      const cardFoil = card.foil || false;
      const generatedId = `${cardName}_${cardPrinting || 'unknown'}_${cardFoil}`;
      return generatedId === cardId;
    });
  };

  // Function to generate unique ID for card selection
  const generateCardSelectionId = (cardData) => {
    const cardName = cardData.card?.name || cardData.name;
    const cardPrinting = cardData.printing || cardData.cardObj?.printing;
    // Use comprehensive foil detection logic to match rendering
    const cardFoil = 
      cardData.foil === true ||
      cardData.card?.foil === true ||
      cardData.cardObj?.foil === true ||
      cardData.cardObj?.card?.foil === true;
    return `${cardName}_${cardPrinting || 'unknown'}_${cardFoil}`;
  };

  // Function to toggle card selection
  const toggleCardSelection = (cardData) => {
    const cardId = generateCardSelectionId(cardData);
    setSelectedCards(prev => {
      const newSet = new Set(prev);
      if (newSet.has(cardId)) {
        newSet.delete(cardId);
      } else {
        newSet.add(cardId);
      }
      return newSet;
    });
  };

  // Context menu state
  const [contextMenu, setContextMenu] = useState({
    open: false,
    x: 0,
    y: 0,
    cardObj: null,
  });

  // Close context menu on click elsewhere
  useEffect(() => {
    if (!contextMenu.open) return;
    const close = () =>
      setContextMenu({ open: false, x: 0, y: 0, cardObj: null });
    window.addEventListener("click", close);
    window.addEventListener("contextmenu", close);
    return () => {
      window.removeEventListener("click", close);
      window.removeEventListener("contextmenu", close);
    };
  }, [contextMenu.open]);

  // Minimal logging for production
  if (loading) {
    return (
      <div className="container">
        <div>Loading deck...</div>
      </div>
    );
  }
  if (!deck) {
    return <div className="container">Deck not found.</div>;
  }

  // Render the main component with deck layout and sidebar
  return (
    <>
      {/* Deck title moved above main layout, between Nav and content */}
      <div
        className="deck-title-bar"
        style={{
          width: "100%",
          textAlign: "center",
          background: "white",
          boxShadow: "0 2px 8px rgba(0,0,0,0.04)",
          paddingTop: 8,
          paddingBottom: 8,
        }}
      >
        <h2
          style={{
            margin: 0,
            fontSize: "2rem",
            fontWeight: 700,
            letterSpacing: "-0.5px",
            cursor: "pointer",
            display: "inline-block",
            transition: "color 0.15s",
          }}
          title="Click to copy deck link"
          onClick={async () => {
            try {
              const url = window.location.origin + `/decks/${id}`;
              await navigator.clipboard.writeText(url);
              toast.success("Deck link copied!");
            } catch {
              toast.error("Failed to copy link");
            }
          }}
          onMouseOver={(e) => (e.currentTarget.style.color = "#1976d2")}
          onMouseOut={(e) => (e.currentTarget.style.color = "")}
        >
          {deck.name || "Untitled Deck"}
        </h2>
      </div>

      {/* Deck Stats Section - standalone like title bar */}
      <div
        className="deck-stats-bar"
        style={{
          width: "100%",
          background: "white",
          boxShadow: "0 2px 8px rgba(0,0,0,0.04)",
          marginBottom: "1rem",
        }}
      >
        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "flex-start",
            maxWidth: "1200px",
            margin: "0 auto",
            gap: "24px",
            flexWrap: "wrap",
            padding: "16px 24px",
          }}
        >
          {/* Total Value & Collection */}
          <div style={{ textAlign: "center", minWidth: "120px", flex: "0 0 auto" }}>
            <div style={{ marginBottom: "12px" }}>
              <div style={{ fontSize: "14px", color: "#666", marginBottom: "2px" }}>
                Total Value
              </div>
              <div style={{ fontSize: "12px", fontWeight: "bold", color: "#2c5530" }}>
                ${(() => {
                  const totalValue = (cards || deck?.cards || []).reduce((sum, cardObj) => {
                    const priceData = extractPrice(cardObj);
                    const price = parseFloat(priceData.price) || 0;
                    const quantity = cardObj.count || cardObj.quantity || 1;
                    return sum + (price * quantity);
                  }, 0);
                  return totalValue.toFixed(2);
                })()}
              </div>
            </div>
            <div>
              <div style={{ fontSize: "14px", color: "#666", marginBottom: "2px" }}>
                In Collection
              </div>
              <div style={{ fontSize: "12px", fontWeight: "bold", color: "#1976d2" }}>
                {(() => {
                  // Get collection from localStorage for accurate percentage calculation
                  const collection = JSON.parse(localStorage.getItem('cardCollection') || '[]');
                  
                  // Create a map for faster lookup: printing_id + foil -> quantity
                  const collectionMap = new Map();
                  collection.forEach(item => {
                    const key = `${item.printing_id}_${item.foil}`;
                    collectionMap.set(key, (collectionMap.get(key) || 0) + item.quantity);
                  });
                  
                  let totalCards = 0;
                  let ownedCards = 0;
                  
                  (cards || deck?.cards || []).forEach(cardObj => {
                    const quantity = cardObj.count || cardObj.quantity || 1;
                    totalCards += quantity;
                    
                    // Get printing ID from various possible locations
                    const printingId = cardObj.printing || 
                                      cardObj.cardObj?.printing || 
                                      cardObj.cardObj?.card?.printing ||
                                      cardObj.card?.printing ||
                                      cardObj.scryfall_id ||
                                      cardObj.id ||
                                      cardObj.cardObj?.scryfall_id ||
                                      cardObj.cardObj?.id ||
                                      cardObj.cardObj?.card?.scryfall_id ||
                                      cardObj.cardObj?.card?.id;
                    
                    // Get foil status
                    const isFoil = cardObj.foil === true || 
                                  cardObj.isFoil === true ||
                                  cardObj.cardObj?.foil === true ||
                                  cardObj.cardObj?.isFoil === true ||
                                  cardObj.cardObj?.card?.foil === true ||
                                  cardObj.cardObj?.card?.isFoil === true;
                    
                    if (printingId) {
                      // Check both foil and non-foil versions in collection
                      const foilKey = `${printingId}_true`;
                      const nonFoilKey = `${printingId}_false`;
                      
                      const foilOwned = collectionMap.get(foilKey) || 0;
                      const nonFoilOwned = collectionMap.get(nonFoilKey) || 0;
                      
                      // If we have any copies (either matching the foil status or any version), consider it owned
                      const hasMatchingFoilStatus = isFoil ? foilOwned > 0 : nonFoilOwned > 0;
                      const hasAnyVersion = (foilOwned + nonFoilOwned) > 0;
                      
                      if (hasMatchingFoilStatus || hasAnyVersion) {
                        ownedCards += quantity;
                      }
                    }
                  });
                  
                  const percentage = totalCards > 0 ? Math.round((ownedCards / totalCards) * 100) : 0;
                  return `${percentage}%`;
                })()}
              </div>
            </div>
          </div>

          {/* Mana Distribution */}
          <div style={{ textAlign: "center", minWidth: "150px", flex: "0 0 auto" }}>
            <div style={{ fontSize: "14px", color: "#666", marginBottom: "8px" }}>
              Mana Distribution
            </div>
            <div style={{ display: "flex", gap: "2px", justifyContent: "center", alignItems: "center" }}>
              {(() => {
                const manaCounts = { W: 0, U: 0, B: 0, R: 0, G: 0 };
                (cards || deck?.cards || []).forEach(cardObj => {
                  const quantity = cardObj.count || cardObj.quantity || 1;
                  const manaCost = cardObj?.scryfall_json?.mana_cost || 
                                 cardObj?.card?.scryfall_json?.mana_cost || 
                                 cardObj?.mana_cost || 
                                 cardObj?.card?.mana_cost || '';
                  
                  // Count mana symbols (excluding colorless/generic mana), multiplied by quantity
                  const matches = manaCost.match(/\{([^}]+)\}/g) || [];
                  matches.forEach(match => {
                    const symbol = match.replace(/[{}]/g, '');
                    
                    // Handle simple mana symbols
                    if (symbol === 'W') manaCounts.W += quantity;
                    else if (symbol === 'U') manaCounts.U += quantity;
                    else if (symbol === 'B') manaCounts.B += quantity;
                    else if (symbol === 'R') manaCounts.R += quantity;
                    else if (symbol === 'G') manaCounts.G += quantity;
                    
                    // Handle hybrid mana (e.g., "W/U", "2/W")
                    else if (symbol.includes('/')) {
                      const parts = symbol.split('/');
                      // For hybrid mana, count each color component
                      parts.forEach(part => {
                        if (part === 'W') manaCounts.W += quantity;
                        else if (part === 'U') manaCounts.U += quantity;
                        else if (part === 'B') manaCounts.B += quantity;
                        else if (part === 'R') manaCounts.R += quantity;
                        else if (part === 'G') manaCounts.G += quantity;
                        // Handle phyrexian mana (e.g., "W/P" -> count W)
                        // Handle colorless/generic hybrid (e.g., "2/W" -> count W)
                      });
                    }
                    
                    // Skip colorless/generic mana (numbers) and other symbols
                  });
                });

                const manaColors = [
                  { symbol: 'W', count: manaCounts.W },
                  { symbol: 'U', count: manaCounts.U },
                  { symbol: 'B', count: manaCounts.B },
                  { symbol: 'R', count: manaCounts.R },
                  { symbol: 'G', count: manaCounts.G },
                ];

                return manaColors
                  .filter(mana => mana.count > 0)
                  .map(mana => (
                    <div key={mana.symbol} style={{ 
                      display: "flex", 
                      flexDirection: "column", 
                      alignItems: "center", 
                      gap: "4px",
                      minWidth: "24px"
                    }}>
                      <img
                        src={`/svgs/${mana.symbol.toLowerCase()}.svg`}
                        alt={`{${mana.symbol}}`}
                        style={{
                          width: "20px",
                          height: "20px",
                          filter: "drop-shadow(0 1px 2px rgba(0,0,0,0.3))"
                        }}
                        title={`${mana.symbol} mana`}
                        onError={(e) => {
                          // Fallback to Scryfall if local SVG doesn't work
                          e.target.src = `https://svgs.scryfall.io/card-symbols/${mana.symbol}.svg`;
                        }}
                      />
                      <div style={{ 
                        fontSize: "12px", 
                        fontWeight: "bold", 
                        color: "#333" 
                      }}>
                        {mana.count}
                      </div>
                    </div>
                  ));
              })()}
            </div>
          </div>

          {/* CMC Distribution */}
          <div style={{ textAlign: "center", minWidth: "250px", flex: "1 1 250px" }}>
            <div style={{ fontSize: "14px", color: "#666" }}>
              Mana Curve
            </div>
            <div style={{ 
              display: "flex", 
              flexDirection: "column",
              alignItems: "center"
            }}>
              {/* Count numbers above bars */}
              <div style={{ 
                display: "flex", 
                gap: "4px", 
                justifyContent: "center", 
                height: "14px",
                alignItems: "flex-end"
              }}>
                {(() => {
                  const cmcCounts = {};
                  let maxCount = 0;
                  
                  (cards || deck?.cards || []).forEach(cardObj => {
                    const quantity = cardObj.count || cardObj.quantity || 1;
                    const cmc = cardObj?.scryfall_json?.cmc || 
                              cardObj?.card?.scryfall_json?.cmc || 
                              cardObj?.cmc || 
                              cardObj?.card?.cmc || 0;
                    const displayCmc = cmc >= 7 ? '7+' : cmc.toString();
                    cmcCounts[displayCmc] = (cmcCounts[displayCmc] || 0) + quantity;
                    maxCount = Math.max(maxCount, cmcCounts[displayCmc]);
                  });

                  const cmcLabels = ['1', '2', '3', '4', '5', '6', '7+'];
                  
                  return cmcLabels.map(cmc => {
                    const count = cmcCounts[cmc] || 0;
                    
                    return (
                      <div key={`count-${cmc}`} style={{ 
                        width: "24px",
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "flex-end",
                        height: "14px"
                      }}>
                        {count > 0 && (
                          <div style={{
                            fontSize: "10px",
                            fontWeight: "bold",
                            color: "#333"
                          }}>
                            {count}
                          </div>
                        )}
                      </div>
                    );
                  });
                })()}
              </div>
              
              {/* Bars */}
              <div style={{ 
                display: "flex", 
                gap: "4px", 
                justifyContent: "center", 
                alignItems: "end", 
                height: "45px"
              }}>
                {(() => {
                  const cmcCounts = {};
                  let maxCount = 0;
                  
                  (cards || deck?.cards || []).forEach(cardObj => {
                    const quantity = cardObj.count || cardObj.quantity || 1;
                    const cmc = cardObj?.scryfall_json?.cmc || 
                              cardObj?.card?.scryfall_json?.cmc || 
                              cardObj?.cmc || 
                              cardObj?.card?.cmc || 0;
                    const displayCmc = cmc >= 7 ? '7+' : cmc.toString();
                    cmcCounts[displayCmc] = (cmcCounts[displayCmc] || 0) + quantity;
                    maxCount = Math.max(maxCount, cmcCounts[displayCmc]);
                  });

                  const cmcLabels = ['1', '2', '3', '4', '5', '6', '7+'];
                  
                  return cmcLabels.map(cmc => {
                    const count = cmcCounts[cmc] || 0;
                    const height = maxCount > 0 ? Math.max(4, (count / maxCount) * 40) : 4;
                    
                    return (
                      <div
                        key={`bar-${cmc}`}
                        style={{
                          width: "24px",
                          height: `${height}px`,
                          backgroundColor: count > 0 ? "#4caf50" : "#e0e0e0",
                          borderRadius: "2px",
                          transition: "height 0.3s ease"
                        }}
                        title={`${count} cards with CMC ${cmc}`}
                      />
                    );
                  });
                })()}
              </div>
              
              {/* CMC labels at bottom */}
              <div style={{ 
                display: "flex", 
                gap: "4px", 
                justifyContent: "center"
              }}>
                {['1', '2', '3', '4', '5', '6', '7+'].map(cmc => (
                  <div key={`label-${cmc}`} style={{ 
                    width: "24px",
                    fontSize: "12px", 
                    color: "#666",
                    textAlign: "center"
                  }}>
                    {cmc}
                  </div>
                ))}
              </div>
            </div>
          </div>

          {/* Card Type Distribution */}
          <div style={{ textAlign: "center", minWidth: "200px", flex: "1 1 200px" }}>
            <div style={{ fontSize: "14px", color: "#666", marginBottom: "8px" }}>
              Card Types
            </div>
            <div style={{ display: "flex", gap: "8px", justifyContent: "center", alignItems: "center", flexWrap: "wrap" }}>
              {(() => {
                const typeCounts = {};
                
                (cards || deck?.cards || []).forEach(cardObj => {
                  const quantity = cardObj.count || cardObj.quantity || 1;
                  const typeLine = cardObj?.scryfall_json?.type_line || 
                                 cardObj?.card?.scryfall_json?.type_line || 
                                 cardObj?.type_line || 
                                 cardObj?.card?.type_line || '';
                  
                  // Extract primary card types, multiplied by quantity
                  const types = typeLine.toLowerCase();
                  if (types.includes('creature')) typeCounts['Creature'] = (typeCounts['Creature'] || 0) + quantity;
                  else if (types.includes('instant')) typeCounts['Instant'] = (typeCounts['Instant'] || 0) + quantity;
                  else if (types.includes('sorcery')) typeCounts['Sorcery'] = (typeCounts['Sorcery'] || 0) + quantity;
                  else if (types.includes('enchantment')) typeCounts['Enchantment'] = (typeCounts['Enchantment'] || 0) + quantity;
                  else if (types.includes('artifact')) typeCounts['Artifact'] = (typeCounts['Artifact'] || 0) + quantity;
                  else if (types.includes('planeswalker')) typeCounts['Planeswalker'] = (typeCounts['Planeswalker'] || 0) + quantity;
                  else if (types.includes('land')) typeCounts['Land'] = (typeCounts['Land'] || 0) + quantity;
                  else if (types.includes('battle')) typeCounts['Battle'] = (typeCounts['Battle'] || 0) + quantity;
                  else typeCounts['Other'] = (typeCounts['Other'] || 0) + quantity;
                });

                const typeColors = {
                  'Creature': '#8bc34a',
                  'Instant': '#2196f3',
                  'Sorcery': '#ff9800',
                  'Enchantment': '#9c27b0',
                  'Artifact': '#795548',
                  'Planeswalker': '#e91e63',
                  'Land': '#4caf50',
                  'Battle': '#f44336',
                  'Other': '#607d8b'
                };

                // Use your custom SVG icons from public/svgs folder
                const getTypeIcon = (type) => {
                  const svgMap = {
                    'Creature': 'creature.svg',
                    'Instant': 'instant.svg',
                    'Sorcery': 'sorcery.svg',
                    'Enchantment': 'enchantment.svg',
                    'Artifact': 'artifact.svg',
                    'Planeswalker': 'planeswalker.svg',
                    'Land': 'land.svg',
                    'Battle': 'artifact.svg', // Fallback to artifact since battle.svg doesn't exist
                    'Other': 'artifact.svg' // Fallback to artifact for other types
                  };
                  
                  const svgFile = svgMap[type] || 'artifact.svg';
                  
                  return (
                    <img
                      src={`/svgs/${svgFile}`}
                      alt={type}
                      style={{
                        width: "20px",
                        height: "20px",
                        filter: "brightness(0)", // Make SVGs black
                        opacity: 0.8
                      }}
                      title={`${type} symbol`}
                    />
                  );
                };

                return Object.entries(typeCounts)
                  .filter(([type, count]) => count > 0)
                  .sort(([,a], [,b]) => b - a) // Sort by count descending
                  .map(([type, count]) => (
                    <div key={type} style={{ 
                      display: "flex", 
                      flexDirection: "column", 
                      alignItems: "center", 
                      gap: "4px",
                      minWidth: "32px"
                    }}>
                      {getTypeIcon(type)}
                      <div style={{ 
                        fontSize: "12px", 
                        fontWeight: "bold", 
                        color: "#333" 
                      }}>
                        {count}
                      </div>
                    </div>
                  ));
              })()}
            </div>
          </div>
        </div>
      </div>

      {/* Main layout with sidebar and content */}
      <div className="deck-container">
        <div className="deck-layout" style={{ alignItems: "flex-start" }}>
          {/* Sidebar with search, card preview and display options */}
          <div
            className="deck-sidebar"
          >
            {/* Card preview positioned above search bar - hide when search modal is open */}
            {!showSearchModal && (
              <CardPreview
                preview={fixedPreview}
                showPreview={true}
                isFixed={true}
                style={{
                  height: "auto",
                  maxHeight: "400px", // Prevent preview from getting too large
                  maxWidth: "100%", // Ensure it fits within sidebar
                  borderRadius: "4.75%",
                  background: "white",
                  marginBottom: "0", // No margin to connect to search bar below
                  padding: 0,
                  boxShadow: "0 2px 8px rgba(0,0,0,0.04)",
                  objectFit: "contain", // Maintain aspect ratio
                }}
              />
            )}

            {/* Search bar */}
            <div
              className="search-container"
              style={{
                position: "relative",
                display: "flex",
                justifyContent: "center",
                marginBottom: "0", /* Remove gap - card preview will attach directly */
              }}
            >
              <input
                type="text"
                placeholder="Search for cards to add (Scryfall syntax supported, including otag:)..."
                value={search}
                onChange={(e) => {
                  console.log('🔍 Search input changed:', {
                    newValue: e.target.value,
                    oldValue: search,
                    timestamp: new Date().toISOString()
                  });
                  setSearch(e.target.value);
                  debouncedSearch(e.target.value);
                }}
                onBlur={(e) => {
                  // Capture references before setTimeout to avoid stale references
                  const searchInput = e.currentTarget;
                  const searchContainer = searchInput.closest('.search-container');
                  
                  // Clear search when clicking outside the search input
                  // Use setTimeout to allow dropdown clicks to register first
                  setTimeout(() => {
                    const activeElement = document.activeElement;
                    const dropdown = searchContainer?.querySelector('[style*="position: absolute"]');
                    
                    // Check if focus moved to the dropdown or its children
                    const focusedOnDropdown = dropdown && dropdown.contains(activeElement);
                    const focusedOnInput = activeElement === searchInput;
                    
                    // Only clear if focus is not on the input or dropdown
                    if (!focusedOnInput && !focusedOnDropdown) {
                      setSearch("");
                      setSearchResults([]);
                      setNoResultsMsg("");
                      setShowDropdown(false);
                      setSelectedSearchIndex(-1);
                    }
                  }, 150); // Small delay to allow other events to process
                }}
                onKeyDown={(e) => {
                  // Helper function to create preview card with printing priority logic
                  const createPreviewCard = (card) => {
                    // 🎯 PREVIEW-MODAL SYNC FIX: Apply same printing priority logic as modal
                    const cardName = card.name;
                    let finalPrintingId = card.scryfall_id || card.id;
                    let finalSet = card.set || card.set_name;
                    let finalImageUris = card.image_uris;
                    
                    // Apply same printing priority logic as modal opening (lines 6106-6120)
                    try {
                      // 1. Check user preferences first (highest priority)
                      const userPreference = PrintingPreferences.get(cardName);
                      if (userPreference && userPreference.id) {
                        finalPrintingId = userPreference.id;
                        finalSet = userPreference.set;
                        // Use Scryfall API for correct printing image
                        finalImageUris = {
                          normal: `https://api.scryfall.com/cards/${userPreference.id}?format=image&version=normal`,
                          small: `https://api.scryfall.com/cards/${userPreference.id}?format=image&version=small`
                        };
                        console.log(`🎯 [KEYBOARD PREVIEW] Using user preference for ${cardName}: ${userPreference.set?.toUpperCase()} #${userPreference.collector_number}`);
                      }
                      
                      // 2. Check printing cache
                      else {
                        const cachedData = PrintingCache.get(cardName);
                        if (cachedData && cachedData.selectedPrinting) {
                          finalPrintingId = cachedData.selectedPrinting.id;
                          finalSet = cachedData.selectedPrinting.set;
                          finalImageUris = cachedData.selectedPrinting.image_uris || finalImageUris;
                          console.log(`💾 [KEYBOARD PREVIEW] Using cached printing for ${cardName}: ${cachedData.selectedPrinting.set?.toUpperCase()}`);
                        }
                        
                        // 3. Check basic land preferences (using same logic as modal)
                        else if (BASIC_LAND_PRINTINGS[cardName]) {
                          finalPrintingId = BASIC_LAND_PRINTINGS[cardName];
                          // Use Scryfall API for basic land image
                          finalImageUris = {
                            normal: `https://api.scryfall.com/cards/${finalPrintingId}?format=image&version=normal`,
                            small: `https://api.scryfall.com/cards/${finalPrintingId}?format=image&version=small`
                          };
                          console.log(`🏔️  [KEYBOARD PREVIEW] Using basic land preference for ${cardName}: ${finalPrintingId}`);
                        }
                      }
                    } catch (error) {
                      console.warn(`[KEYBOARD PREVIEW] Error checking preferences for ${cardName}:`, error);
                      // Fall back to search result data
                    }
                    
                    return {
                      name: cardName,
                      card: {
                        name: cardName,
                        // Include essential data for preview
                        ...(finalImageUris && { image_uris: finalImageUris }),
                        ...(card.scryfall_json && { scryfall_json: card.scryfall_json }),
                        ...(card.mana_cost && { mana_cost: card.mana_cost }),
                        ...(card.type_line && { type_line: card.type_line }),
                        ...(card.oracle_text && { oracle_text: card.oracle_text }),
                        ...(card.power && { power: card.power }),
                        ...(card.toughness && { toughness: card.toughness }),
                        ...(card.loyalty && { loyalty: card.loyalty }),
                      },
                      forceEnglish: true,
                      forceHighRes: true,
                      // CRITICAL: Use the resolved printing information to match modal
                      printing: finalPrintingId,
                      set: finalSet,
                      collector_number: card.collector_number || null,
                      // Include scryfall_id for proper identification
                      scryfall_id: finalPrintingId,
                    };
                  };
                  
                  // Handle keyboard navigation for search dropdown
                  if (showDropdown && (searchResults.length > 0 || noResultsMsg)) {
                    const totalItems = searchResults.length + (searchResults.length > 0 ? 1 : 0); // +1 for "Show all results" button
                    
                    if (e.key === "ArrowDown") {
                      e.preventDefault();
                      setSelectedSearchIndex(prev => {
                        const newIndex = prev < totalItems - 1 ? prev + 1 : 0;
                        // Show preview for the selected card (but not for "Show all results" button)
                        if (newIndex < searchResults.length && searchResults[newIndex]) {
                          const card = searchResults[newIndex];
                          const cleanSearchCard = createPreviewCard(card);
                          handleCardHover(cleanSearchCard);
                        }
                        return newIndex;
                      });
                      return;
                    }
                    
                    if (e.key === "ArrowUp") {
                      e.preventDefault();
                      setSelectedSearchIndex(prev => {
                        const newIndex = prev > 0 ? prev - 1 : totalItems - 1;
                        // Show preview for the selected card (but not for "Show all results" button)
                        if (newIndex < searchResults.length && searchResults[newIndex]) {
                          const card = searchResults[newIndex];
                          const cleanSearchCard = createPreviewCard(card);
                          handleCardHover(cleanSearchCard);
                        }
                        return newIndex;
                      });
                      return;
                    }
                    
                    if (e.key === "Enter") {
                      e.preventDefault();
                      if (selectedSearchIndex >= 0 && selectedSearchIndex < searchResults.length) {
                        // Add the selected card
                        const selectedCard = searchResults[selectedSearchIndex];
                        handleAddCard(selectedCard);
                        setSearch("");
                        setShowDropdown(false);
                        setSelectedSearchIndex(-1);
                        return;
                      } else if (selectedSearchIndex === searchResults.length && searchResults.length > 0) {
                        // "Show all results" button selected
                        fetchAllSearchResults(search.trim());
                        setSelectedSearchIndex(-1);
                        return;
                      }
                    }
                  }
                  
                  // Handle Enter key press when no item is selected - open modal
                  if (e.key === "Enter" && search.trim()) {
                    // Open search results modal
                    fetchAllSearchResults(search.trim());
                    e.preventDefault();
                  }
                  
                  // Handle Escape key to close dropdown and clear search
                  if (e.key === "Escape") {
                    if (showDropdown) {
                      setShowDropdown(false);
                      setSelectedSearchIndex(-1);
                    }
                    // Clear the search field
                    setSearch("");
                    setSearchResults([]);
                    setNoResultsMsg("");
                    e.preventDefault();
                  }
                }}
                style={{
                  backgroundColor: "#f9f9f9",
                  boxShadow: "0 2px 8px rgba(0,0,0,0.02)",
                  borderRadius: 4,
                  marginBottom: "8px",
                  padding: "6px 8px",
                  border: "1px solid #ccc",
                  width: "242px", // Match the width to the sidebar width
                  fontSize: "12px", // Match the dropdown font size
                  color: "#333",
                  outline: "none",
                  transition: "border-color 0.15s",
                }}
              />

              {/* Search dropdown */}
              {showDropdown && search.trim() && (
                <div
                  style={{
                    position: "absolute",
                    top: "100%",
                    left: "50%",
                    transform: "translateX(-50%)",
                    width: "242px",
                    backgroundColor: "#f9f9f9",
                    border: "1px solid #ccc",
                    borderRadius: "4px",
                    marginTop: "2px",
                    maxHeight: "300px",
                    overflowY: "auto",
                    zIndex: 1000,
                    boxShadow: "0 2px 8px rgba(0,0,0,0.15)",
                  }}
                  onMouseLeave={() => {
                    // Reset selection when mouse leaves the entire dropdown
                    debouncedResetSelection();
                  }}
                >
                  {searchLoading ? (
                    <div
                      style={{
                        padding: "6px 8px",
                        textAlign: "center",
                        color: "#666",
                        fontSize: "12px",
                      }}
                    >
                      Searching...
                    </div>
                  ) : searchResults.length > 0 ? (
                    // Debug: log dropdown rendering state
                    console.log('🔍 Dropdown rendering with:', {
                      searchResults: searchResults.length,
                      search: search,
                      showDropdown: showDropdown,
                      timestamp: new Date().toISOString()
                    }) || searchResults.map((card, index) => {
                      const isSelected = index === selectedSearchIndex;
                      const isHovered = isSelected; // Consider keyboard-selected items as "hovered" for styling
                      
                      return (
                        <div
                          key={`${card.scryfall_id || card.id}-${index}`}
                          style={{
                            padding: "6px 8px",
                            cursor: "pointer",
                            transition: "background-color 0.15s ease",
                            borderBottom:
                              index < searchResults.length - 1
                                ? "1px solid #eee"
                                : "none",
                            backgroundColor: isSelected ? "#e3f2fd" : "transparent",
                          }}
                          onMouseEnter={(e) => {
                            // Cancel any pending debounced reset
                            debouncedResetSelection.cancel();
                            // Update keyboard selection to match mouse hover
                            setSelectedSearchIndex(index);
                            
                            // 🎯 PREVIEW-MODAL SYNC FIX: Apply same printing priority logic as modal
                            const cardName = card.name;
                            let finalPrintingId = card.scryfall_id || card.id;
                            let finalSet = card.set || card.set_name;
                            let finalImageUris = card.image_uris;
                            
                            // Apply same printing priority logic as modal opening (lines 6106-6120)
                            try {
                              // 1. Check user preferences first (highest priority)
                              const userPreference = PrintingPreferences.get(cardName);
                              if (userPreference && userPreference.id) {
                                finalPrintingId = userPreference.id;
                                finalSet = userPreference.set;
                                // Use Scryfall API for correct printing image
                                finalImageUris = {
                                  normal: `https://api.scryfall.com/cards/${userPreference.id}?format=image&version=normal`,
                                  small: `https://api.scryfall.com/cards/${userPreference.id}?format=image&version=small`
                                };
                                console.log(`🎯 [SEARCH PREVIEW] Using user preference for ${cardName}: ${userPreference.set?.toUpperCase()} #${userPreference.collector_number}`);
                              }
                              
                              // 2. Check printing cache
                              else {
                                const cachedData = PrintingCache.get(cardName);
                                if (cachedData && cachedData.selectedPrinting) {
                                  finalPrintingId = cachedData.selectedPrinting.id;
                                  finalSet = cachedData.selectedPrinting.set;
                                  finalImageUris = cachedData.selectedPrinting.image_uris || finalImageUris;
                                  console.log(`💾 [SEARCH PREVIEW] Using cached printing for ${cardName}: ${cachedData.selectedPrinting.set?.toUpperCase()}`);
                                }
                                
                                // 3. Check basic land preferences (using same logic as modal)
                                else if (BASIC_LAND_PRINTINGS[cardName]) {
                                  finalPrintingId = BASIC_LAND_PRINTINGS[cardName];
                                  // Use Scryfall API for basic land image
                                  finalImageUris = {
                                    normal: `https://api.scryfall.com/cards/${finalPrintingId}?format=image&version=normal`,
                                    small: `https://api.scryfall.com/cards/${finalPrintingId}?format=image&version=small`
                                  };
                                  console.log(`🏔️  [SEARCH PREVIEW] Using basic land preference for ${cardName}: ${finalPrintingId}`);
                                }
                              }
                            } catch (error) {
                              console.warn(`[SEARCH PREVIEW] Error checking preferences for ${cardName}:`, error);
                              // Fall back to search result data
                            }
                            
                            // Show the card in the fixed preview with correct printing
                            // Create a clean card object for search results to avoid data pollution
                            const cleanSearchCard = {
                              name: cardName,
                              card: {
                                name: cardName,
                                // Only include essential data for preview
                                ...(finalImageUris && {
                                  image_uris: finalImageUris,
                                }),
                                ...(card.scryfall_json && {
                                  scryfall_json: card.scryfall_json,
                                }),
                                ...(card.mana_cost && {
                                  mana_cost: card.mana_cost,
                                }),
                                ...(card.type_line && {
                                  type_line: card.type_line,
                                }),
                                ...(card.oracle_text && {
                                  oracle_text: card.oracle_text,
                                }),
                                ...(card.power && { power: card.power }),
                                ...(card.toughness && {
                                  toughness: card.toughness,
                                }),
                                ...(card.loyalty && { loyalty: card.loyalty }),
                              },
                              // Force English lookup for search results
                              forceEnglish: true,
                              forceHighRes: true,
                              // CRITICAL: Use the resolved printing information to match modal
                              printing: finalPrintingId,
                              set: finalSet,
                              collector_number: card.collector_number || null,
                              // Include scryfall_id for proper identification
                              scryfall_id: finalPrintingId,
                            };
                            handleCardHover(cleanSearchCard);
                          }}
                          onMouseLeave={() => {
                            // Use debounced reset to handle fast mouse movements
                            debouncedResetSelection();
                            // Optional: Could clear the preview here, but usually better to leave the last viewed card
                            // handleCardHover(null);
                          }}
                          onClick={(event) => {
                            // Enhanced stabilization fix for intermittent click issues
                            event.preventDefault();
                            event.stopPropagation();
                            
                            // Ensure DOM stability before processing
                            const target = event.currentTarget;
                            target.getBoundingClientRect();
                            
                            // Double-check that we still have valid card data
                            if (!card || !card.name) {
                              console.warn('🚨 Invalid card data, skipping click');
                              return;
                            }
                            
                            console.log('🚨 SEARCH CLICK FIRED! Card clicked:', card.name);
                            console.log('🔍 Full card object:', card);
                            
                            // Use multiple strategies to ensure the click is processed
                            const processClick = () => {
                              // Use the same printing resolution logic as the search preview to ensure consistency
                              const cardName = card.name;
                              let finalPrintingId = card.scryfall_id || card.id;
                              let finalSet = card.set;
                              
                              try {
                                // 1. Check user preferences first (same as preview and modal)
                                const userPreference = PrintingPreferences.get(cardName);
                                if (userPreference && userPreference.id) {
                                  finalPrintingId = userPreference.id;
                                  finalSet = userPreference.set;
                                  console.log(`🎯 [SEARCH CLICK] Using user preference for ${cardName}: ${finalSet?.toUpperCase()} #${userPreference.collector_number}`);
                                }
                                // 2. Check printing cache second (same as preview and modal)
                                else {
                                  const cachedData = PrintingCache.get(cardName);
                                  if (cachedData && cachedData.selectedPrinting) {
                                    finalPrintingId = cachedData.selectedPrinting.id;
                                    finalSet = cachedData.selectedPrinting.set;
                                    console.log(`💾 [SEARCH CLICK] Using cached printing for ${cardName}: ${finalSet?.toUpperCase()} #${cachedData.selectedPrinting.collector_number}`);
                                  }
                                  // 3. Check basic land preferences (same as preview and modal)
                                  else if (BASIC_LAND_PRINTINGS[cardName]) {
                                    finalPrintingId = BASIC_LAND_PRINTINGS[cardName];
                                    console.log(`🏔️ [SEARCH CLICK] Using basic land preference for ${cardName}: ${finalPrintingId}`);
                                  }
                                  // 4. Use search result data as fallback
                                  else {
                                    console.log(`📋 [SEARCH CLICK] Using search result data for ${cardName}: ${finalSet?.toUpperCase()} #${card.collector_number}`);
                                  }
                                }
                              } catch (error) {
                                console.warn(`[SEARCH CLICK] Error checking preferences for ${cardName}:`, error);
                                // Fall back to original card data
                              }
                              
                              // Create a consistent card object with the resolved printing
                              const consistentCard = {
                                ...card,
                                scryfall_id: finalPrintingId,
                                id: finalPrintingId,
                                set: finalSet,
                                // Preserve collector_number if it exists in cached data
                                ...(finalSet === card.set && { collector_number: card.collector_number })
                              };
                              
                              console.log(`🎯 [SEARCH CLICK] Final card data for ${cardName}:`, {
                                originalId: card.scryfall_id || card.id,
                                resolvedId: finalPrintingId,
                                originalSet: card.set,
                                resolvedSet: finalSet,
                                match: (card.scryfall_id || card.id) === finalPrintingId
                              });
                              
                              console.log('[SEARCH DEBUG] Clicked card:', consistentCard);
                              handleAddCard(consistentCard);
                              setSearch("");
                              setShowDropdown(false);
                              setSelectedSearchIndex(-1);
                            };
                            
                            // Try immediate execution, fall back to requestAnimationFrame if needed
                            try {
                              processClick();
                            } catch (error) {
                              console.warn('Immediate click processing failed, using fallback:', error);
                              requestAnimationFrame(() => {
                                try {
                                  processClick();
                                } catch (fallbackError) {
                                  console.error('Click processing completely failed:', fallbackError);
                                }
                              });
                            }
                          }}
                        >
                          <div style={{ 
                            fontWeight: isSelected ? "600" : "500", 
                            fontSize: "12px",
                            color: isSelected ? "#1976d2" : "#333"
                          }}>
                            {card.name}
                          </div>
                        </div>
                      );
                    })
                  ) : noResultsMsg ? (
                    <div
                      style={{
                        padding: "6px 8px",
                        textAlign: "center",
                        color: "#666",
                        fontSize: "12px",
                      }}
                    >
                      {noResultsMsg}
                    </div>
                  ) : null}

                  {/* Show all... button - only show if we have a search query and some results */}
                  {search.trim() && searchResults.length > 0 && (
                    <div
                      style={{
                        padding: "6px 8px",
                        textAlign: "center",
                        color: selectedSearchIndex === searchResults.length ? "#ffffff" : "#1976d2",
                        fontSize: "12px",
                        fontWeight: "bold",
                        backgroundColor: selectedSearchIndex === searchResults.length ? "#007acc" : "#f0f7ff",
                        borderTop: "1px solid #ddd",
                        cursor: "pointer",
                        transition: "all 0.2s ease",
                      }}
                      onMouseEnter={() => {
                        // Cancel any pending debounced reset
                        debouncedResetSelection.cancel();
                        setSelectedSearchIndex(searchResults.length);
                      }}
                      onMouseLeave={() => {
                        // Use the same debounced reset as other elements
                        debouncedResetSelection();
                      }}
                      onClick={() => {
                        console.log('🔍 "Show all results..." button clicked', {
                          searchValue: search,
                          trimmedValue: search.trim(),
                          timestamp: new Date().toISOString()
                        });
                        // Open search results modal
                        fetchAllSearchResults(search.trim());
                        setSelectedSearchIndex(-1);
                      }}
                    >
                      Show all results...
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Bulk Edit Toggle Button */}
            <div
              style={{
                background: "white",
                padding: "8px 0",
                display: "flex",
                justifyContent: "center",
                marginBottom: "8px",
              }}
            >
              <button
                onClick={() => {
                  setBulkEditMode(!bulkEditMode);
                  setSelectedCards(new Set()); // Clear selections when toggling
                }}
                className={`bulk-edit-button ${bulkEditMode ? 'active' : ''}`}
              >
                {bulkEditMode ? "Exit Bulk Edit" : "Bulk Edit"}
              </button>
            </div>

            {/* Bulk Edit Action Buttons */}
            {bulkEditMode && (
              <div className="bulk-actions-container">
                <div className="bulk-actions-counter">
                  {selectedCards.size} card{selectedCards.size !== 1 ? 's' : ''} selected
                </div>
                
                <div className="bulk-select-all-container">
                  <button
                    onClick={() => {
                      if (selectedCards.size === 0) {
                        // Select all cards
                        const allCardIds = new Set();
                        const allCards = cards && cards.length > 0 ? cards : deck?.cards || [];
                        allCards.forEach(card => {
                          allCardIds.add(generateCardSelectionId(card));
                        });
                        setSelectedCards(allCardIds);
                      } else {
                        // Clear all selections
                        setSelectedCards(new Set());
                      }
                    }}
                    className="bulk-select-all-text"
                    style={{
                      padding: '2px 6px',
                      fontSize: '10px',
                      backgroundColor: '#1976d2',
                      color: '#fff',
                      border: '1px solid #1565c0',
                      borderRadius: '3px',
                      cursor: 'pointer',
                    }}
                  >
                    {selectedCards.size === 0 ? 'Select All' : 'Clear All'}
                  </button>
                </div>
                <div className="bulk-actions-grid">
                  <button
                    onClick={() => handleBulkAddToCollection()}
                    disabled={selectedCards.size === 0}
                    className="bulk-action-button collection"
                  >
                    + Collection
                  </button>
                  <button
                    onClick={() => handleBulkAddToWishlist()}
                    disabled={selectedCards.size === 0}
                    className="bulk-action-button wishlist"
                  >
                    + Wishlist
                  </button>
                  <button
                    onClick={() => handleBulkMoveToSideboard()}
                    disabled={selectedCards.size === 0}
                    className="bulk-action-button sideboard"
                  >
                    → Sideboard
                  </button>
                  <button
                    onClick={() => handleBulkMoveToTechIdeas()}
                    disabled={selectedCards.size === 0}
                    className="bulk-action-button tech-ideas"
                  >
                    → Tech Ideas
                  </button>
                  <button
                    onClick={() => handleBulkRemoveFromDeck()}
                    disabled={selectedCards.size === 0}
                    className="bulk-action-button remove"
                  >
                    Remove from Deck
                  </button>
                  <button
                    onClick={() => handleBulkToggleFoil()}
                    disabled={selectedCards.size === 0}
                    className="bulk-action-button foil"
                  >
                    Toggle Foil
                  </button>
                </div>
              </div>
            )}

            {/* Display options - now part of the sticky sidebar */}
            <div
              style={{
                background: "white",
                boxShadow: "0 2px 8px rgba(0,0,0,0.02)",
                borderRadius: 8,
                marginBottom: 8,
              }}
            >
              <CardGroupSortOptions
                groupBy={groupBy}
                setGroupBy={setGroupBy}
                sortBy={sortBy}
                setSortBy={setSortBy}
                hidePrices={hidePrices}
                setHidePrices={setHidePrices}
                showMana={showMana}
                setShowMana={setShowMana}
                viewMode={viewMode}
                setViewMode={setViewMode}
              />
            </div>
          </div>

          {/* Main content area with card type sections */}
          <div className="deck-main-content">
            {/* Mobile view controls - only visible when sidebar is hidden */}
            <div 
              className="mobile-view-controls"
              style={{
                display: 'none',
                marginBottom: '1rem',
                padding: '12px',
                backgroundColor: 'white',
                borderRadius: '8px',
                boxShadow: '0 2px 8px rgba(0,0,0,0.04)',
              }}
            >
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' }}>
                <span style={{ fontSize: '14px', fontWeight: '500', color: '#666' }}>View:</span>
                <div style={{ display: 'flex', gap: '4px' }}>
                  <button
                    onClick={() => setViewMode('list')}
                    style={{
                      padding: '6px 12px',
                      border: '1px solid #ddd',
                      borderRadius: '4px',
                      backgroundColor: viewMode === 'list' ? '#1976d2' : 'white',
                      color: viewMode === 'list' ? 'white' : '#333',
                      fontSize: '12px',
                      cursor: 'pointer',
                      transition: 'all 0.2s ease',
                    }}
                  >
                    📋 List
                  </button>
                  <button
                    onClick={() => setViewMode('grid')}
                    style={{
                      padding: '6px 12px',
                      border: '1px solid #ddd',
                      borderRadius: '4px',
                      backgroundColor: viewMode === 'grid' ? '#1976d2' : 'white',
                      color: viewMode === 'grid' ? 'white' : '#333',
                      fontSize: '12px',
                      cursor: 'pointer',
                      transition: 'all 0.2s ease',
                    }}
                  >
                    🔳 Grid
                  </button>
                </div>
              </div>
            </div>
            
            {/* Mana symbol summary will be added here in next step */}
            {/* Card grid with grouped card sections */}
            <div
              className={`card-type-grid ${viewMode === 'grid' ? 'grid-view-mode' : ''}`}
              key={`deck-grid-${cards?.length}-${deck?.cards?.length}-${JSON.stringify(cards.map((c) => c.count || c.quantity || 1))}`}
            >
              {groupedAndSortedCards.map((group) => (
                <div key={group.type} className="card-type-container">
                  <CardTypeHeader
                    type={group.type}
                    count={group.cards.reduce((total, cardObj) => {
                      const quantity = cardObj.count || cardObj.quantity || 1;
                      return total + quantity;
                    }, 0)}
                  />
                  {/* Conditional container based on view mode */}
                  <div style={viewMode === 'grid' ? {
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(150px, 1fr))',
                    gap: '8px',
                    paddingTop: '8px',
                    paddingBottom: '8px',
                    width: '100%',
                    boxSizing: 'border-box',
                    justifyItems: 'center' // Center cards in their grid cells
                  } : {}}>
                    {group.cards.map((cardObj, index) => {
                    // If groupCards() was used, group.cards is an array of { name, count, printing, cardObj }
                    // If not, fallback to cardObj structure
                    // console.log(`[DeckViewEdit] Rendering card: ${cardObj.card?.name || cardObj.name}, count:`, cardObj.count, "quantity:", cardObj.quantity, "foil:", cardObj.foil);
                    const cardData = cardObj.cardObj
                      ? cardObj
                      : {
                          name: cardObj.card?.name || cardObj.name,
                          count: cardObj.count || cardObj.quantity || 1, // Try both count and quantity
                          printing: cardObj.printing,
                          cardObj,
                        };
                    // Make sure the cardObj has the correct foil status from all possible locations before extractPrice
                    // CRITICAL FIX: Use single, comprehensive foil status check for both display and pricing
                    const isExplicitlyFoil =
                      cardData.foil === true ||
                      cardObj.foil === true ||
                      cardData.cardObj?.foil === true ||
                      cardData.cardObj?.card?.foil === true ||
                      cardObj.card?.foil === true ||
                      cardData.cardObj?.cardObj?.foil === true ||
                      cardData.cardObj?.cardObj?.card?.foil === true;

                    // Create a complete card object with consistent foil status at all levels
                    // IMPORTANT: Use the original card object, not any modified versions
                    const originalCardObj = cardData.cardObj || cardObj;
                    const cardObjWithFoilStatus = JSON.parse(
                      JSON.stringify(originalCardObj),
                    );

                    // CRITICAL FIX: Set the foil status at all levels using the SAME logic for consistency
                    cardObjWithFoilStatus.foil = isExplicitlyFoil;
                    if (cardObjWithFoilStatus.card) {
                      cardObjWithFoilStatus.card.foil = isExplicitlyFoil;
                    }
                    if (cardObjWithFoilStatus.cardObj) {
                      cardObjWithFoilStatus.cardObj.foil = isExplicitlyFoil;
                      if (cardObjWithFoilStatus.cardObj.card) {
                        cardObjWithFoilStatus.cardObj.card.foil = isExplicitlyFoil;
                      }
                    }

                    // Set foil status at all levels
                    cardObjWithFoilStatus.foil = isExplicitlyFoil;
                    if (cardObjWithFoilStatus.card) {
                      cardObjWithFoilStatus.card.foil = isExplicitlyFoil;
                    }
                    if (cardObjWithFoilStatus.cardObj) {
                      cardObjWithFoilStatus.cardObj.foil = isExplicitlyFoil;
                      if (cardObjWithFoilStatus.cardObj.card) {
                        cardObjWithFoilStatus.cardObj.card.foil =
                          isExplicitlyFoil;
                      }
                    }

                    // CRITICAL: For basic lands, use preferred printing for consistent pricing with modal
                    // For other cards, preserve original printing information to prevent hover from affecting pricing
                    const isBasicLand = BASIC_LAND_PRINTINGS[cardData.name];
                    if (isBasicLand) {
                      // Use preferred printing for basic lands to match modal pricing
                      const preferredPrintingId = BASIC_LAND_PRINTINGS[cardData.name];
                      cardObjWithFoilStatus.printing = preferredPrintingId;
                      if (cardObjWithFoilStatus.card) {
                        cardObjWithFoilStatus.card.printing = preferredPrintingId;
                      }
                    } else {
                      // For non-basic lands, preserve original printing
                      if (cardData.printing && !cardObjWithFoilStatus.printing) {
                        cardObjWithFoilStatus.printing = cardData.printing;
                      }
                      if (cardData.printing && cardObjWithFoilStatus.card && !cardObjWithFoilStatus.card.printing) {
                        cardObjWithFoilStatus.card.printing = cardData.printing;
                      }
                    }

                    // Always recalculate price at render time to ensure we have the most up-to-date price based on foil status
                    const { price, isFoil, source } = extractPrice(
                      cardObjWithFoilStatus,
                    );
                    // console.log(`[DeckViewEdit] Card price for ${cardData.name}: $${price} (foil: ${isFoil}, source: ${source})`);

                    return viewMode === 'grid' ? (
                      <GridCard
                        key={`${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                        cardData={cardData}
                        isExplicitlyFoil={isExplicitlyFoil}
                        price={price}
                        onMouseEnter={() => {
                          // For basic lands, use preferred printing to match modal
                          const isBasicLand = BASIC_LAND_PRINTINGS[cardData.name];
                          let preferredPrinting = cardData.printing || cardData.cardObj?.printing;
                          
                          if (isBasicLand) {
                            preferredPrinting = BASIC_LAND_PRINTINGS[cardData.name];
                          }

                          // Create enhanced card object with foil AND printing information
                          const cardWithFoil = {
                            ...cardData.cardObj,
                            foil: isExplicitlyFoil,
                            isFoil: isExplicitlyFoil,
                            name: cardData.name,
                            // CRITICAL: Use preferred printing for basic lands to match modal
                            printing: preferredPrinting,
                          };
                          handleCardHover(cardWithFoil);
                        }}
                        onClick={() => {
                          // Create a deeply cloned object to avoid reference issues
                          const baseObj = JSON.parse(
                            JSON.stringify(cardData.cardObj || {}),
                          );

                          // For basic lands, use preferred printing to match preview
                          const isBasicLand = BASIC_LAND_PRINTINGS[cardData.name];
                          let preferredPrinting = cardData.printing || baseObj.printing;
                          
                          // 🎯 CHECK USER PREFERENCE FIRST - even for basic lands
                          const userPreference = PrintingPreferences.get(cardData.name);
                          if (userPreference && userPreference.id) {
                            preferredPrinting = userPreference.id;
                            console.log(`[DeckViewEdit] 🎯 Using user preference for modal: ${cardData.name} → ${userPreference.set?.toUpperCase()} #${userPreference.collector_number}`);
                          } 
                          // 🎯 CHECK PRINTING CACHE SECOND - to match search preview logic
                          else {
                            const cachedData = PrintingCache.get(cardData.name);
                            if (cachedData && cachedData.selectedPrinting) {
                              preferredPrinting = cachedData.selectedPrinting.id;
                              console.log(`[DeckViewEdit] 💾 Using cached printing for modal: ${cardData.name} → ${cachedData.selectedPrinting.set?.toUpperCase()}`);
                            } else if (isBasicLand) {
                              preferredPrinting = BASIC_LAND_PRINTINGS[cardData.name];
                              console.log(`[DeckViewEdit] Using basic land default for modal: ${cardData.name} (no user preference or cache)`);
                            } else {
                              console.log(`[DeckViewEdit] Using fallback printing for modal: ${cardData.name} → ${preferredPrinting}`);
                            }
                          }

                          // Ensure we always have critical properties at the top level
                          // Use the actual foil property, not the extractPrice interpretation
                          const enrichedCardObj = {
                            ...baseObj,
                            name: cardData.name, // Ensure name is available at top level
                            foil: isExplicitlyFoil, // Use the actual foil property, not extractPrice interpretation
                            count: cardData.count || 1, // Ensure count is at top level
                            price: price || null, // Include the calculated price
                            // CRITICAL: Use preferred printing for basic lands to match preview
                            printing: preferredPrinting,
                          
                            // Debug: Log card data being passed to modal
                            _debug_cardData: {
                              printing: cardData.printing,
                              name: cardData.name,
                              baseObjPrinting: baseObj.printing,
                              preferredPrinting: preferredPrinting,
                              isBasicLand: !!isBasicLand,
                              cardObjCard: baseObj.card,
                              cardObjCardPrinting: baseObj.card?.printing,
                              cardObjCardScryfallId: baseObj.card?.scryfall_json?.id
                            }
                          };

                          // Ensure foil status and printing are consistent at all levels of the object
                          if (enrichedCardObj.card) {
                            enrichedCardObj.card.foil = isExplicitlyFoil;
                            // CRITICAL FIX: Update printing in nested card object for ALL cards, not just basic lands
                            // The modal relies on card.printing to determine which printing to display
                            enrichedCardObj.card.printing = preferredPrinting;
                          }

                          setModalState({
                            isOpen: true,
                            cardObj: enrichedCardObj,
                          });
                        }}
                        onContextMenu={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          
                          // Create enhanced card object for context menu
                          const cardWithFoil = {
                            ...cardData.cardObj,
                            foil: isExplicitlyFoil,
                            isFoil: isExplicitlyFoil,
                            name: cardData.name,
                            printing: cardData.printing || cardData.cardObj?.printing,
                            count: cardData.count || 1,
                            price: price || null,
                          };
                          
                          setContextMenu({
                            open: true,
                            x: e.clientX,
                            y: e.clientY,
                            cardObj: cardWithFoil,
                          });
                        }}
                        bulkEditMode={bulkEditMode}
                        isSelected={selectedCards.has(generateCardSelectionId(cardData))}
                        onToggleSelection={() => toggleCardSelection(cardData)}
                      />
                    ) : (
                      <DeckCardRow
                        key={`${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                        cardData={cardData}
                        isFoil={isFoil}
                        price={price}
                        index={index}
                        onMouseEnter={() => {
                          // Use the same printing resolution logic as search preview and modal for consistency
                          const cardName = cardData.name;
                          let preferredPrinting = cardData.printing || cardData.cardObj?.printing;
                          
                          try {
                            // 1. Check user preferences first (same as search preview and modal)
                            const userPreference = PrintingPreferences.get(cardName);
                            if (userPreference && userPreference.id) {
                              preferredPrinting = userPreference.id;
                              // console.log(`🎯 [DECK HOVER] Using user preference for ${cardName}: ${userPreference.set?.toUpperCase()} #${userPreference.collector_number}`);
                            }
                            // 2. Check printing cache second (same as search preview and modal)
                            else {
                              const cachedData = PrintingCache.get(cardName);
                              if (cachedData && cachedData.selectedPrinting) {
                                preferredPrinting = cachedData.selectedPrinting.id;
                                // console.log(`💾 [DECK HOVER] Using cached printing for ${cardName}: ${cachedData.selectedPrinting.set?.toUpperCase()} #${cachedData.selectedPrinting.collector_number}`);
                              }
                              // 3. Check basic land preferences (same as search preview and modal)
                              else if (BASIC_LAND_PRINTINGS[cardName]) {
                                preferredPrinting = BASIC_LAND_PRINTINGS[cardName];
                                // console.log(`🏔️ [DECK HOVER] Using basic land preference for ${cardName}: ${preferredPrinting}`);
                              }
                              // 4. Use deck card data as fallback
                              else {
                                // console.log(`📋 [DECK HOVER] Using deck card data for ${cardName}: ${cardData.printing || 'no printing'}`);
                              }
                            }
                          } catch (error) {
                            // console.warn(`[DECK HOVER] Error checking preferences for ${cardName}:`, error);
                            // Fall back to original deck data
                          }

                          // Create enhanced card object with foil AND consistent printing information
                          const cardWithFoil = {
                            ...cardData.cardObj,
                            foil: isExplicitlyFoil,
                            isFoil: isExplicitlyFoil,
                            name: cardData.name,
                            // CRITICAL: Use the same resolved printing as search preview and modal
                            printing: preferredPrinting,
                          };
                          
                          // console.log(`🔍 [DECK HOVER] Final card data for ${cardName}:`, {
                          //   originalPrinting: cardData.printing,
                          //   resolvedPrinting: preferredPrinting,
                          //   foilStatus: isExplicitlyFoil,
                          //   match: cardData.printing === preferredPrinting
                          // });
                          
                          handleCardHover(cardWithFoil);
                        }}
                        onClick={() => {
                          // Create a deeply cloned object to avoid reference issues
                          const baseObj = JSON.parse(
                            JSON.stringify(cardData.cardObj || {}),
                          );

                          // For basic lands, use preferred printing to match preview
                          const isBasicLand = BASIC_LAND_PRINTINGS[cardData.name];
                          let preferredPrinting = cardData.printing || baseObj.printing;
                          
                          // 🎯 CHECK USER PREFERENCE FIRST - even for basic lands
                          const userPreference = PrintingPreferences.get(cardData.name);
                          if (userPreference && userPreference.id) {
                            preferredPrinting = userPreference.id;
                            console.log(`[DeckViewEdit-Sideboard] 🎯 Using user preference for modal: ${cardData.name} → ${userPreference.set?.toUpperCase()} #${userPreference.collector_number}`);
                          } 
                          // 🎯 CHECK PRINTING CACHE SECOND - to match search preview logic
                          else {
                            const cachedData = PrintingCache.get(cardData.name);
                            if (cachedData && cachedData.selectedPrinting) {
                              preferredPrinting = cachedData.selectedPrinting.id;
                              console.log(`[DeckViewEdit-Sideboard] 💾 Using cached printing for modal: ${cardData.name} → ${cachedData.selectedPrinting.set?.toUpperCase()}`);
                            } else if (isBasicLand) {
                              preferredPrinting = BASIC_LAND_PRINTINGS[cardData.name];
                              console.log(`[DeckViewEdit-Sideboard] Using basic land default for modal: ${cardData.name} (no user preference or cache)`);
                            } else {
                              console.log(`[DeckViewEdit-Sideboard] Using fallback printing for modal: ${cardData.name} → ${preferredPrinting}`);
                            }
                          }

                          // Ensure we always have critical properties at the top level
                          // Use the actual foil property, not the extractPrice interpretation
                          const enrichedCardObj = {
                            ...baseObj,
                            name: cardData.name, // Ensure name is available at top level
                            foil: isExplicitlyFoil, // Use the actual foil property, not extractPrice interpretation
                            count: cardData.count || 1, // Ensure count is at top level
                            price: price || null, // Include the calculated price
                            // CRITICAL: Use preferred printing for basic lands to match preview
                            printing: preferredPrinting,
                          
                          // Debug: Log card data being passed to modal
                          _debug_cardData: {
                            printing: cardData.printing,
                            name: cardData.name,
                            baseObjPrinting: baseObj.printing,
                            preferredPrinting: preferredPrinting,
                            isBasicLand: !!isBasicLand,
                            cardObjCard: baseObj.card,
                            cardObjCardPrinting: baseObj.card?.printing,
                            cardObjCardScryfallId: baseObj.card?.scryfall_json?.id
                          }
                          };

                          // Ensure foil status and printing are consistent at all levels of the object
                          if (enrichedCardObj.card) {
                            enrichedCardObj.card.foil = isExplicitlyFoil;
                            // CRITICAL FIX: Update printing in nested card object for ALL cards, not just basic lands
                            // The modal relies on card.printing to determine which printing to display
                            enrichedCardObj.card.printing = preferredPrinting;
                          }

                          /*
                        // console.log('[DeckViewEdit] Opening modal with enriched card:', {
                          name: enrichedCardObj.name,
                          foil: enrichedCardObj.foil,
                          cardFoil: enrichedCardObj.card?.foil,
                          cardObjFoil: enrichedCardObj.cardObj?.foil,
                          cardObjCardFoil: enrichedCardObj.cardObj?.card?.foil
                        });
                        */

                          setModalState({
                            isOpen: true,
                            cardObj: enrichedCardObj,
                          });
                        }}
                        showMana={showMana}
                        hidePrices={hidePrices}
                        isExplicitlyFoil={isExplicitlyFoil}
                        bulkEditMode={bulkEditMode}
                        isSelected={selectedCards.has(generateCardSelectionId(cardData))}
                        onToggleSelection={() => toggleCardSelection(cardData)}
                        onContextMenu={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          
                          // Create enhanced card object for context menu
                          const cardWithFoil = {
                            ...cardData.cardObj,
                            foil: isExplicitlyFoil,
                            isFoil: isExplicitlyFoil,
                            name: cardData.name,
                            printing: cardData.printing || cardData.cardObj?.printing,
                            count: cardData.count || 1,
                            price: price || null,
                          };
                          
                          setContextMenu({
                            open: true,
                            x: e.clientX,
                            y: e.clientY,
                            cardObj: cardWithFoil,
                          });
                        }}
                      />
                    );
                  })}
                  </div>
                  {/* Render context menu at top level so it is not clipped or duplicated */}
                  {contextMenu.open && (
                    <CardContextMenu
                      x={contextMenu.x}
                      y={contextMenu.y}
                      onClose={() =>
                        setContextMenu({
                          open: false,
                          x: 0,
                          y: 0,
                          cardObj: null,
                        })
                      }
                      onUseForDeckImage={async () => {
                        const cardObj = contextMenu.cardObj;
                        if (!cardObj || !deck) {
                          toast.error("Unable to set deck image");
                          return;
                        }

                        try {
                          // Get the art_crop URL for the deck image
                          let artCropUrl = null;
                          
                          // Try to get art_crop from various possible locations
                          if (cardObj.card?.scryfall_json?.image_uris?.art_crop) {
                            artCropUrl = cardObj.card.scryfall_json.image_uris.art_crop;
                          } else if (cardObj.scryfall_json?.image_uris?.art_crop) {
                            artCropUrl = cardObj.scryfall_json.image_uris.art_crop;
                          } else if (cardObj.card?.image_uris?.art_crop) {
                            artCropUrl = cardObj.card.image_uris.art_crop;
                          } else if (cardObj.image_uris?.art_crop) {
                            artCropUrl = cardObj.image_uris.art_crop;
                          }

                          if (artCropUrl) {
                            // Update the deck with the custom preview image URL
                            const token = localStorage.getItem("token");
                            const apiUrl = import.meta.env.VITE_API_URL;
                            
                            console.log('🖼️ Setting custom deck image:', {
                              deckId: deck._id,
                              artCropUrl,
                              currentDeck: deck
                            });
                            
                            const updatePayload = {
                              name: deck.name,
                              format: deck.format,
                              cards: deck.cards,
                              customPreviewImage: artCropUrl
                            };
                            
                            console.log('📤 Sending deck update payload:', updatePayload);
                            
                            const response = await fetch(`${apiUrl}/api/decks/${deck._id}`, {
                              method: "PUT",
                              headers: {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${token}`,
                              },
                              body: JSON.stringify(updatePayload),
                              credentials: "include",
                            });

                            if (response.ok) {
                              const updatedDeck = await response.json();
                              console.log('✅ Server response for deck update:', updatedDeck);
                              setDeck(updatedDeck);
                              toast.success(`Set "${cardObj.name}" as deck image!`);
                              
                              // Store update timestamp in localStorage to trigger refresh on other pages
                              localStorage.setItem('deck-updated-timestamp', Date.now().toString());
                              
                              // Dispatch custom event to notify other components
                              window.dispatchEvent(new CustomEvent('deck-updated', { 
                                detail: { deckId: deck._id, action: 'custom-image-set' } 
                              }));
                            } else {
                              const errorText = await response.text();
                              console.error('❌ Failed to update deck:', response.status, errorText);
                              toast.error("Failed to update deck image");
                            }
                          } else {
                            toast.error("No suitable image found for this card");
                          }
                        } catch (error) {
                          console.error("Error setting deck image:", error);
                          toast.error("Failed to set deck image");
                        }
                      }}
                      onAddToWishlist={async () => {
                        const cardObj = contextMenu.cardObj;
                        if (!cardObj) {
                          toast.error("Unable to add card to wishlist");
                          return;
                        }

                        try {
                          const token = localStorage.getItem("token");
                          const apiUrl = import.meta.env.VITE_API_URL;
                          
                          // Create wishlist entry
                          const wishlistData = {
                            cardName: cardObj.name,
                            printing: cardObj.printing || null,
                            foil: cardObj.foil || false,
                            quantity: 1
                          };

                          const response = await fetch(`${apiUrl}/api/wishlist`, {
                            method: "POST",
                            headers: {
                              "Content-Type": "application/json",
                              Authorization: `Bearer ${token}`,
                            },
                            body: JSON.stringify(wishlistData),
                            credentials: "include",
                          });

                          if (response.ok) {
                            toast.success(`Added "${cardObj.name}" to wishlist!`);
                          } else {
                            const errorData = await response.json();
                            toast.error(errorData.error || "Failed to add card to wishlist");
                          }
                        } catch (error) {
                          console.error("Error adding to wishlist:", error);
                          toast.error("Failed to add card to wishlist");
                        }
                      }}
                      onAddToCollection={async () => {
                        const cardObj = contextMenu.cardObj;
                        if (!cardObj) {
                          toast.error("Unable to add card to collection");
                          return;
                        }
                        
                        // Use the existing handleAddToCollection function
                        await handleAddToCollection(cardObj);
                      }}
                      onCopyScryfallLink={async () => {
                        const cardObj = contextMenu.cardObj;
                        let scryfallUrl = null;
                        // Try to get the Scryfall page URL from card data
                        if (cardObj?.card?.scryfall_json?.scryfall_uri) {
                          scryfallUrl = cardObj.card.scryfall_json.scryfall_uri;
                        } else if (cardObj?.scryfall_json?.scryfall_uri) {
                          scryfallUrl = cardObj.scryfall_json.scryfall_uri;
                        } else if (cardObj?.card?.scryfall_uri) {
                          scryfallUrl = cardObj.card.scryfall_uri;
                        } else if (cardObj?.scryfall_uri) {
                          scryfallUrl = cardObj.scryfall_uri;
                        } else if (cardObj?.card?.name) {
                          // Fallback: construct a Scryfall search URL by name
                          scryfallUrl = `https://scryfall.com/search?q=${encodeURIComponent(cardObj.card.name)}`;
                        } else if (cardObj?.name) {
                          scryfallUrl = `https://scryfall.com/search?q=${encodeURIComponent(cardObj.name)}`;
                        }
                        if (scryfallUrl) {
                          try {
                            await navigator.clipboard.writeText(scryfallUrl);
                            toast.success("Scryfall link copied to clipboard!");
                          } catch (err) {
                            toast.error("Failed to copy Scryfall link.");
                          }
                        } else {
                          toast.error(
                            "Could not determine Scryfall link for this card.",
                          );
                        }
                      }}
                      onRemoveFromDeck={() => {
                        const cardObj = contextMenu.cardObj;
                        if (!cardObj) {
                          toast.error("Unable to remove card");
                          return;
                        }
                        
                        // Use the existing handleRemoveCard function
                        handleRemoveCard(cardObj);
                      }}
                    />
                  )}
                </div>
              ))}
            </div>
          </div>

          {/* Tech Ideas Container */}
          <div className="tech-ideas-content" style={{
            marginTop: '1rem',
            padding: '16px',
            backgroundColor: 'white',
            borderRadius: '8px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.04)',
            border: '2px solid #8b5cf6',
          }}>
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '16px',
              paddingBottom: '8px',
              borderBottom: '1px solid #e5e7eb'
            }}>
              <h3 style={{
                margin: 0,
                fontSize: '18px',
                fontWeight: '600',
                color: '#8b5cf6',
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                💡 Tech Ideas
                <span style={{
                  backgroundColor: '#8b5cf6',
                  color: 'white',
                  fontSize: '12px',
                  padding: '2px 8px',
                  borderRadius: '12px',
                  fontWeight: '500'
                }}>
                  {techIdeas.reduce((total, card) => total + (card.count || 1), 0)}
                </span>
              </h3>
            </div>

            {techIdeas.length === 0 ? (
              <div style={{
                textAlign: 'center',
                padding: '40px',
                color: '#64748b',
                fontSize: '16px'
              }}>
                <div style={{ fontSize: '32px', marginBottom: '8px' }}>💭</div>
                <p style={{ margin: 0 }}>No tech ideas yet. Add cards from search results or move them from your deck!</p>
              </div>
            ) : (
              <div
                className={`card-type-grid ${viewMode === 'grid' ? 'grid-view-mode' : ''}`}
                style={{ border: 'none' }}
              >
                {groupedAndSortedTechIdeas.map((group) => (
                  <div key={`tech-${group.type}`} className="card-type-container">
                    <CardTypeHeader
                      type={group.type}
                      count={group.cards.reduce((total, cardObj) => {
                        const quantity = cardObj.count || cardObj.quantity || 1;
                        return total + quantity;
                      }, 0)}
                    />
                    {/* Conditional container based on view mode */}
                    <div className={viewMode === 'grid' ? 'card-type-grid-container' : 'card-type-list-container'}>
                      {group.cards.map((cardData, index) => {
                        const isExplicitlyFoil = cardData.foil === true;
                        const isFoil = isExplicitlyFoil || cardData.isFoil;
                        const price = isExplicitlyFoil 
                          ? (cardData.card?.prices?.usd_foil || cardData.prices?.usd_foil || null)
                          : (cardData.card?.prices?.usd || cardData.prices?.usd || null);

                        const cardObjWithFoilStatus = {
                          ...cardData,
                          foil: isExplicitlyFoil,
                          isFoil: isExplicitlyFoil,
                          price: price,
                          fromTechIdeas: true,
                        };

                        return viewMode === 'grid' ? (
                          <GridCard
                            key={`tech-grid-${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                            cardData={cardData}
                            isFoil={isFoil}
                            price={price}
                            index={index}
                            onMouseEnter={() => handleCardHover(cardObjWithFoilStatus)}
                            onClick={() => {
                              const enrichedCardObj = {
                                ...cardObjWithFoilStatus,
                                name: cardData.name,
                                foil: isExplicitlyFoil,
                                count: cardData.count || 1,
                                price: price || null,
                                printing: cardData.printing,
                                fromTechIdeas: true
                              };

                              setModalState({
                                isOpen: true,
                                cardObj: enrichedCardObj,
                              });
                            }}
                          />
                        ) : (
                          <DeckCard
                            key={`tech-list-${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                            cardObj={{
                              name: cardData.name,
                              foil: isExplicitlyFoil,
                              count: cardData.count || 1,
                              price: price || null,
                              printing: cardData.printing,
                              card: cardData.card,
                              cardObj: cardData.cardObj,
                              scryfall_json: cardData.scryfall_json,
                              fromTechIdeas: true
                            }}
                            onClick={() => {
                              const enrichedCardObj = {
                                ...cardObjWithFoilStatus,
                                name: cardData.name,
                                foil: isExplicitlyFoil,
                                count: cardData.count || 1,
                                price: price || null,
                                printing: cardData.printing,
                                fromTechIdeas: true
                              };

                              setModalState({
                                isOpen: true,
                                cardObj: enrichedCardObj,
                              });
                            }}
                            onMouseEnter={() => handleCardHover(cardObjWithFoilStatus)}
                            showMana={showMana}
                            hidePrices={hidePrices}
                            isExplicitlyFoil={isExplicitlyFoil}
                            bulkEditMode={false}
                            isSelected={false}
                            onToggleSelection={() => {}}
                            onContextMenu={(e) => {
                              e.preventDefault();
                              e.stopPropagation();
                              
                              const cardWithFoil = {
                                ...cardData.cardObj,
                                foil: isExplicitlyFoil,
                                isFoil: isExplicitlyFoil,
                                name: cardData.name,
                                printing: cardData.printing || cardData.cardObj?.printing,
                                count: cardData.count || 1,
                                price: price || null,
                                fromTechIdeas: true
                              };
                              
                              setContextMenu({
                                open: true,
                                x: e.clientX,
                                y: e.clientY,
                                cardObj: cardWithFoil,
                              });
                            }}
                          />
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Sideboard Container */}
          <div className="sideboard-content" style={{
            marginTop: '1rem',
            padding: '16px',
            backgroundColor: 'white',
            borderRadius: '8px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.04)',
            border: '2px solid #f59e0b',
          }}>
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '16px',
              paddingBottom: '8px',
              borderBottom: '1px solid #e5e7eb'
            }}>
              <h3 style={{
                margin: 0,
                fontSize: '18px',
                fontWeight: '600',
                color: '#f59e0b',
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                📋 Sideboard
                <span style={{
                  backgroundColor: '#f59e0b',
                  color: 'white',
                  fontSize: '12px',
                  padding: '2px 8px',
                  borderRadius: '12px',
                  fontWeight: '500'
                }}>
                  {sideboard.reduce((total, card) => total + (card.count || 1), 0)}
                </span>
              </h3>
            </div>

            {sideboard.length === 0 ? (
              <div style={{
                textAlign: 'center',
                padding: '40px',
                color: '#64748b',
                fontSize: '16px'
              }}>
                <div style={{ fontSize: '32px', marginBottom: '8px' }}>📝</div>
                <p style={{ margin: 0 }}>No sideboard cards yet. Move cards from your deck or add them from search results!</p>
              </div>
            ) : (
              <div
                className={`card-type-grid ${viewMode === 'grid' ? 'grid-view-mode' : ''}`}
                style={{ border: 'none' }}
              >
                {groupedAndSortedSideboard.map((group) => (
                  <div key={`sideboard-${group.type}`} className="card-type-container">
                    <CardTypeHeader
                      type={group.type}
                      count={group.cards.reduce((total, cardObj) => {
                        const quantity = cardObj.count || cardObj.quantity || 1;
                        return total + quantity;
                      }, 0)}
                    />
                    {/* Conditional container based on view mode */}
                    <div className={viewMode === 'grid' ? 'card-type-grid-container' : 'card-type-list-container'}>
                      {group.cards.map((cardData, index) => {
                        const isExplicitlyFoil = cardData.foil === true;
                        const isFoil = isExplicitlyFoil || cardData.isFoil;
                        const price = isExplicitlyFoil 
                          ? (cardData.card?.prices?.usd_foil || cardData.prices?.usd_foil || null)
                          : (cardData.card?.prices?.usd || cardData.prices?.usd || null);

                        const cardObjWithFoilStatus = {
                          ...cardData,
                          foil: isExplicitlyFoil,
                          isFoil: isExplicitlyFoil,
                          price: price,
                          fromSideboard: true,
                        };

                        return viewMode === 'grid' ? (
                          <GridCard
                            key={`sideboard-grid-${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                            cardData={cardData}
                            isFoil={isFoil}
                            price={price}
                            index={index}
                            onMouseEnter={() => handleCardHover(cardObjWithFoilStatus)}
                            onClick={() => {
                              const enrichedCardObj = {
                                ...cardObjWithFoilStatus,
                                name: cardData.name,
                                foil: isExplicitlyFoil,
                                count: cardData.count || 1,
                                price: price || null,
                                printing: cardData.printing,
                                fromSideboard: true
                              };

                              setModalState({
                                isOpen: true,
                                cardObj: enrichedCardObj,
                              });
                            }}
                          />
                        ) : (
                          <DeckCard
                            key={`sideboard-list-${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                            cardObj={{
                              name: cardData.name,
                              foil: isExplicitlyFoil,
                              count: cardData.count || 1,
                              price: price || null,
                              printing: cardData.printing,
                              card: cardData.card,
                              cardObj: cardData.cardObj,
                              scryfall_json: cardData.scryfall_json,
                              fromSideboard: true
                            }}
                            onClick={() => {
                              const enrichedCardObj = {
                                ...cardObjWithFoilStatus,
                                name: cardData.name,
                                foil: isExplicitlyFoil,
                                count: cardData.count || 1,
                                price: price || null,
                                printing: cardData.printing,
                                fromSideboard: true
                              };

                              setModalState({
                                isOpen: true,
                                cardObj: enrichedCardObj,
                              });
                            }}
                            onMouseEnter={() => handleCardHover(cardObjWithFoilStatus)}
                            showMana={showMana}
                            hidePrices={hidePrices}
                            isExplicitlyFoil={isExplicitlyFoil}
                            bulkEditMode={false}
                            isSelected={false}
                            onToggleSelection={() => {}}
                            onContextMenu={(e) => {
                              e.preventDefault();
                              e.stopPropagation();
                              
                              const cardWithFoil = {
                                ...cardData.cardObj,
                                foil: isExplicitlyFoil,
                                isFoil: isExplicitlyFoil,
                                name: cardData.name,
                                printing: cardData.printing || cardData.cardObj?.printing,
                                count: cardData.count || 1,
                                price: price || null,
                                fromSideboard: true
                              };
                              
                              setContextMenu({
                                open: true,
                                x: e.clientX,
                                y: e.clientY,
                                cardObj: cardWithFoil,
                              });
                            }}
                          />
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>

        {/* Search Results Modal */}
        {showSearchModal && (
            <div style={{
              textAlign: 'center',
              padding: '40px',
              color: '#64748b',
              fontSize: '16px'
            }}>
              <div style={{ fontSize: '32px', marginBottom: '8px' }}>💭</div>
              <p style={{ margin: 0 }}>No tech ideas yet. Add cards from search results or move them from your deck!</p>
            </div>
          ) : (
            <div
              className={`card-type-grid ${viewMode === 'grid' ? 'grid-view-mode' : ''}`}
              style={{ border: 'none' }}
            >
              {groupedAndSortedTechIdeas.map((group) => (
                <div key={`tech-${group.type}`} className="card-type-container">
                  <CardTypeHeader
                    type={group.type}
                    count={group.cards.reduce((total, cardObj) => {
                      const quantity = cardObj.count || cardObj.quantity || 1;
                      return total + quantity;
                    }, 0)}
                  />
                  {/* Conditional container based on view mode */}
                  <div style={viewMode === 'grid' ? {
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(150px, 1fr))',
                    gap: '8px',
                    paddingTop: '8px',
                    paddingBottom: '8px',
                    width: '100%',
                    boxSizing: 'border-box',
                    justifyItems: 'center'
                  } : {}}>
                    {group.cards.map((cardObj, index) => {
                      const cardData = cardObj.cardObj
                        ? cardObj
                        : {
                            name: cardObj.card?.name || cardObj.name,
                            count: cardObj.count || cardObj.quantity || 1,
                            printing: cardObj.printing,
                            cardObj,
                          };

                      const isExplicitlyFoil = cardData.foil === true ||
                                              cardObj.foil === true ||
                                              cardData.cardObj?.foil === true ||
                                              cardData.cardObj?.card?.foil === true ||
                                              cardObj.card?.foil === true;

                      const cardObjWithFoilStatus = JSON.parse(JSON.stringify(cardData.cardObj || cardObj));
                      if (cardObjWithFoilStatus) {
                        cardObjWithFoilStatus.foil = isExplicitlyFoil;
                        if (cardObjWithFoilStatus.card) {
                          cardObjWithFoilStatus.card.foil = isExplicitlyFoil;
                        }
                      }

                      const price = extractPrice(cardObjWithFoilStatus)?.price || null;
                      const isFoil = isExplicitlyFoil;

                      return viewMode === 'grid' ? (
                        <GridCard
                          key={`tech-grid-${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                          cardData={cardData}
                          isFoil={isFoil}
                          price={price}
                          index={index}
                          onMouseEnter={() => handleCardHover(cardObjWithFoilStatus)}
                          onClick={() => {
                            const enrichedCardObj = {
                              ...cardObjWithFoilStatus,
                              name: cardData.name,
                              foil: isExplicitlyFoil,
                              count: cardData.count || 1,
                              price: price || null,
                              printing: cardData.printing,
                              fromTechIdeas: true
                            };

                            setModalState({
                              isOpen: true,
                              cardObj: enrichedCardObj,
                            });
                          }}
                          bulkEditMode={bulkEditMode}
                          isSelected={false}
                          onToggleSelection={() => {}}
                        />
                      ) : (
                        <DeckCardRow
                          key={`tech-row-${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                          cardData={cardData}
                          isFoil={isFoil}
                          price={price}
                          index={index}
                          onMouseEnter={() => handleCardHover(cardObjWithFoilStatus)}
                          onClick={() => {
                            const enrichedCardObj = {
                              ...cardObjWithFoilStatus,
                              name: cardData.name,
                              foil: isExplicitlyFoil,
                              count: cardData.count || 1,
                              price: price || null,
                              printing: cardData.printing,
                              fromTechIdeas: true
                            };

                            setModalState({
                              isOpen: true,
                              cardObj: enrichedCardObj,
                            });
                          }}
                          showMana={showMana}
                          hidePrices={hidePrices}
                          isExplicitlyFoil={isExplicitlyFoil}
                          bulkEditMode={false}
                          isSelected={false}
                          onToggleSelection={() => {}}
                          onContextMenu={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const cardWithFoil = {
                              ...cardData.cardObj,
                              foil: isExplicitlyFoil,
                              isFoil: isExplicitlyFoil,
                              name: cardData.name,
                              printing: cardData.printing || cardData.cardObj?.printing,
                              count: cardData.count || 1,
                              price: price || null,
                              fromTechIdeas: true
                            };
                            
                            setContextMenu({
                              open: true,
                              x: e.clientX,
                              y: e.clientY,
                              cardObj: cardWithFoil,
                            });
                          }}
                        />
                      );
                    })}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Sideboard Container */}
        <div className="sideboard-content" style={{
          marginTop: '1rem',
          padding: '16px',
          backgroundColor: 'white',
          borderRadius: '8px',
          boxShadow: '0 2px 8px rgba(0,0,0,0.04)',
          border: '2px solid #f59e0b',
        }}>
          <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: '16px',
            paddingBottom: '8px',
            borderBottom: '1px solid #e5e7eb'
          }}>
            <h3 style={{
              margin: 0,
              fontSize: '18px',
              fontWeight: '600',
              color: '#f59e0b',
              display: 'flex',
              alignItems: 'center',
              gap: '8px'
            }}>
              📋 Sideboard
              <span style={{
                backgroundColor: '#f59e0b',
                color: 'white',
                fontSize: '12px',
                padding: '2px 8px',
                borderRadius: '12px',
                fontWeight: '500'
              }}>
                {sideboard.reduce((total, card) => total + (card.count || 1), 0)}
              </span>
            </h3>
          </div>

          {sideboard.length === 0 ? (
            <div style={{
              textAlign: 'center',
              padding: '40px',
              color: '#64748b',
              fontSize: '16px'
            }}>
              <div style={{ fontSize: '32px', marginBottom: '8px' }}>📋</div>
              <p style={{ margin: 0 }}>No sideboard cards yet. Add cards from search results or move them from your deck!</p>
            </div>
          ) : (
            <div
              className={`card-type-grid ${viewMode === 'grid' ? 'grid-view-mode' : ''}`}
              style={{ border: 'none' }}
            >
              {groupedAndSortedSideboard.map((group) => (
                <div key={`sideboard-${group.type}`} className="card-type-container">
                  <CardTypeHeader
                    type={group.type}
                    count={group.cards.reduce((total, cardObj) => {
                      const quantity = cardObj.count || cardObj.quantity || 1;
                      return total + quantity;
                    }, 0)}
                  />
                  {/* Conditional container based on view mode */}
                  <div style={viewMode === 'grid' ? {
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fill, minmax(150px, 1fr))',
                    gap: '8px',
                    paddingTop: '8px',
                    paddingBottom: '8px',
                    width: '100%',
                    boxSizing: 'border-box',
                    justifyItems: 'center'
                  } : {}}>
                    {group.cards.map((cardObj, index) => {
                      const cardData = cardObj.cardObj
                        ? cardObj
                        : {
                            name: cardObj.card?.name || cardObj.name,
                            count: cardObj.count || cardObj.quantity || 1,
                            printing: cardObj.printing,
                            cardObj,
                          };

                      const isExplicitlyFoil = cardData.foil === true ||
                                              cardObj.foil === true ||
                                              cardData.cardObj?.foil === true ||
                                              cardData.cardObj?.card?.foil === true ||
                                              cardObj.card?.foil === true;

                      const cardObjWithFoilStatus = JSON.parse(JSON.stringify(cardData.cardObj || cardObj));
                      if (cardObjWithFoilStatus) {
                        cardObjWithFoilStatus.foil = isExplicitlyFoil;
                        if (cardObjWithFoilStatus.card) {
                          cardObjWithFoilStatus.card.foil = isExplicitlyFoil;
                        }
                      }

                      const price = extractPrice(cardObjWithFoilStatus)?.price || null;
                      const isFoil = isExplicitlyFoil;

                      return viewMode === 'grid' ? (
                        <GridCard
                          key={`sideboard-grid-${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                          cardData={cardData}
                          isFoil={isFoil}
                          price={price}
                          index={index}
                          onMouseEnter={() => handleCardHover(cardObjWithFoilStatus)}
                          onClick={() => {
                            const enrichedCardObj = {
                              ...cardObjWithFoilStatus,
                              name: cardData.name,
                              foil: isExplicitlyFoil,
                              count: cardData.count || 1,
                              price: price || null,
                              printing: cardData.printing,
                              fromSideboard: true
                            };

                            setModalState({
                              isOpen: true,
                              cardObj: enrichedCardObj,
                            });
                          }}
                          bulkEditMode={bulkEditMode}
                          isSelected={false}
                          onToggleSelection={() => {}}
                        />
                      ) : (
                        <DeckCardRow
                          key={`sideboard-row-${cardData.name}-${cardData.printing || ""}-${cardData.count}-${isExplicitlyFoil ? "foil" : "nonfoil"}-${price || "na"}-${index}`}
                          cardData={cardData}
                          isFoil={isFoil}
                          price={price}
                          index={index}
                          onMouseEnter={() => handleCardHover(cardObjWithFoilStatus)}
                          onClick={() => {
                            const enrichedCardObj = {
                              ...cardObjWithFoilStatus,
                              name: cardData.name,
                              foil: isExplicitlyFoil,
                              count: cardData.count || 1,
                              price: price || null,
                              printing: cardData.printing,
                              fromSideboard: true
                            };

                            setModalState({
                              isOpen: true,
                              cardObj: enrichedCardObj,
                            });
                          }}
                          showMana={showMana}
                          hidePrices={hidePrices}
                          isExplicitlyFoil={isExplicitlyFoil}
                          bulkEditMode={false}
                          isSelected={false}
                          onToggleSelection={() => {}}
                          onContextMenu={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const cardWithFoil = {
                              ...cardData.cardObj,
                              foil: isExplicitlyFoil,
                              isFoil: isExplicitlyFoil,
                              name: cardData.name,
                              printing: cardData.printing || cardData.cardObj?.printing,
                              count: cardData.count || 1,
                              price: price || null,
                              fromSideboard: true
                            };
                            
                            setContextMenu({
                              open: true,
                              x: e.clientX,
                              y: e.clientY,
                              cardObj: cardWithFoil,
                            });
                          }}
                        />
                      );
                    })}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Search Results Modal */}
        {showSearchModal && (
          <div
            data-search-modal="true"
            style={{
              position: "fixed",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: "rgba(0, 0, 0, 0.8)",
              zIndex: 10000,
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              padding: "20px",
            }}
            onClick={(e) => {
              if (e.target === e.currentTarget) {
                setShowSearchModal(false);
              }
            }}
            onKeyDown={(e) => {
              if (e.key === 'Escape') {
                setShowSearchModal(false);
              }
            }}
            tabIndex={-1}
          >
            <div
              style={{
                backgroundColor: "white",
                borderRadius: "12px",
                width: "95%",
                maxWidth: "1400px",
                height: "90%",
                maxHeight: "900px",
                display: "flex",
                flexDirection: "column",
                boxShadow: "0 25px 50px rgba(0, 0, 0, 0.4)",
                overflow: "hidden",
              }}
              onClick={(e) => e.stopPropagation()}
            >
              {/* Modal Header - Clean white style like the screenshot */}
              <div
                style={{
                  background: "white",
                  padding: "20px 24px",
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  borderBottom: "1px solid #e5e7eb",
                }}
              >
                <div>
                  <h2 style={{ margin: 0, fontSize: "18px", fontWeight: "500", color: "#374151" }}>
                    Search Results for "{search}"
                  </h2>
                  <p style={{ margin: "4px 0 0 0", fontSize: "14px", color: "#6b7280" }}>
                    Found {allSearchResults.length} results
                  </p>
                </div>
                <button
                  onClick={() => setShowSearchModal(false)}
                  style={{
                    background: "none",
                    border: "none",
                    color: "#6b7280",
                    fontSize: "24px",
                    cursor: "pointer",
                    padding: "4px",
                    borderRadius: "4px",
                    transition: "all 0.2s ease",
                  }}
                  onMouseEnter={(e) => {
                    e.target.style.backgroundColor = "#f3f4f6";
                    e.target.style.color = "#374151";
                  }}
                  onMouseLeave={(e) => {
                    e.target.style.backgroundColor = "transparent";
                    e.target.style.color = "#6b7280";
                  }}
                >
                  ×
                </button>
              </div>

              {/* Modal Content */}
              <div
                style={{
                  flex: 1,
                  padding: "24px",
                  overflowY: "auto",
                  background: "white",
                }}
              >
                {searchModalLoading ? (
                  <div
                    style={{
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "center",
                      height: "200px",
                      flexDirection: "column",
                      gap: "16px",
                    }}
                  >
                    <div
                      style={{
                        width: "40px",
                        height: "40px",
                        border: "4px solid #e2e8f0",
                        borderTop: "4px solid #6366f1",
                        borderRadius: "50%",
                        animation: "spin 1s linear infinite",
                      }}
                    />
                    <div style={{ fontSize: "16px", color: "#666" }}>
                      Loading search results...
                    </div>
                  </div>
                ) : allSearchResults.length > 0 ? (
                  <>
                    {console.log('🎭 Modal rendering with', allSearchResults.length, 'results')}
                    <div
                      style={{
                        display: "grid",
                        gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))",
                        gap: "16px",
                        maxWidth: "100%",
                      }}
                    >
                      {allSearchResults.map((card, index) => (
                        <div
                          key={`${card.scryfall_id || card.id}-${index}`}
                          style={{
                            background: "white",
                            borderRadius: "8px",
                            overflow: "hidden",
                            boxShadow: "0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)",
                            transition: "all 0.2s ease",
                            border: "1px solid #e5e7eb",
                            display: "flex",
                            flexDirection: "column",
                          }}
                          onMouseEnter={(e) => {
                            e.currentTarget.style.transform = "translateY(-2px)";
                            e.currentTarget.style.boxShadow = "0 4px 8px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12)";
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.transform = "translateY(0)";
                            e.currentTarget.style.boxShadow = "0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)";
                          }}
                        >
                          {/* Card Image */}
                          {(card.image_uris?.normal || card.image_uris?.small) && (
                            <div
                              style={{
                                width: "100%",
                                aspectRatio: "5/7",
                                backgroundImage: `url(${card.image_uris?.normal || card.image_uris?.small})`,
                                backgroundSize: "cover",
                                backgroundPosition: "center",
                                backgroundRepeat: "no-repeat",
                                cursor: "zoom-in",
                              }}
                              onClick={() => {
                                // Open image in new tab
                                window.open(card.image_uris?.normal || card.image_uris?.small, '_blank');
                              }}
                              title={`${card.name} - Click to view larger`}
                            />
                          )}
                          
                          {/* Action Buttons */}
                          <div style={{ 
                            padding: "12px",
                            display: "flex", 
                            flexDirection: "column", 
                            gap: "6px"
                          }}>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleAddCard(card);
                                  setShowSearchModal(false);
                                  setSearch("");
                                }}
                                style={{
                                  background: "#3b82f6",
                                  color: "white",
                                  border: "none",
                                  padding: "8px 16px",
                                  borderRadius: "6px",
                                  fontSize: "13px",
                                  fontWeight: "500",
                                  cursor: "pointer",
                                  transition: "background-color 0.2s ease",
                                  width: "100%",
                                }}
                                onMouseEnter={(e) => {
                                  e.target.style.backgroundColor = "#2563eb";
                                }}
                                onMouseLeave={(e) => {
                                  e.target.style.backgroundColor = "#3b82f6";
                                }}
                              >
                                Add to Deck
                              </button>
                              
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleAddToTechIdeas(card);
                                }}
                                style={{
                                  background: "#8b5cf6",
                                  color: "white",
                                  border: "none",
                                  padding: "8px 16px",
                                  borderRadius: "6px",
                                  fontSize: "13px",
                                  fontWeight: "500",
                                  cursor: "pointer",
                                  transition: "background-color 0.2s ease",
                                  width: "100%",
                                }}
                                onMouseEnter={(e) => {
                                  e.target.style.backgroundColor = "#7c3aed";
                                }}
                                onMouseLeave={(e) => {
                                  e.target.style.backgroundColor = "#8b5cf6";
                                }}
                              >
                                Add to Tech Ideas
                              </button>
                              
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleAddToSideboard(card);
                                }}
                                style={{
                                  background: "#f59e0b",
                                  color: "white",
                                  border: "none",
                                  padding: "8px 16px",
                                  borderRadius: "6px",
                                  fontSize: "13px",
                                  fontWeight: "500",
                                  cursor: "pointer",
                                  transition: "background-color 0.2s ease",
                                  width: "100%",
                                }}
                                onMouseEnter={(e) => {
                                  e.target.style.backgroundColor = "#d97706";
                                }}
                                onMouseLeave={(e) => {
                                  e.target.style.backgroundColor = "#f59e0b";
                                }}
                              >
                                Add to Sideboard
                              </button>
                              
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleAddToShoppingCart(card);
                                }}
                                style={{
                                  background: "#059669",
                                  color: "white",
                                  border: "none",
                                  padding: "8px 12px",
                                  borderRadius: "6px",
                                  fontSize: "12px",
                                  fontWeight: "500",
                                  cursor: "pointer",
                                  transition: "background-color 0.2s ease",
                                  width: "100%",
                                }}
                                onMouseEnter={(e) => {
                                  e.target.style.backgroundColor = "#047857";
                                }}
                                onMouseLeave={(e) => {
                                  e.target.style.backgroundColor = "#059669";
                                }}
                              >
                                Add to Shopping Cart
                              </button>
                            </div>
                        </div>
                      ))}
                    </div>
                  </>
                ) : (
                  <div
                    style={{
                      textAlign: "center",
                      padding: "60px 40px",
                      color: "#64748b",
                      fontSize: "18px",
                    }}
                  >
                    <div style={{ fontSize: "48px", marginBottom: "16px" }}>🔍</div>
                    <h3 style={{ margin: "0 0 8px 0", color: "#374151" }}>No Results Found</h3>
                    <p style={{ margin: 0 }}>No cards found matching "{search}"</p>
                  </div>
                )}
              </div>
            </div>
          </div>
        )}

        {modalState.isOpen && modalState.cardObj && (
          <CardActionsModal
            isOpen={modalState.isOpen}
            onClose={() => setModalState({ isOpen: false, cardObj: null })}
            card={modalState.cardObj}
            onUpdateCard={handleUpdateCard}
            onRemoveCard={handleRemoveCard}
            onMoveToSideboard={handleMoveToSideboard}
            onMoveToTechIdeas={(cardObj) => {
              // Get the proper source card data
              const sourceCardData = cardObj.cardObj || cardObj.card || cardObj;
              
              // Create the card data in the expected format
              const techIdeasCard = {
                name: cardObj.name || cardObj.card?.name,
                count: cardObj.count || 1,
                printing: cardObj.printing || cardObj.cardObj?.printing,
                foil: cardObj.foil,
                card: {
                  name: sourceCardData.name,
                  type_line: sourceCardData.type_line,
                  scryfall_json: sourceCardData,
                  printing: cardObj.printing || sourceCardData.id || sourceCardData.scryfall_id
                },
                cardObj: sourceCardData,
                scryfall_json: sourceCardData,
                addedToTechIdeas: Date.now()
              };
              
              let updatedCards = cards;
              let updatedSideboard = sideboard;
              
              // Check if card is from sideboard and remove it
              if (cardObj.fromSideboard) {
                updatedSideboard = sideboard.filter(card => 
                  !(card.name === techIdeasCard.name && 
                    card.printing === techIdeasCard.printing && 
                    card.foil === techIdeasCard.foil)
                );
                
                setSideboard(updatedSideboard);
                
                // Update deck object to remove from sideboard
                setDeck(prevDeck => ({
                  ...prevDeck,
                  sideboard: updatedSideboard,
                  techIdeas: [...(prevDeck.techIdeas || []), techIdeasCard],
                  lastUpdated: Date.now()
                }));
              } else if (cardObj.fromTechIdeas) {
                // If already in tech ideas, don't duplicate
                toast.info(`"${techIdeasCard.name}" is already in tech ideas`);
                setModalState({ isOpen: false, cardObj: null });
                return;
              } else {
                // Card is from main deck - remove it and get updated array
                updatedCards = cards.filter((c) => {
                  const cName = c.name || c.card?.name || c.cardObj?.name || c.cardObj?.card?.name;
                  const cPrinting = c.printing || c.cardObj?.printing;
                  const cFoil = c.foil;
                  
                  const removeName = cardObj.name || cardObj.cardObj?.name || cardObj.cardObj?.card?.name;
                  const removePrinting = cardObj.printing || cardObj.cardObj?.printing;
                  const removeFoil = cardObj.foil;
                  
                  return !(cName === removeName && cPrinting === removePrinting && cFoil === removeFoil);
                });
                
                setCards(updatedCards);
                
                // Update deck object to add to tech ideas
                setDeck(prevDeck => ({
                  ...prevDeck,
                  cards: updatedCards,
                  techIdeas: [...(prevDeck.techIdeas || []), techIdeasCard],
                  lastUpdated: Date.now()
                }));
              }
              
              // Add to tech ideas
              const updatedTechIdeas = [...techIdeas, techIdeasCard];
              setTechIdeas(updatedTechIdeas);

              setModalState({ isOpen: false, cardObj: null });
              toast.success(`Moved "${techIdeasCard.name}" to tech ideas`);

              // Save to server with updated arrays
              (async () => {
                try {
                  const token = localStorage.getItem("token");
                  if (!token) return;

                  // Format the cards properly for the server using updated array
                  const formattedCards = updatedCards.map((card) => {
                    const formattedCard = {
                      name: card.name || card.card?.name || "",
                      printing: card.printing || null,
                      foil: card.foil === true,
                    };

                    if (card.card && card.card._id) {
                      formattedCard.card = {
                        _id: card.card._id,
                        name: card.card.name,
                      };
                    } else if (card._id) {
                      formattedCard._id = card._id;
                    }

                    return formattedCard;
                  });

                  // Format the tech ideas properly for the server using updated array
                  const formattedTechIdeas = updatedTechIdeas.map((card) => ({
                    name: card.name || card.card?.name || "",
                    printing: card.printing || null,
                    foil: card.foil === true,
                    card: card.card || { name: card.name },
                    addedToTechIdeas: card.addedToTechIdeas || Date.now()
                  }));

                  // Format the sideboard properly for the server using updated array
                  const formattedSideboard = updatedSideboard.map((card) => ({
                    name: card.name || card.card?.name || "",
                    printing: card.printing || null,
                    foil: card.foil === true,
                    card: card.card || { name: card.name },
                    addedToSideboard: card.addedToSideboard || Date.now()
                  }));

                  console.log(`[DeckViewEdit] Saving to server - Cards: ${formattedCards.length}, Sideboard: ${formattedSideboard.length}, Tech Ideas: ${formattedTechIdeas.length}`);

                  const apiUrl = import.meta.env.VITE_API_URL;
                  await fetch(`${apiUrl}/api/decks/${deck._id}`, {
                    method: "PUT",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${token}`,
                    },
                    body: JSON.stringify({
                      name: deck.name,
                      format: deck.format,
                      cards: formattedCards,
                      sideboard: formattedSideboard,
                      techIdeas: formattedTechIdeas,
                    }),
                    credentials: "include",
                  });
                } catch (error) {
                  console.error("Error saving tech ideas to server:", error);
                  toast.error("Card moved locally but failed to save to server");
                }
              })();
            }}
            onAddToCollection={handleAddToCollection}
            onPreviewUpdate={handlePreviewUpdate}
            onOracleTagSearch={handleOracleTagSearchModal}
            updatingPrinting={updatingPrinting}
          />
        )}
      </div>
    </>
  );
}
